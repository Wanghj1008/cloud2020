SpringMVC：
    拦截用户请求,DispatcherServlet承担中介职责将用户请求通过HandlerMapping去匹配controller,然后controller执行具体操作

架构分层：
    1.视图层：视图层和控制层结合紧密,视图层主要是页面的展示
    2.控制层：控制要调用的业务层代码
    3.业务层：业务代码的逻辑处理，可能会涉及到持久层接口的调用
    4.持久层：负责与数据库交互,进行CRUD的操作
SSM原理流程：
    1.客户端发送请求到DispatcherServlet
    2.DispatcherServlet控制器查询HandlerMapping,找到对应Controller
    3.Controller调用Service进行业务处理,处理中可能涉及到去DAO进行数据库操作。最终将响应返回给客户端
低耦合高内聚： https://blog.csdn.net/ws9029/article/details/116454153
    低耦合：模块和模块之间交互不可避免,交互性低也就是耦合低才能让模块直接增加独立性。实现多模块可拆卸
    高内聚：功能内聚,一个模块只需要做自己负责的事情,不过分关心其他事情。 保证模块拆卸过程中对功能控制的精准性
    总结：低耦合高内聚的思想其实就是将系统分成多个模块分而治之的思想。对系统来说将会有更高的可靠性.系统升级微服务也轻松一些
Spring： 开源的轻量级框架,简化应用程序开发,降低耦合度。
    1.IOC(控制反转):让Spring帮助创建对象以及管理对象之间的依赖关系,降低对象间耦合度
        容器初始化过程：
            1.XML方式
                1.创建 ClassPathXmlApplicationContext 调用构造方法时,
                    一、先是调用顶层父构造方法对部分属性初始化
                    二、调用父类setConfigLocations设置传入属性值,Spring配置文件路径
                    三、调用父类refresh方法对xml中bean进行载入封装
                        1.判断是否存在Spring容器,存在销毁然后创建,保证refresh创建的时新的容器
                        2.通过路径将XML解析成文档对象,然后封装程key-value存入一个Map中,这个过程加锁保证线程安全. key为String value为BeanDefinition（内部封装 单例、多例、参数）
            2.注解方式
                1.配置自动扫描路径,启动时会根据路径对所有类进行扫描
                2.直接将含注解的bean注册到容器中
        Bean实例化参数配置： //todo 了解动态代理和CGlib代码 搭配作用域scope使用
            1.scope(默认单例)  注解方式：@Scope(value = WebApplicationContext.SCOPE_SESSION,  proxyMode =ScopedProxyMode.INTERFACES)
                1.singleton：单例 ：每一个bean只有一个实例。Spring创建就会被加载,生命周期和Spring一致。
                2.prototype：多例 (懒加载,用的时候才走初始化用完就会销毁)：每次对bean的请求都会创建一个实例
                3.request：请求,每次HTTP请求都会生成一个bean,表示在一次HTTP内有效
                4.session：在同一个session内,使用一个bean
                5.global session：在一个全局session内 使用一个bean
            2.id、class：id自定义一般为类开头字母小写、class为全路径名
            3.init-method 初始化方法
            4.destroy-method 销毁方法
        Bean实例化方式
            1.无参构造：<bean id="bean1" class="demo3.Bean1">
            2.工厂静态方法： <bean id="bean2" class="demo3.Bean2Factory" factory-method="getBean2">
            3.工厂实例方法： <bean id="bean3Factory" class="demo3.Bean3Factory"> <bean id="bean3" factory-bean="bean3Factory" factory-method="getBean3">
        依赖注入： 优点:将对象的依赖关系交给容器自动化完成,解耦合    缺点：实例bean源码复杂,不易学习。 通过反射创建对象有损耗,但是从便利性和实用性这点损耗可以忽略
            1.构造方法：优点：自动寻找bean进行注入 缺点：可能存在多个构造方法,不方便维护。 但是IDEA仍然推荐这种方法进行代码书写(优点：保证依赖不为空避免空指针)  如果一个依赖有多种实现推荐使用set注入
            2.setter方法：优点：可以继承、设置默认值、用的时候进行注入  缺点：无法在对象构造完成后立刻使用 需要调用set方法  可以搭配Required注解强制要求使用者注入该属性
            3.接口注入：使用较少,因为强制被注入对象实现接口
            4.P指针注入(本质就是set)：配置文件使用较多 优点：代码整洁  缺点：可维护性不高,如果属性多会导致配置过长
        依赖注入注解：
            1.Autowired:按类型自动装配
            2.Qualifier:不能单独使用,配合 Autowired按名称自动装配,需要Autowired后面增加装配名称
            3.Resource：默认按名称装配,找不到按照类型装配！  Spring提供注解 但是实现需要引入第三方工具 javax.annotation.jar
            4.Value：⽤于注⼊基本类型,可以标注在成员变量上,set方法上。不能标注构造方法上！！
            5.Bean：作用在方法上,将方法返回的类注入到容器中
            6.PathVariable：用来接收路径参数的注解
            6.Configuration：等同于Bean.xml,通过annotationConfigApplicationContext加载,
            7.Component:等同于application.xml,通过ClassPathXmlApplicationContext加载
            8.Repository|Service|Controller:DAO、业务层、控制层特殊的注解,作用和Component相同
            9.Configuration和Component区别：
                官方解释：1.加载方式不同   //todo 2.Configuration会进行cglib代理(简化就是获取bean 一种获取到的是代理对象  一种获取到的原始对象)
    2.AOP(切面编程): 代码重复部分抽出来,通过动态代理技术在不改变源码基础上进行代码增强  常用于：权限控制、日志处理、事务等
        1.相关注解
            1.Aspect(切面)： 会包含一些切点以及相应的增强
                1.Before前置通知：目标方法调用前调用通知方法
                2.After后置通知：目标方法调用后调用通知方法
                3.After-returning最终通知：目标方法成功执行之后调用通知方法  (异常不执行)
                4.After-throwing异常通知：目标方法抛出异常后调用通知方法
                5.Around环绕通知：目标方法调用前和调用后都调用通知方法
                区别：
                正常执行顺序： 环绕前置-》前置通知-》执行代码-》环绕之后-》后置通知-》最终通知
                异常执行顺序： 环绕前置-》前置通知-》执行代码-》环绕之后-》后置通知-》异常通知
                注意：只有当环绕后置未对异常处理继续抛出时候才会出现异常 否则就会进行最终通知
            2.JoinPoint(连接点)：程序中某一行为,例如执行过程中所有字段、方法都是连接点。 Spring只支持方法类型连接点
            3.Pointcut(切点)：我们自定义要拦截的连接点组合就可以称为切点！！
            4.Weaving(织入):把切面增强内容应用到目标对象并创建代理对象的过程
        2.代理对象生成时机？
            1.初始化的时候会找到所有实现 BeanPostProcessor 的子类进行遍历执行初始化后置方法,其中一个就是实现AOP动态代理,内部会判断是否有增强
            如果有增强方法就会通过class判断使用CGLIB还是JDK生成代理对象
        3.为什么三级缓存解决AOP循环依赖问题？
            由上述可知,初始化结束才能获取到代理对象,如果AB都需要对方代理对象,如果没有三级缓存,就会造成一方获取到的是原始对象,导致一个保存的原始对象和一级缓存的代理对象产生误差
            而三级缓存内部其实提前调用了,初始化之后的方法获取代理对象.
        多个AOP执行先后顺序？
            1.xml通过order属性配置   2.注解使用order注解  3.实现类ordered重写getOrder方法实现多个AOP按序执行,order越小越先执行
            执行过程中切面顺序和多个过滤器一致,最先开始的切面最后结束！！！！
    3.事务控制：  Spring事务本质上是数据库对事务的支持,没有数据库的支持,Spring是无法提供事务这个功能的
        1.原生JDBC与SpringJDBC区别：
            1.源生JDBC使用事务： 1.获取连接 2.setAutoCommit开启事务  3.执行业务sql  4.commit提交/rollback回滚事务   5.关闭连接   实际是通过binLog或redLog实现的
            2.Spring事务: 不需要手动开启提交或回滚事务,只需要在业务类上增加transaction注解,通过AOP对方法进行增强实现事务的操作
        2.事务的传播属性： 多个事务同时存在的时候,Spring如何处理这些事务的行为。 属性定义在 TransactionDefinition中
            1.PROPAGATION_REQUIRED： 支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择，也是 Spring 默认的事务的传播。
            2.PROPAGATION_REQUIRES_NEW：新建事务,如果存在事务进行挂起,创建新事务。外层事务失败回滚不影响内层事务结果！内层事务抛异常外层可以捕获决定是否回滚事务
            3.PROPAGATION_SUPPORTS:支持当前事务，如果当前没有事务，就以非事务方式执行。
            4.PROPAGATION_MANDATORY: 支持当前事务，如果当前没有事务，就抛出异常。   基本不用
            5.PROPAGATION_NOT_SUPPORTED:以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。   基本不用
            6.PROPAGATION_NEVER:以非事务方式执行，如果当前存在事务，则抛出异常。    基本不用
            7.PROPAGATION_NESTED:如果一个活动的事务存在，则运行在一个嵌套的事务中。
            如果没有活动事务,则按照1执行,可以保存多个回滚点,内部事务回滚不会对外部事物造成影响！只对DataSourceTransactionManager事务管理器起效。
        3.事务的隔离级别
            1.数据库隔离级别
                1.Read-Uncommitted(读未提交):会产生脏读，不可重复读和幻像读。
                2.Read-Committed(读已提交)：避免脏读，允许不可重复读和幻读
                3.Repeatable-Read(可重复读)：同一个事务不管怎么读数据都保持一致。避免脏读，不可重复读，允许幻读
                4.Serializable(序列化)： 串行化读，事务只能一个一个执行，避免了脏读、不可重复读、幻读。执行效率慢，使用时慎重
            2.Spring中隔离级别
                1.ISOLATION_DEFAULT： 默认的隔离级别，使用数据库默认的事务隔离级别。
                2.ISOLATION_READ_UNCOMMITTED： 会产生脏读，不可重复读和幻像读。
                3.ISOLATION_READ_COMMITTED： 避免脏读，允许不可重复读和幻读
                4.ISOLATION_REPEATABLE_READ：避免脏读，不可重复读，允许幻读
                5.ISOLATION_SERIALIZABLE：这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。
            3.导致的问题
                1.脏读：一事务对数据进行了增删改，但未提交，另一事务可以读取到未提交的数据。如果第一个事务这时候回滚了，那么第二个事务就读到了脏数据。
                2.幻读：A在同一事务中读取两次结果不同,因为其他事务进行了插入操作
                3.不可重复读：A在同一事务中读取的两次结果不同,因为其他事务对某一条数据进行了修改或删除
                幻读和不可重读区别？
                    1.两者都是读了两次数据不一样,但是幻读针对的是插入操作,不可重读针对的是修改和删除   2.解决方案也不同,幻读采用间隙锁解决,不可重读采用行锁和和重复读隔离解决可以解决
            4.总结：
                1.隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。
                2.大多数的数据库默认隔离级别为 Read Commited，比如 SqlServer、Oracle
                3.少数数据库默认隔离级别为：Repeatable Read 比如： MySQL InnoDB
    4.方便集成测试
    5.降低API使用难度,对很多API进行封装提供Template调用
单例多例模式下线程安全问题：
   单例：方法局部变量、ThreadLocal是线程安全的,但是全局变量、静态变量存在线程不安全情况
   多例：每次创建一个新对象,不存在多线程共享一个Bean。所以ThreadLocal、局部变量、全局变量都是线程安全的、静态变量存在线程不安全情况
   为什么Spring中controller、service、dao却线程安全？
       答：因为通常情况下我们都是调用他们内部的方法,对于JVM虚拟机栈来说是线程私有的,不涉及线程安全问题。
代理模式：
   作用： 1.可以对方法进行增强,例如AOP实现增强方法   2.控制是否可进行目标方法的调用
   静态代理： 需求变了改代码实现功能    优点：容易理解,使用方便 2.如果改动较大,大部分类都要修改
   动态代理： 增强方法写在代理类中,只需要将业务代码生成一个代理对象即可   优点：耦合度低,灵活度高便于维护
       JDK Proxy: 实现 InvocationHandler接口 重写invoke方法进行增强。 基础是反射机制,因为执行方法调用method.invoke。创建实例调用proxy.newProxyInstance
       CGLib Proxy：实现 MethodInterceptor接口 重写intercept方法进行拦截增强。 原理是创建目标类子类,setSuperClass实现,覆盖其中方法进行增加。所以final方法不可用
       差异性：
           1.JDK代理是JAVA原生提供的,JDK8性能提高很多而且写起来方便,但是只能对接口进行增强   CGLib都可以进行增强,Spring提供的还需要引入ASM.jar,基于ASM(字节码操控框架)实现
           2.JDK代理直接编译生成字节码加载到JVM而CGLIB使用ASM效率较低,但是执行方法JDK使用反射而CGLIB使用FastClass为代理类和被代理类各一个类,通过index确定调用方法  整体：CGLIB速度快
           3.JDK代理对接口处理,所以不支持私有、保护。接口支持static但是没有实现方法不能代理    CGLIB创建子类方式：所以私有、保护、final、static等方法也不可代理
本来可以new对象,为什么要使用Spring IOC呢？
   1.主要好处就是bean的集中管理,降低耦合度  其次Spring提供了一整套Bean的生命周期管理,对于方法增强也有AOP处理
Spring Bean： 生命周期
    1.Spring启动时会扫描注解/XML/JavaConfig把需要管理的bean封装成BeanDefinition对象,然后统一放到beanDefinitionMap中,key就是beanName值就是BeanDefinition
    2.BeanFactoryPostProcessor 工厂后置处理器可以对Bean元数据进行修改,XML占位符就是他的子类注入进去的,一般用的比较少。 敏感数据比如密码之类的可以在这一层进行解密使用  Configuration注解类的加载成beanDefinitionMap
    3.InstantiationAwareBeanPostProcessor 感知Bean实例化处理器 父类是BeanPostProcessor。 通过AbstractAutowireCapableBeanFactory#createBean触发执行
        触发机制：Bean实例化之前会检查是否存在该接口,并触发下述1接口,1接口任何一个返回非null都会导致当前Bean生命周期缩短
        1.postProcessBeforeInstantiation: 在Bean实例化方法之前执行.  如果返回null就会执行doCreateBean进行实例化(内部有一个方法判断如果不存在构造或者多个构造的匹配方案)
            1.返回值决定后续实例化是否执行，如果返回空继续执行后续实例化等方法,如果返回AOP代理对象,生命周期会缩短,只执行postProcessAfterInitialization完成Bean加载,也不继续执行销毁方法
            2.作用就是替换普通实例化Bean,主要应用与框架层面,使用代理类替换普通类。 如果是我们日常业务中想要替换Bean,Spring提供了一个适配器类InstantiationAwareBeanPostProcessorAdapter
        2.postProcessAfterInstantiation：在bean实例化之后,初始化之前执行. 当前该Bean可能部分属性还没有设置值
            1.当前Bean结果返回true或false会直接影响当前Bean后续3是否执行,各Bean之间互不影响
        3.postProcessProperties：上述第二步结果为true,并且有一个check方法为true 的时候才会执行。是两个条件,可以给Bean属性赋值,也可以对xml的注入参数做修改
        4.postProcessPropertyValues: 已经被标注@Deprecated，Spring5.1被postProcessProperties取代。
    4.上述3如果没有缩短生命周期,接下来就执行Set依赖注入
    5.依赖注入之后,初始化之前可以在目标Bean上实现一些感知方法   具体回调方式如下两种
        1.invokeAwareMethods中通过判断类型直接进行回调的方法 例如:BeanNameAware、BeanFactoryAware、BeanClassLoaderAware
        2.通过BeanPostProcessor#postProcessBeforeInitialization方法实现的 例如：ApplicationContextAware
        问题：为什么之前在方法内,后面采用BeanPostProcessor方式实现回调？
             这个我也不太清楚,可能是Spring升级 采用修改关闭,扩展开放原则所以采用扩展方式添加！！！   加载顺序：第一种先执行回调.
    6.BeanPostProcessor：初始化阶段,实际初始化阶段和5(感知回调)都在初始化Bean中完成,执行顺序  invokeAwareMethods->下1->上2->下2
        1.postProcessBeforeInitialization：调用初始化方法之前执行,Spring一些感知方法的回调就是通过这个执行的！
        2.postProcessAfterInitialization:调用初始化方法之后执行,
    7.生命周期接口
        1.InitializingBean:自定义初始化执行的时候都会进行感知方法回调,所以可以对前面获取的对象放心使用。 还可以通过注解,XML配置实现完成配置！执行顺序不重要,都是初始化一般不会写多个！！
        2.DisposableBean:自定义销毁方法执行！容器关闭,调用close就可以触发
1.理解JAVA对象和Spring对象的区别
    1.java对象创建对象是使用堆中的类对象(只描述了类基本信息)作为模板创建
    2.Spring创建的BeanDefinition(包含了作用域,构造传入值和set传入值,初始化方法名、销毁方法名,如果是工厂类型实例还会有工厂名和工厂方法名)
BeanPostProcessor 注册时机与执行顺序?那么Spring是如何保证BeanPostProcessor在我们的业务Bean之前初始化完成呢？
    1.源码中对他提供的和我们自己写的Bean做了划分,加载的时候也是先注册 BeanPostProcessor(Bean后置处理器) 然后才会对单例非懒加载的Bean进行注册
    2.每种类型中执行顺序又可以通过实现类进行加载排序   1.PriorityOrdered   2.Ordered   3.什么都不加    执行顺序按照123执行。 内部优先级越小越早执行
三级缓存： doCreateBean中采用三级缓存解决循环依赖问题
    一级缓存(singletonObjects)：存放的是所有创建好的单例Bean
    二级缓存(earlySingletonObjects)：完成实例化，但是还未进行属性注入及初始化的对象 由三级缓存放入
    三级缓存(singletonFactories)：提前暴露的一个单例工厂.拿到的是一个工厂对象,通过它实例对象每次可能都不一样！！！Bean就不是单例了
        解决:二级缓存中存储的就是从这个工厂中获取到的对象实例。 当使用三级缓存getObject获取就会移除三级缓存放入二级缓存
    流程:
        当A完成构造方法调用,将Bean放入三级缓存,进行属性注入时候发现B没有被加载,所以进行B的创建,B创建时候发现要注入A,尝试一级缓存获取\二级获取,最后从三级缓存拿到一个没有初始化完全的Bean
        然后B完成依赖注入和初始化操作后将B放入一级缓存,继续返回A中注入B完成依赖注入和初始化,最后将A放入一级缓存。 因为B拿到A是一个引用,所以最终B中的A也是一个初始化完全的Bean
    循环依赖不支持情况？   1.放入三级缓存的前提是执行了构造方法,所以构造器的循环问题不能解决   2.
Spring循环依赖如何解决？
    1.首先区分Spring中出现循环依赖是什么情况
        1.AOP代理对象产生循环依赖
            1.使用@Lazy注解，延迟加载    2.使用@DependsOn注解，指定加载先后关系     3.修改文件名称，改变循环依赖类的加载顺序
        2.DependsOn产生循环依赖
            只能取消注解让它不出现循环依赖
        3.多例循环依赖
            因为多例情况下不走缓存,所以只能变成单例解决
        4.单例构造器循环依赖
            1..使用@Lazy注解，延迟加载   2.先加载的构造器改为Set注入
BeanFactory和ApplicationContext有什么区别？
    1.ApplicationContext是BeanFactory的一个子接口,所以ApplicationContext可以理解为是BeanFactory基础上的一个增强
        1.ApplicationContext:采用一次性加载  优点：1.如果配置错误启动就会报错 2.运行过程中速度快,因为不涉及太多加载 缺点：一次性加载太多比较吃内存,首次加载很慢
            加载：ClassPathXmlApplicationContext
            增强1.MessageSource 国际化  2.ResourceLoader资源访问(绝对路径相对路径处理)  3.AOP增强
        2.BeanFactory：懒加载  优点：首次运行速度快 缺点:配置错误只有访问时候才能发现,而且过程中可能涉及加载影响速度
            加载：XmlBeanFactory
        3.FactoryBean:工厂Bean,使用工厂模式,提供工厂方法来实例化Bean！

-----------------------------------------------------------------------------------------------
Mybatis：持久层框架,可以将参数映射到配置的SQL进行执行,结果集映射成Java对象返回！
    优点：1.相比于JDBC减少冗余代码  2.SQL写到XML与程序分离,使用灵活耦合度低
         3.底层使用JDBC连接数据库,只有JDBC支持的数据库Mybatis都支持,但是XML中的语法要符合对应数据库规范
         4.支持对象与数据库字段关系映射(ORM)
    缺点：1.关联表、字段多时比较复杂   2.SQL依赖于数据库,切换数据库移植性差
MyBatis和Hibernate的区别
    1.Mybatis需要手动编写SQL并且需要手动配置数据库字段和对象映射关系。Hibernate不需要编写SQL只需要操作对象！耦合度低,因为不需要编写SQL所以移植性高
    2.Mybatis支持动态SQL,并且能进行SQL优化。  Hibernate全自动映射 性能慢,不能SQL优化！
    场景：Mybatis适合大型互联网相互,性能高   Hibernate适合对性能要求不太高的后台管理系统之类的
为什么要使用三级缓存？ 减少读取数据库操作,提高效率.一般项目中都会使用redis缓存,一级二级基本不怎么使用 所以没了解二级缓存回收策略
    一级缓存(默认开启)：也叫会话缓存  HashMap无容量限制
        1.缓存的key是一个CacheKey对象,由分页偏移量(默认0),条数(默认Inter.Max),SQL语句,传入参数等传入到一个UpdateList<Object>中
        2.通过CacheKey查询缓存,获取不到进行数据库查询。 查询之前先给存一次,value为空enum  查询之后将key进行删除   将结果重新put进去
    一级缓存清空： BaseExecutor#query方法可知！
        1.配置文件配置flushCache=true属性,会进行缓存清空。但是也会把二级缓存清空
        2.MyBatis全局配置属性localCacheScope配置为Statement时，那么完成一次查询就会清除缓存。   还可以配置成Session,不会清理
        3.执行增删改操作会清空一级缓存
    一级缓存缺点： 不同会话可能存在脏数据！ 所以建议设置本地缓存作用域为 Statement不使用Session 或者开启二级缓存

    二级缓存：开启二级缓存 1.CacheEnable=true 2.Mapper中加入<cache/>  用来解决一级缓存不能跨会话问题  HashMap无容量限制
    二级缓存注意点：
        1.二级缓存开启后对于实体类需要实现Serializable接口,因为二级缓存不一定只存在内存中,也可能放硬盘里！所以取得时候需要反序列化
        2.需要事务commit之后才会生效 (两次查询中间如果有更新 但是未提交会走缓存。 提交后才会清空缓存)
            如果未提交会存在临时的Map中,只有当commit的时候才会转移到真正二级缓存的Map！防止脏读
    二级缓存流程：
        1.通过缓存执行器先创建一级缓存Key,通过Key查询二级缓存,没数据进入具体执行器走一级缓存流程,最后将结果放入临时二级缓存！ 当方法提交后移入真正的二级缓存
    二级缓存场景
        1.因为增删改都会清空二级缓存,所以只适合读多写少的清空开启   2.二级缓存针对nameSpace,建议单表操作的Mapper使用！

    三级缓存(自定义缓存)：Mybatis官方提供redis  解决一级缓存和二级缓存脏读的问题、并且可以多应用之间使用
        1.自定义一个缓存类实现Cache接口,重写对于存取方法即可！
    三级缓存需要Mybatis操作存取,不是Spring容器,不能直接注入RedisTemplate,如何拿到的RedisTemplate对象呢？
        RedisTemplate可以通过applicationAware注入application进行getBean
Mybatis的三种分页
    1.Limit关键字实现  优点：灵活性高  缺点：实现复杂,数据量大效率低！
    2.RowBounds类实现逻辑分页(一次性获取所有结果集,业务层进行分页。 不推荐没人使用)   优点:写法比limit简单  缺点：一次性查询所有,占内存
    3.PageHelper第三方插件实现分页
        原理：内部实现一个拦截器,业务代码中设置PageHelper的页数和条数实际添加到了ThreadLocal中,拦截器拦截到SQL判断ThreadLocal是否有分页信息进行SQL的limit的拼接查询。最后清楚ThreadLocal
        注意事项：因为PageHelper使用的ThreadLocal和线程绑定,所以需要设置完分页参数就进行数据库查询！ 内部会清理本地变量。 如果中间增加很多业务代码可能导致不安全情况！
            不安全情况说明：如果业务代码后没有进行数据库查询继续执行,因为本地变量没有清空可能会导致当前线程的其他查询方法进行了分页处理！导致业务异常。   可以手动finally增加清理分页参数
Mybatis延迟加载原理(懒加载)
    好处：先从单表查询,需要时再从关联表查询,提高数据库性能！因为单表比关联查询速度快
    缺点：需要用到数据才进行查询,数据量大的情况下接口响应时间长
    操作过程：再ResultMap中可以配置Lazy属性和对应查询SQL！ 当业务层访问懒加载数据时动态代理被触发通过SqlSession执行嵌套SQL。但是当数据返回到控制层如果再去访问延迟数据就会报错！因为sqlSession
    sqlSession生命周期： 一次sqlSession相当于一个数据库连接,就当事务注解存在的时候,当业务层代码执行完毕就应该关闭连接！ 所以当controller访问拦截在就会报错,无法使用代理执行嵌套SQL
Spring装载Mybatis流程
    1.Spring整合Mybatis的时候首先要配置一个SqlSessionFactoryBean,这个工厂Bean中可以注入数据源、mybatis参数配置文件、XML文件位置
        1.实现InitializingBean:启动会执行初始化方法,内部执行了构建工厂Bean方法
        2.FactoryBean：通过getObject获取Bean。内部对SqlSessionFactory获取如果为空执行构建工厂Bean方法
        3.ApplicationListener：容器刷新的时候更新SqlSessionFactory！！Spring的refresh
    2.buildSqlSessionFactory(构建工厂Bean方法)
        1.构建XMLConfigBuilder对象,加载configLocation配置文件(插件、setting配置、环境配置、Mappers)封装进Configuration中
            1.对配置文件参数的获取封装到Configuration中,用到可以跟代码看默认值或可选项有哪些进行查阅资料！ 核心就是下面加载Mappers
            2.mappers可以通过两种方式配置。 加载Mappers核心就是 1.二级缓存标签的配置  2.封装MappedStatement对象
                1.package：通过包路径获取所有xml的CRUD标签进行MappedStatement封装
                2.mapper：属性可以选择 1.resource   2.class   3.url  {因为这种单一注入、一般不常使用}
                3.通过XMLStatementBuilder封装MappedStatement对象 (MappedStatementID是namespace+id)
                    1.参数类型(ParameterType)  2.SqlSource生成  3.ResultMap
                MappedStatement作用
                    1.Executor执行器执行SQL前将输入的java对象映射到SQL中.相当于JDBC中preparedStatement对参数的设置！
                    2.SQL执行结果映射回java对象,相当于JDBC中对结果集循环处理封装对象的过程！
    3.MappedStatement属性中SqlSource接口的封装 调用createSqlSource进行创建
        1.使用XmlScriptBuilder对SQL进行解析,判断是否属于动态SQL  条件： 1.SQL中包含动态标签   2.SQL中包含${}符
        2.通过判断是否为动态SQL为SqlSource创建不同的实现类  1.动态SQL实现类DynamicSqlSource    2.静态SQL实现类RawSqlSource 内部最终使用了StaticSqlSource
Mybatis执行流程源码
    1.Spring加载Mybatis之后会创建一个DefaultSqlSessionFactory。通过DefaultSqlSessionFactory创建一个sqlSession
        1.获取环境信息,根据配置环境加载不同数据源
        2.获取事务工厂创建一个事务：包含事务隔离级别配置(Enum类)、事务是否开启
        3.创建一个执行器(默认是SimpleExecutor): 根据配置获取也可以通过 openSession传入参数设置执行器！
        4.创建DefaultSqlSession
    2.通过DefaultSqlSession获取Mapper对象！ 就是从注册的Map中取
    3.执行Mapper中对应方法！
        1.通过执行器执行对应方法,会将加载Mybatis加载好的MappedStatement一起给执行器！
        2.通过SqlSource接口执行getBoundSql方法获取对应SQL。 如果是静态SQL可以从参数直接拿到,如果是动态SQL就会通过传入参数进行判断封装SQL。
        3.判断一级缓存和二级缓存进行处理,执行SQL获取结果集！最后根据MappedStatement将结果集封装回java对象
Mybatis都有哪些Executor执行器？  通过setting配置！作用范围都是一个sqlSession!  如果开启二级缓存会将执行器包装成缓存执行器！就是
    1.SimpleExecutor(默认)：执行数据库操作前，每次都会新建一个statement，然后执行数据库操作。
    2.ReuseExecutor：维护一个Map缓存,相同SQL会复用Statement
    3.BatchExecutor：可以对增删改进行批处理,但是配置上不仅仅只是设置执行器,还有其他配置操作！  底层手动开启事务 然后SQL到批处理中  最后批量执行所有SQL  提交事务
    4.缓存执行器：就是再原执行器的基础上增加了缓存处理
DefaultSqlSession线程不安全问题？
    1.因为DefaultSqlSession做不到每次请求创建一个新实例,如果多个请求共用一个,在一级缓存处可能导致并发冲突。
        因为操作不是同步的,一级缓存先会存一个空的Enum.然后执行查询。第二个请求发现缓存不为空就会获取进行强制类型转换 从而引发报错！
    解决：Spring-Mybatis中提供SqlSessionTemplate在每次请求都会使用代理创建一个实例
Mybatis动态SQL
    1.动态SQL类会将SQL解析成SqlNode然后对SQL进行拼接
    2.#{}无论静态SQL还是动态SQL都会变成？通过preparedStatement执行！  ${}则和其他动态标签一样解析成SQLNode进行SQL拼接
#{}和${}区别
    1.${}和动态标签一样需要对SQL进行替换拼接 没有预编译SQL执行过程可能产生SQL注入问题
    2.#{}替换成？号使用PreparedStatement执行,因为有预编译,避免SQL注入
    使用场景：ORDER BY ${id} 如果使用#{id}会解析成"id"写法有误   表名等！
    预编译的作用：1.预编译可以将多次操作合成一次,并且可以直接执行   2.预编译后产生的PreparedStatement会有缓存下次可以直接使用
Mybatis怎么避免重复加载
    加载之前会从Map查是否存在,不存在进行加载,第一步存到Map中,后续执行加载！ 因为启动是单线程不是并行,所以不会出现重复加载问题
Mybatis接口绑定:  代码只需要调用接口方法自动完成实现的映射
    1.注解绑定:接口上增加CRUD注解编写SQL。 SQL简单时可以使用,但是一般推荐使用XML方式
    2.XML绑定:通过XML配置SQL实现！ 耦合度低,复杂SQL必须使用XML方式。 没有强迫性,自行选择
---------------------------------------------------------------------------------------------


























