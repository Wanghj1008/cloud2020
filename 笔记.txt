
 Spring：轻量级框架,以IOC和AOP为核心
 1.IOC低耦合高内聚2.AOP面向切面变成3.事务的控制4.方便集成测试5.方便集成其他优秀框架6.降低API使用难度,Spring对很多API进行封装提供Template
IOC控制反转：把对象的创建权交给Spring
XML方式：
Bean的配置：id自定义 class类的全路径名  init-method 初始化方法  destroy-method 销毁方法
ApplicationContext.getBean两种方式 一种通过id   一种通过字节码文件。。如果bean注入两次通过字节码会报错。无法判断要哪个
  实例化三种： 无参构造                 <bean id="userDao" calss="com.whj.dao.UserDao"/>
                需要现有一个StaticFactory类 然后里面有一个静态的getUserDao方法
              工厂静态方法             <bean id="userDao" class="com.whj.dao.StaticFactory" factory-method="getUserDao"/>
                需要现有一个StaticFactory类 然后里面有一个getUserDao方法   这样就不能直接类名.方法调用 需要先实例创建StaticFactory
              工厂实例方法             <bean id="factory" calss="com.whj.dao.StaticFactory"/>
                                      <bean id="userDao" factory-bean="factory" factory-method="getUserDao"/>
scope作用范围
singleton：单例    如果是单例则在加载xml配置文件时,bean就被创建  只要Spring容器在对象就一直活着，容器销毁对象才销毁
prototype：多例    如果是多例则在加载xml配置文件时不创建bean。getBean的时候才创建,get一次创建一个 只要对象在使用就活着,长时间不使用会被GC回收
request：web项目中，Spring创建一个Bean的对象，将对象存放到request域中
session：web项目中，Spring创建一个Bean的对象，将对象存放到session域中
global session：web项目中，应用在Portlet环境,如果没有这个环境,那么相当于session
依赖注入：
    set方法注入
    有参构造注入
    P指针注入：一般还是用set因为这个多了很长不好看
引入其他文件：<import resource="aaalication-dao.xml"/>
注解方式：
@Autowired:直接去寻找类型的bean但是如果相同类型bean有多个会出错。不知道要哪个
@qualifier("id"):根据id去容器寻找一样的bean 但是需要配合Autowired一起使用
@Resource:相当于Autowired+qualifier
@ComponentScan:指定扫描包
@import:配置文件加载其他分支配置文件
@propertyResource：用于加载.properties的文件

整合junit：
@RunWith("SpringJunit4ClassRunner.class")
@ContextConfiguration("classpath:application.xml") 或者不用xml用核心配置类@ContextConfiguration("class={Config.class}")

SpringMvc:
缺点：servlet中每次都需要创建Spring容器加载application
改进：将创建加载的过程交给监听器。容器启动就加载配置文件。ContextLoaderListener存放WebApplicationContextUtil取
前端控制器：统一处理请求。在配置时候需要把SpringMvc配置文件读取进去
配置视图解析器：默认转发可以换成重定向。加前缀后缀
返回字符串：@ResponseBody 但是如果是实体类需要加<mvc:annotation-driven>      mvc注解驱动
请求：获取集合参数 1.使用VO包装接收 2.如果是ajax请求 可以直接用@RequestBody List<User>接收
开放静态资源:<mvc:resources mappingL="/js/**" location="/js/"/>   或者：<mvc: default-servlet-handler/>
@RequestParam(value="name",defaultValue="whj")



 Mybatis：是持久层框架,简化开发使开发者不用关注创建链接等操作,只需要关注SQL语句。
       使用ORM(对象映射关系)思想
           ORM：就是把数据库和实体类及实体类的属性对应起来，让我们可以操作实体类就实现操作数据库
注意事项：XML的mapper标签namespace值为接口全限定类名
         接口名为XML的id值
         接口的包路径和XML包路径保持一致




--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
MQ(MessageQuene) 消息队列
       通过生产者和消费者模型,生产者不断向消息队列中发消息,消费者不断从消息队列中拿消息,因为消息的生产和消费都是异步进行的,而且
       只需要关心消息的发送和接收,实现系统解耦.  别名消息中间件,利用高效的消息传递机制进行平台无关的数据交流。

1.ActiveMQ
   Apache出品,是比较老牌的消息中间件,但是性能不太好。
2.kafka
   Apache出品,追求高吞吐量,但是对事务,消息重复，丢失，错误没有严格要求,所以在大数据领域追求速度用的比较广
3.RocketMQ
   阿里开源消息中间件.借鉴kafka高吞吐,高可用。他对消息的可靠传输及事务做了优化,但是对事务的优化版本需要收费
4.RabbtiMQ
   使用erlang语言开发的消息队列,基于AMQP协议实现。AMQP主要特征就是面向对象、队列、路由、可靠性、安全。AMQP协议更多在企业系统内对数据一致性
   可靠性和稳定性要求很高的场景,即使数据丢失了也可以恢复,对性能和高吞吐量要求还在其次。和Spring框架无缝整合


------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------
JVM(c写的)： 和操作系统
   硬件系统---》操作系统(window，linux,max)---->JRE(JVM)
   java文件---javac---》class文件---》类加载器(CLass Loader)---》java虚拟机运行时数据区（
                      1.方法区：method Area (JVM调优)
                      2.虚拟机栈：VM stack
                      3.本地方法栈：Native Method Area
                      4.堆：heap  (JVM调优)
                      5.程序计数器：compute
                      ）---》
      执行引擎:
          一般的插件都是在执行引擎上操作的
           本地库接口     本地方法库
   类加载器：            new Student()  引用放在虚拟机栈中 具体的人实例在堆中
      加载Class文件
--------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------
MYSQL 高级
  Mysql架构有点：插件式的存储引擎,将查询处理和其他系统任务以及实现数据的读写分离,可以根据业务需求选择存储引擎
  Mysql架构：
        连接层：连接处理,授权认证,引入了线程池的概念
             1.connector：连接层，JDBC，pathon，PHP
             2.connectionPool：连接池。
        业务逻辑处理层：预处理,解析器,优化器,缓存
             1.Management sevice utils：数据库管理工具：备份,容灾恢复，集群
             2.sql Interface:sql实例。存储过程,视图，触发器，DML，DDL
             3.parser解析转换：查询的事务，对象的权限。
             4.optimizer优化：会对写的sql进行优化重排
             5.cache&缓存和缓冲：
        数据存储引擎层：   负责数据的读写,服务器通过API接口进行通讯 。不同的引擎具有不同的功能
             1.mysql支持多种存储引擎  常用的就是Myisam和innodb
        文件存储层：将数据存储在文件系统上
             1.file system 文件系统和 文件日志 logs
  存储引擎：    Mysql命令查询引擎  ： show variables like ‘%storage_engine%’
        默认Innodb：支持事务,有外键,行锁（适合高并发）    缓存索引和数据,对内存要求较高  表空间大  关注点：事务          都是默认安装的
        MyIASM：不支持事务,不支持外键,表锁               只缓存索引                     表空间小  关注点：性能高,因为对内存要求低
索引优化：
  什么是索引？索引是一种排好序的数据结构,帮助MYSQL高效获取数据
              索引本身也很大,不可能全部存储在内存中,因此索引往往以索引文件的形式存储在磁盘上
     优势：1.提高数据检索效率,降低数据库IO成本
           2.通过索引对数据进行排序,降低排序成本,降低CPU消耗
     略势：1.索引实际也是一张表,保存了主键和索引字段,并指向实体表数据.所以索引也要占用空间
           2.虽然提高了查询的速度,但是降低了更新速度》因为更新表,不仅保存数据,还要保存索引,还可能调整索引的键值变化后的信息
           3.索引只是提高效率的一个因素.如果有大量数据表.就需要花时间建立最优的索引.或者优化查询
  索引分类：
     1.单值索引：一个索引只包含单个列,一张表可以建立多个单值索引。但是一般不会超过5个
     2.唯一索引：索引列的值必须唯一,但允许有空值 unique
     3.复合索引：一个索引包含多个列
            1.创建索引：create 【unique】 index  索引名  on   表(字段名)
            2.删除索引：drop  index  索引名  on  表名
            3.查看所有：show  index  from  表名
  索引结构：
     1.BTree索引
            1.3层的B+数可以表示上百万条数据。所以最高需要三次IO。提高查询性能
     2.Hash索引
     3.full-text全文索引
     4.R-Tree索引
  那些情况下建立索引：
     1.主键自动建立唯一索引：
     2.频繁作为查询的字段应该创建索引
     3.查询中与其他表关联的字段,外键建立索引
     4.查询排序中的字段,排序字段若通过索引去访问将提高速度
     5.查询中统计或者分组字段
  哪些情况下不用索引：
     1.频繁更新的字段不适合创建索引。因为更新字段同时同时需要更新索引。
     2.where条件里用不到的字段不需要创建索引
     3.表记录太少    超过300w  MYSQL性能开始下降 可以考虑索引
     4.数据重复且分布平均的表字段  比如说性别  高度重读 创建索引没有什么效果
  如何选择：
     1.单值索引和组合索引选择？高并发下倾向创建组合索引
     2


优化分析：
  1.sql慢问题：
     1.sql写的不好.连接多而且没有建索引或者没用索引
     2.索引失效。 单值索引 create index inx_user_name on user(name)  复合索引 create index inx_user_name on user(name,Email)
  2.执行或等待时间长问题：
     1.关联查询太多join(设计缺陷或不得已的需求)
     2.服务器调优及参数设置(缓冲、线程数)不恰当
常见的Join查询
  sql执行顺序：
     1.人写的 select distinct * from  表名  join 表  where 条件  group 分组 having分组后筛选  order 排序  limit 分页
     2.机读 from 连接条件 连接表 where条件 分组 分组后筛选 查询想要的字段  去重  排序  分页
  七种连接：1.左全部            select  *  from a  left join b on a.id=b.id
            2.右全部 左连接     select  *  from a  right join b on a.id=b.id
            3.交叉部分：        select  *  from a  inner join b on a.id=b.id
            4.左表去右表交叉    select  *  from a  left join b on a.id=b.id  where b.id is  null
            5.右表去左表交叉    select  *  from a  right join b on a.id=b.id  where a.id is  null
            6.全连接       select  *  from a  full join b on a.id=b.id    但是可以使用联合查询 union 将1，2 连接  自动去重
            7.全连接去重复   select  *  from a  full join b on a.id=b.id where a.id is null or b.id is null 或者 union 将4 5连接
性能分析：
         1.优化器：sql进来先进行语法分析,然后语义检查不合法报错,sql优化,可能会调整SQL顺序
         2.MYSQL的常见瓶颈：
            1.CPU：数据装入内存和从磁盘上读取数据的时候会发送cpu饱和   CPU负担重
            2.IO：磁盘I/O瓶颈发生在装入数据大于内存容量的时候          IO负担重
            3.服务器硬件性能瓶颈                                      服务器硬件配置瓶颈
            查看性能状态方式：top 、free 、 ioStat 和vmStat
         3.Explain： explain + SQL语句
            1.使用explain关键字可以模拟优化器执行SQL语句,从而知道MYSQL是如何处理你的SQL语句。分析语句是否存在瓶颈
            2.使用explain 的查询结果字段分析
                1.id:select 查询的序列号,包含一组数字,表示查询中执行select子句或者操作表的顺序
                    1.id相同：执行顺序由上至下
                    2.id不同：如果是子查询,id的序号会递增,id值越大优先级越高,越先被执行
                    3.id相同不同都有：id大的先执行。id一样的顺序执行
                2.select_type  查询的类型,主要用来区别  普通查询、联合查询、子查询等复杂查询
                    1.SIMPLE：简单的查询,不包含子查询和union联合查询
                    2.Primary：查询中如果包含子查询，最外层的查询被标记为 Primary
                    3.subQuery：在select或者where列表中 被包含的子查询
                    4.derived：from中包含的子查询被标记为衍生表,会把查询结果放在一个临时表
                    5.union：第二个select出现在union之后.被标记为联合。若union包含在from子句的子查询中,外层的select将被标记为4.衍生表
                    6.union result：使用union产生的结果集
                3.table：显示这一行数据是来自那个表
                4.type：访问类型排列   最好到最差   system》const》eq_ref》ref》range》index》all  查询最少到range级别  最好到ref
                    1.system：表只有一行记录(等于系统表)。是const特例  平时不会出现  可以忽略
                    2.const：通过索引一次就找到了,const用于比较主键索引和唯一索引。
                             因为只匹配一行,所以很快将主键至于where条件中,Mysql能将该查询转换为一个常量
                    3.eq_ref：唯一性索引扫描,对于每个索引键,表中只有一条记录匹配。常见于主键或者唯一索引扫描
                    4.ref：非唯一的索引扫描,返回匹配单独值的所有行
                    5.range：只检索指定范围的行,使用一个索引来选择行,key列显示使用了那个索引    一般就是>、<  、between and 、in
                    6.index：全索引扫描。只遍历索引树
                    7.all：遍历全表查询数据
                5.possible_keys：显示可能应用在这张表中的索引,一个或者多个，但是不一定被实际使用到
                6.key：实际使用的索引  如果为null则没有使用
                    1.覆盖索引：我使用1,2两个字段创建索引,而查的也是12字段。不需要通过索引去查找其他信息就是覆盖索引
                7.key_len：表示索引中使用的字节数,可以通过该列计算查询中使用的索引长度。不损失精度的情况下 越短越好
                           显示的值为最大可能长度,不是精确长度。是根据字段定义长度计算来的  不是检索出来的。同样的查询结果下 这个越小越好
                8.ref：就是你的条件后面的值。没有=null  有的话分常量const  和  对于值的库 表 字段名
                9.rows：读取行数
                10.extra额外：包含不适合再其他列显示 但是十分重要的额外信息
                    1.using fileSort：无法利用索引完成排序操作,而是使用了一个外部排序。叫文件排序  常见：group by与组合索引个数 顺序不吻合
                    2.using temporary：mysql对结果排序使用了临时表。常见于 order by、group by。
                    3.using index：如果同时出现了using where 说明索引被用来执行查找。没有出现using where 说明索引用来读取数据 而不是查找数据
                    4.using where 表示使用了where条件
                    5.user joinbuffer：使用了连接缓存
                    6.impossible where：where条件不可能成立   name=王昊杰 and  name=王洁
         4.Explain的作用
            1.通过查询的结果id可以判断表的加载顺序
            2.通过select_type可以判断查询语句有哪些操作类型   union、子查询 等
            3.判断哪些索引可以使用
            4.判断哪些索引被实际使用了
            5.通过ref可以判断表之间的引用
            6.通过rows每张表有多少行被查询出来
索引优化：
    1.索引分析：
        1.单表：
        2.两表：左连接索引建右表,右连接索引建左表
        3.三表：根据2的结论一步一步加两个索引。1lef join2  left join3   现在2被查询条件加索引,然后在3被查询条件加索引
    2.避免索引失效：
        1.相同结果下 key_len越小越好
        2.最佳左前缀法则：如果索引了多列,要遵守最左法则,查询从索引最左开始,并且不能跳过列。如果跳过按照最短匹配计算
        3.不要在索引列上做任何操作。(计算,函数,自动或者手动类型转换),会导致索引失效从而扫描全表
        4.不能对索引值查询范围。范围后面的会失效。但是范围如果符合顺序会使用
        5.尽量使用覆盖索引
        6.！=和 is null 和is not null也无法使用索引。
        7.使用like模糊查询 百分号只能加右边。左边会失效。解决方案就是用覆盖索引查询。 如果第二个使用
        8.字符串不加单引号会导致索引失效。其实相当于隐式类型转换
        9.少用or  用它会索引失效
    3.常见问题：
        1.分组之前会排序,如果顺序错乱会产生using filesort和临时表
        2.order by按顺序可以使用索引。不按顺序会出现file sort
    4.一般建议：
        1.对于单值索引,尽量选择针对当前索引过滤性更好的索引
        2.在选择组合索引的时候,尽量按顺序写索引字段进行查找
        3.


------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------
Redis
90年代：使用单机数据库 +静态html页面。  访问量不大  单个数据库足够使用
        1.数据量总大小 一个机器放不下 ----》300w必须创建索引
        2.数据的索引（B+ Tree）一个机器的内存放不下时
        3.访问量多(读写混合)--》一个服务器受不了
        16G内 存能放下大概 2000W 行数据的索引，  简单的读和写混合访问量3000/s左右没有问题，
Memcached（缓存）+MySQL + 垂直拆分
        1.网站80%都在查询。每次操作数据库十分麻烦,为减轻数据库压力。可以使用缓存
        2.但是数据量大了还是会出现最初内存不够  访问量大无法承受的问题
读写分离：主库承担写的压力，分库承担读的压力
        1.对于读多写的少  适用
        2.写入量大  会造成主库无法承受
水平拆分：数据量变成1/n,,可以提高并发量和稳定性
        1.分片式事务不好解决
        2.跨库join性能降低。而且维护难度提高。
云数据库：
缓存适用于数据变动不大。但是像用户日志。数据量大变动又快的东西 关系型数据库就不适用了


