并发工具类
CountDownLatch(减法计数器)
   1.调用countDown方法 减一,当为零的时候 await方法继续执行   (王者荣耀加载游戏界面 开启十个线程分别加载,一个线程完毕调用一次-1 全部加载好进入游戏)
CyclicBarrier（同步屏障）
   CyclicBarrier可以用于多线程计算数据,先每个线程计算学生平均成绩,最后计算班级平均成绩
区别：
   1.CountDownLatch只能使用一次,而 CyclicBarrier 执行完会进行重置,可以重复使用
   2.CyclicBarrier某个线程中断,那么所有await的线程都无法使用, 而CountDownLatch一个线程中断只是一个await线程不能使用
   3.CountDownLatch使用的 AQS,操作的是AQS的state  而CyclicBarrier使用的ReentrantLock
Semaphore(信号量)
   1.同时访问线程的数量,可以用作限流控制 控制可访问线程数量,其他线程等待  (停车场例子)   acquire(取得)  release(释放)
Exchanger(交换者)
   1.用于线程间进行通信、数据交换  当两个线程都调用(交换点)exchange方法 就会进行数据交换,为了避免一方中断可以设置超时时间  避免一直等待
---------------------------------------------------------------------------------------------------------------
并发容器和框架
Fork/Join：分支合并   分而治之和工作窃取算法。
    1.首先将一个大任务拆分成多个小任务多个线程去执行,最后合并小任务的结果
    2.工作窃取：拆分成多个线程如果某个线程执行完不会等待其他线程而是会窃取其他线程任务继续执行,提高效率(维护的双端队列)
---------------------------------------------------------------------------------------------------------------
线程池： （池化技术）
什么是线程池？
   简单理解其实它就是一个管理线程的池子。
   好处：
      1.管理线程,避免了创建和销毁线程的资源消耗:线程其实也是一个对象,创建过程需要类加载,销毁需要GC垃圾回收.都需要消耗系统资源
      2.提高响应速度:如果直接从池子里拿和创建一个线程 来比较的话速度肯定快
      3.线程复用：线程用完，再放回池子，可以达到重复利用的效果，节省资源。
能说说工作中线程池的应用吗？
   1.首先发送验证码类似接口,可以通过线程池去发送,用户无需等待
   2.我们和第三方安管一些接口,我们需要上报一些审计数据,下发策略等东西。 当数据发生变动就会使用线程池去开启线程上报数据
线程池：三大方法   七大参数
    1.Executors.newSingleThreadExecutor       //单个线程
    2.Executors.newFixedThreadPool(int值)     //创建一个固定大小的线程池
    3.Executors.newCachedThreadPool()         //可伸缩的，遇强则强
    4.Executors.newScheduledThreadPool()      //定时线程 延时3s处理
三种方法本质都是new ThreadPoolExecutor  这个方法的七个参数
    1.corePoolSize                                       核心线程池大小(最小)
    2.maximumPoolSize                                    最大线程池大小 (可伸缩的创建最大21亿  OOM内存溢出)
    3.keepAliveTime                                      超时释放时间(超时没人调用,)
    4.TimeUnit                                           时间单位 (上面超时时间的单位)
    5.BlockingQueue<Runnable>                            阻塞队列
    6.ThreadFactory                                      线程工厂，创建线程的,一般不用动
    7.RejectedExecutionHandler                           拒绝策略
    最大线程到底改如何定义？
      1.CPU密集型：几核CPU就是允许最大线程    Runtime.getRuntime().availableProcessors()获取
      2.IO密集型：判断程序中十分耗IO的线程, 只要大于这个数就行 一般两倍
四种拒绝策略
    1.new ThreadPoolExecutor.AbortPolicy()  //丢弃任务并抛出RejectedExecutionException异常。
    2.new ThreadPoolExecutor.CallerRunsPolicy() //由调用线程处理该任务 【谁调用，谁处理】
    3.new ThreadPoolExecutor.DiscardPolicy()   //也是丢弃任务，但是不抛出异常。
    //当任务被拒绝添加时，会抛弃任务队列中最旧的任务也就是最先加入队列的，再把这个新任务添加进去。
    //在rejectedExecution先从任务队列种弹出最先加入的任务，空出一个位置，然后再次执行execute方法把任务加入队列。
    4.new ThreadPoolExecutor.DiscardOldestPolicy()
---------------------------------------------------------------------------------------------------------------
什么是JMM？
     java内存模型,是一个不存在的东西,共享变量存储在主内存,每个线程又有线程内存。 线程操作共享变量必须要拿到线程内存进行使用,最后要刷新回主内存
线程：  工作内存        主内存    涉及到8种操作  4组
    1.lock     （锁定）：作用于主内存的变量，把一个变量标识为线程独占状态
    2.unlock （解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
    3.read    （读取）：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用
    4.load     （载入）：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中
    5.use      （使用）：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令
    6.assign  （赋值）：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中
    7.store    （存储）：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用
    8.write 　（写入）：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中
有序性可见性原子性
    有序性：程序按照指令一行一行执行                             synchronized和synchronized可以保证
    原子性：要么同时成功要么同时失败,要统一执行,不可分割,不可中断     通过锁保证原子性
    可见性：一个线程修改了共享变量的值,其他线程要立即知道            synchronized和synchronized可以保证
指令重排：
    1.执行程序的时候,为了提高性能,处理器和编译器可能会对程序的指令进行重新排序
    比如：指令重排导致DCL懒汉式出现问题
指令重排有限制吗？通过哪两个规则可以约束？
    1.happens-before：是JMM中保证多线程操作可见的一个机制
          定义1.如果一个操作 happens-before 另一个操作,那么这个操作的结果对另一个操作是可见的。
              2.如果操作顺序被指令重排,但是结果保持一致,那么它并不是非法的
          规则：1.锁定规则：一个线程的unlock操作要先于另一个线程的lock操作
               2.volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；
    2.as-if-serial：所有指令都可以被重排序,但是需要保证是在单线程下而且执行结果不变。 他其实不会对有依赖关系的指令进行重排
请你谈谈 volatile 的理解？ volatile的原理？
   volatile是轻量级的同步机制
   1.保证可见性: 他不操作线程内存,直接操作主内存进行读写,所以保证可见性
   2.不保证原子性
   3.保证有序性: 会在指令前后加读写内存屏障,从而限制一些情况的重排序。在它符合的规则内还是可以进行重排的
---------------------------------------------------------------------------------------------------------------
synchronized用过吗？怎么使用
   1.对实例方法加锁:锁的是对象实例
   2.对静态方法加锁:锁的是Class类模板
   3.对代码块加锁:
synchronized锁住的是什么呢？
   1.基于Monitor实现的。HotSpot中,Monitor是由ObjectMonitor实现的,也叫内部锁
   ObjectMonitor的工作原理
       1.两个队列:：_WaitSet、_EntryList，用来保存ObjectWaiter 对象列表。
       2.当线程进行 _owner 区,_count +1 如果线程调用wait方法,_count-1 如果_owner为空,进入_WaitSet队列
synchronized可见性，有序性，可重入性怎么实现？
   保证可见性:加锁前情况线程内存的值,加锁后重新读取最新值,然后其他线程是不可读取操作共享变量,解锁时把修改值维护回主内存
   保证有序性:加锁的代码只会被一个线程执行,符合as-if-serial,可以保证最终结果的有序性,但是不保证不会指令重排
   可重入性  :通过 ObjectMonitor内部维护的count实现可重入性,重入+1 执行完-1 如果为零释放锁
锁升级：    方向  无锁-》偏向锁-》轻量级锁-》重量级锁 // todo
    1.为什么1.6后引入锁升级
        因为重量级锁争抢不到就会造成阻塞,需要操作系统切换CPU处理,频繁阻塞消耗既系统资源也消耗时间
    2.synchronized
        字节码中对应的 monitorEnter 和 monitorExit 其实底层采用cas的一个原子操作
    偏向锁
        单线程情况下采用偏向锁保存线程信息一直持有偏向锁,所以单线程中基本没有额外开销,只是第一次需要CAS加锁
        偏向锁撤销： 偏向锁不会主动撤销,需要有其他线程竞争才会撤销
            1.持有偏向锁线程执行完毕空闲状态：CAS释放锁其他线程进行CAS持有偏向锁
            2.持有偏向锁线程没有执行完：进入安全点等待,升级轻量级锁
    轻量级锁(会在每个线程创建一块空间存放对象的对象头,尝试切换owner区指针来获取锁)
       当偏向锁在执行且其他线程竞争时候就会切换成轻量级锁,竞争的线程采用自选方式尝试获取锁,采用自旋而不是直接阻塞来提高性能
       场景：适合线程的短时间等待,用自旋操作来优化和操作系统交互的阻塞操作
    重量级锁
        当轻量级锁自旋10次还没获取到锁就会升级为重量级锁,这个时候线程获取不到锁就会阻塞。
    总结：锁升级在竞争小的时候会采用自旋可以优化线程阻塞性能低的问题
锁降级
    指的是读写锁,写锁降低成读锁。写锁中获取读锁然后释放写锁的过程。
synchronized和lock区别
    1.synchronized 是一个关键字                            lock 是一个java类
    2.synchronized 会自动释放锁                            lock 手动释放锁   不释放就是死锁   手动释放更加安全
    3.synchronized 默认可重入,不可中断,非公平                lock 默认可重入,可判断中断,非公平(可以自己设置)
    6.synchronized 底层使用监视器                          lock 底层使用AQS
AQS:抽象同步队列（CountDownLatch、ReentrantLock都是的子类） //todo
    包含共享模式和独占模式,每种模式都提供了各自的API接口(可超时、可中断)子类通过cas对volatile修饰的state不同处理来实现加锁和解锁操作
    1.ReentrantLock的加锁解锁
        1.加锁先判断state是否为0,为0可以直接通过cas进行加锁改为1,加锁成功父类保存线程信息,如果不为零说明已加锁,判断加锁线程和父类线程是一个线程如果是state+1实现可重入,如果线程不一样返回false
        2.争抢失败会将线程封装成Node通过前驱和后继组成一个链表结构,
            添加：先将自己前驱修改为上节点,然后将尾节点前驱指向自己,最后将前节点后继指向自己完成添加     这也是为什么唤醒扫描节点从尾巴开始,因为可能漏掉节点
            移除：不会自动移除,当节点获取锁就会将自己切换为头节点,之前头节点没有指针也就属于移除,垃圾回收就会清理掉无引用节点
            唤醒：新节点存入需要将前节点设置成可唤醒(-1)状态,将自身设置为0默认状态。 当线程执行发现自己为0就不会继续唤醒后继节点！
    2.信号量底层采用共享模式、CountDownLatch
        CountDownLatch会将state设置成传入大小,每次countDown使用cas进行交换,如果值为0执行wait后代码实现
ReentrantLock  默认非公平 ,传true设置公平锁  非公平吞吐量大但是可能导致一些优先级低的线程饥饿而无法执行
    非公平锁：调用lock执行进行一次抢占,不成功入队排列,发现锁被释放会进行CAS自选争抢  而公平锁会判断前面是否有其他线程处于等待,有则进行等待排到后面
CAS：比较并交换 (比较当前工作内存的值和主内存的值是否一致 一直就交换,不一致一直循环阻塞)
    缺点: 1.ABA 问题      2.循环性能开销        3. 只能保证一个变量的原子操作(如果多个变量可以通过锁保证原子性   或者变量封装成对象通过原子引用保证原子性)
单例模式：
    1.饿汉单例：Hangry
    2.懒汉单例：Lazy             DCL懒汉式               静态内部类单例模式
    3.但是他们通过反射都可以破坏单例    可以通过ENUM解决   内部提供的是一个有参构造函数,但是反射无法破坏Enum对象
---------------------------------------------------------------------------------------------------------------
ThreadLocal：线程本地变量
为什么要引入ThreadLocal？
    多线程共享资源修改线程不安全,加锁效率又低,所以对部分数据使用ThreadLocal让每个线程都有一份自己修改自己的,线程隔离保证线程安全
ThreadLocal用处？
    1.拦截器将用户信息存入ThreadLocal,就可以在任意地方取值  2.pageHelper
ThreadLocal实现原理
    Thread类中属性ThreadLocalMap,ThreadLocalMap内部使用Entry数组.entry的key是ThreadLocal弱引用,value是存入数据
    扩容：初始16 达到3/4扩容为2倍然后重新hash计算迁移到新数组中,最后改变引用指针
    hash冲突：存的时候如果位置冲突就会向后找空位置存,取的时候定位到判断是否一致,不一致向后找
为什么使用ThreadLocal作为key不使用Thread？为什么采用弱引用
    一个线程中可能存放多个ThreadLocal。这时候使用Thread就无法区分！
    强引用问题：采用强引用的话线程池不销毁,线程一直存在所以ThreadLocalMap也会保留从而ThreadLocal也无法回收造成内存泄露
如何解决内存泄露
    使用完之后通过finally方法执行remove将key和value都设置为null就会被GC回收
为什么ThreadLocal建议设置成静态
    因为一个线程对应一个ThreadLocalMap,只需要创建一次即可.不加静态每次创建对象都创建一个相同的ThreadLocal浪费资源
父子线程传递数据？线程池传递数据？  //todo
    1.JDK自带InheritableThreadLocal解决父子线程传值问题,init方法判断父线程是否有Map拷贝到子线程
    2.阿里巴巴开源TransmittableThreadLocal解决线程池传值问题。
---------------------------------------------------------------------------------------------------------------
线程的状态  Thread.state 可以查看状态
    1.new 线程被创建,但是没有调用start方法
    2.Runnable 运行：java线程将操作系统的就绪和运行都统称为运行
    3.Blocked 阻塞： 表示线程阻塞
    4.Waiting 等待的一个状态(死等)： 线程进入等待,需要等待其他线程通知或者中断
    5.Timed_Waiting 等多少秒就不等了  不同于等待是可以在固定时间内自行返回
    6.Terminated  终止  代表执行完毕

wait和sleep的区别？
    1.wait存在Object类           sleep存在Thread类
    2.wait会释放锁               sleep不会释放锁
    3.wait只能在同步代码块中使用    sleep任何地方都可以使用

工具类
读写锁
  独占锁(写锁)：一次只能被一个线程占用
  共享搜(读锁): 多个线程可以同时占用

阻塞队列：   一般在d多线程并发处理和线程池用到
    1.当队列满了,不能继续存的时候需要阻塞.等待取出然后在存
    2.当队列没有的时候,必须阻塞等待生产才能取
阻塞队列对应的四组API
    1.抛出异常                 添加:add          移除:remove            查看队首元素:element
    2.不抛出异常,有返回值        添加:offer        移除:poll              查看队首元素:peek
    3.超时等待                 添加:offer有参     移除:poll有参
    4.阻塞等待                 添加:put          移除:take
同步队列SynchronousQueue
    进去一个元素，必须等待元素取出 才能继续存放元素   存   put   取  take
顶级 collection --》queue---》blockingQueue
    blockingQueue：阻塞队列   》》》一边存 另一边取
    AbstractQueue：非阻塞队列
    Deque：双端队列           》》》 两边都可以存取
