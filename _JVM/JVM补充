1.垃圾回收是否涉及栈内存？
  不需要,栈内存就是方法调用产生的栈帧内存,方法执行结束会弹出栈,内存会自动释放.
2.栈内存分片越大越好吗？    -Xss指定栈的大小   linux 默认是1024kb(1M)    在启动设置VMOptions设置
  分配太小,如果方法递归很多可能造成栈溢出。分配太大不会影响线程的运行效率,资源浪费可能影响最大线线程数量。
如果线程过多导致栈溢出,可以适当减小最大堆和最大栈容量来换取更多线程
3.方法内的局部变量是否是线程安全的？
  方法内局部变量：如果局部变量的作用范围没有逃离方法作用范围,则是线程安全的
  方法内局部变量：如果局部变量的作用范围逃离方法作用范围,则是线程不安全的  如：参数传入  return返回
  方法外全局变量：变量是线程共享的,每个线程都可以访问操作此变量,所以是线程不安全的,存在竞争条件。可能造成结果不可知
4.栈什么情况会出现内存溢出？         java.lang.StackOverflowError
  栈帧过多,错误递归导致无限调用方法导致栈帧太多超过虚拟机栈内存
  情况： 员工对象包含部门字段   部门对象包含员工集合     将这两个对象转Json格式就会产生无限循环   解决方案就是 @JsonIgnore 忽略一个属性

线程运行诊断
1.CPU占用过高
  top命令可以查看CPU占用  从而获取进程ID(PID),使用PS命令可以查询具体进程内所有线程id(TID)对cpu占用情况
  PS H -eo   (H打印线程的进程数)(打印感兴趣的信息 后面跟PID进程 TiD线程 %CPU cpu占用)
  jstack Pid 可以查看具体信息,将线程id转换成16进制,可以查看具体Java代码行数
2.程序一直没有结果
  jstack pid 查看具体信息,如果存在死锁下面会告诉存在死锁的两个线程及代码行数。
死锁原因：1线程锁住方法A然后sleep3s 再此期间2线程锁住方法B然后要访问方法A 所以需要等待,1线程sleep结束访问方法B 也需要等待
         相互若无外力 一直等待造成死锁

5.堆内存溢出？不使用就会回收,为什么会溢出？         java.lang.OutOfMemoryError: Java heap space
     1.如果不断产生对象,而且产生的新对象不断有人使用,就不能被回收,慢慢就会内存溢出    -Xmx指定最大堆大小  -Xms指定初始堆大小
6.检测死锁方式？
  top -》 ps -》jstack    2.jconsole    3.jvisualvm  可视化虚拟机
7.垃圾回收后,堆内存无法释放还是居高不下。 使用jvisualvm可视化虚拟机中 堆快照拉取一部分堆内存进行占比排序,然后查看具体占用情况
8.方法区1.8以前导致永久代内存溢出
  -XX:PermSize=64M      初始永久代内存
  -XX:MaxPermSize=128M  最大永久代内存
9.方法区1.8以后导致元空间内存溢出    云空间自行管理垃圾回收,
  -XX:MetaspaceSize     初始化元空间内存
  -XX:MaxMetaspaceSize  最大元空间内存
  并且如果不设置初始化和最大大小空间会和系统内存大小一致
  上述初始化永久代和元空间大小会触发垃圾回收,所以需要合理设置,避免频繁垃圾回收。
10.方法区内存溢出实际场景？为什么会创建那么多class对象
  Srping中AOP使用动态代理cglib,mybatis使用cglib产生mapper接口实现类。
  都是在运行期间动态生成字节码文件代理,所以可能产生元空间内存溢出
11.为什么1.6永久代中常量池里面的字符串常量池到1.8就迁移到堆中了？
  因为堆中垃圾回收快
12简述Java中垃圾回收机制
  Java内存回收时虚拟机自动执行的,只有在堆内存不足或者虚拟机空间的时候才会进行垃圾回收,扫描没有被引用的对象进行回收










