1.如何做慢查询优化
    1.定位慢查询sql,通过慢查询日志配置,可以通过slow_log查询消耗时间比较长的SQL
    2.调研SQL是否近期改过,查看库表是否重新设计过,如果是很有可能就是这个问题
    3.查看表索引信息,大概判断执行类型然后进行SQL分析
    4.SQL分析
        1.通过 show profiles query ID 可以分析SQL使用资源情况
            发现资源异常,比如CPU占用低,IO占用高,判断是否内存参数配置不合理,导致多次回表
        2.通过 Explain 分析SQl使用索引的情况
            发现SQL写的不好,没使用索引或者索引失效了进行SQL的优化
    如果走了索引还是很慢怎么做？
        1.一般来说是数据量太大了,可以考虑把旧数据删除一些,但是只有一些极少数的可以删除数据
        2.可以考虑增加redis缓存,看实际允许的缓存和数据库的一致性是否允许部分不一致
        3.可以考虑增加聚合表,让数据分类存储多份,查询的时候可以提高效率,但是空间消耗严重
        4.如果都不合适的话可以考虑引入中间件进行分库分表,提高查询
    额外查询方式：
        1.通过全局查询日志可以查询所有执行的SQL
        2.通过SHOW PROCESSLIST 查询所有运行的线程
        3.trace可以查看最近5条SQL执行计划

2.排序算法
    1.双路算法：首先从磁盘读取主键和排序字段,在内存进行排序,在通过排序好的ID读取磁盘,返回数据
    2.单路算法：从磁盘读取所有需要的列,在内存进行排序,然后将结果返回.避免二次操作磁盘。
    缺点：当内存不够放会导致单路变多路,提高IO消耗
    解决方案：1.减少select *使用降低内存消耗  2.适当调大排序缓冲区大小

3.Explain： explain + SQL语句
    1.使用explain关键字可以模拟优化器执行SQL语句。分析语句是否存在问题
    2.使用explain 的查询结果字段分析
        1.id:select 查询的序列号,包含一组数字,表示查询中执行select子句或者操作表的顺序
            1.id相同：执行顺序由上至下
            2.id不同：如果是子查询,id的序号会递增,id值越大优先级越高,越先被执行
            3.id相同不同都有：id大的先执行。id一样的顺序执行
        2.select_type  查询的类型,主要用来区别  普通查询、联合查询、子查询等复杂查询
            1.SIMPLE：简单的查询,不包含子查询和union联合查询
            2.Primary：查询中如果包含子查询，最外层的查询被标记为 Primary
            3.subQuery：在select或者where列表中 被包含的子查询
            4.derived：from中包含的子查询被标记为衍生表,会把查询结果放在一个临时表
            5.union：第二个select出现在union之后.被标记为联合。若union包含在from子句的子查询中,外层的select将被标记为4.衍生表
            6.union result：使用union产生的结果集
        3.table：显示这一行数据是来自那个表
        4.type：访问类型排列   最好到最差   system》const》eq_ref》ref》range》index》all  查询最少到range级别  最好到ref
            2.const：通过主键或唯一键查询并且结果只有一行,
            3.eq_ref：两个表采用主键和唯一键关联时,关联查询主键或唯一键,查询结果为一行
            4.ref：使用等号的索引查询
            5.range：索引范围查询
            6.index：全索引扫描,通过最左侧第一个索引行,通过双向指针一直遍历到所有叶子节点索引行
            7.all：遍历全表查询数据
        5.possible_keys：显示可能应用在这张表中的索引,一个或者多个，但是不一定被实际使用到
        6.key：实际使用的索引  如果为null则没有使用
            1.覆盖索引：我使用1,2两个字段创建索引,而查的也是12字段。不需要通过索引去查找其他信息就是覆盖索引
        7.key_len：表示索引中使用的字节数,    相同结果下 key_len越小越好
        8.ref：就是你的条件后面的值。没有=null  有的话分常量const  和  对于值的库 表 字段名
        9.rows：读取行数
        10.extra额外：包含不适合再其他列显示 但是十分重要的额外信息
            1.using fileSort：无法利用索引完成排序操作,而是使用了一个外部排序,没采用左匹配会导致
            2.using temporary：查询数据量大内存放不下通过临时表存储
            3.using index：单独出现说明读取的覆盖索引
            4.impossible where：where条件和having条件为false,比如(where 1!=1)
4.Explain 的作用
    1.通过type判断查询的类型,是否可以进行优化
    2.查看可以使用那些索引,实际使用了什么索引,数据查询了多少行
    3.通过额外信息判断是否出现了影响性能的操作,即使进行优化

5.MySQL 数据库 CPU 飙升到 500% 的话他怎么处理?
    1.通过top命令查看是什么进程导致的CPU飙升
    2.如果是mysql导致的 SHOW PROCESSLIST 线程数是线程过多适当进行限流
    3.如果是SQL执行问题,通过Explain分析SQL具体情况进行修改(无索引或没有命中、数据库参数不合理等)
6.说说 MySQL 的主从复制?主从复制中涉及到哪三个线程？
    1.从节点IO线程:连接主节点,请求从指定位置读取binlog日志
    2.主节点log dump线程：接收到IO线程的请求后读取指定位置之后的binlog日志信息和位置信息
    3.从节点IO线程：获取到binlog日志信息放入relayLog和masterInfo中,masterInfo用于告诉告诉主节点下次读取binlog日志位置
    3.从节点SQL线程：检测到relayLog变化后会进行binlog日志解析,并且在当前数据库执行
7.异步复制存在数据丢失？
    1.主节点不会主动下发,等待从节点发请求,当主节点宕机,如果数据没有下发从节点并且存在故障转移,那么数据将会永久丢失。  MYSQL8默认复制策略、性能快。
    2.同步复制：主节点写入到binlog中后需要同步到所有从节点,并且都执行成功后。主节点才处理新的请求, 保证数据安全但是性能低
    3.半同步复制：主节点写入binlog后数据未提交前发送给所有从节点,只要有一个从节点将数据存入relayLog中且返回ACK(确认字符)。主节点就接收新请求。  保证数据不丢失,性能也比同步复制高
7.主从复制延迟的原因？解决方案？
    1.采用异步复制    2.网络延迟    3.主节点并发高,从节点只有一个SQL线程跟不上
    解决方案：1.网络优化  2.从库使用固态提高IO性能   3.并行复制：开启多个SQL线程执行relayLog,通过事务ID判断是否在同一个事务组,在一个组可以进行并行处理提高效率
8.为什么要进行读写分离？谈谈你对数据库读写分离的理解？
    1.通过部署多台数据库,主机进行写操作,从机进行读操作来提高主机写入性能
9.分库后ID怎么生成？
    1.雪花ID自增  2.Reids自增
10.分库分表迁移过程？
    1.双写机制,新表旧表同时插入
    2.将旧库数据迁移到新库
    3.当数据已经一致的时候开启双读,将一部分流量切入新库
    4.一段时间没问题后将读写流量全部切入新库,如果出现问题进行临时回滚切换旧库执行
-------------------------------------------------------------------------------------------
MYSQL锁
    1.从数据操作类型分
        1.读锁：共享锁
        2.写锁：排它锁
        3.乐观锁：更新的时候携带版本号,通过cas更新
        4.悲观锁：读锁和写锁就属于悲观锁
    2.从s数据操作粒度来分
        1.行锁：只对一行加锁,不影响其他行。开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高。  Innodb采用索引使用行锁,索引失效会导致行锁变成表锁
        2.表锁：对整个表加锁,开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突概率高，并发度最低。
        3.页锁：对一页数据加锁,开销和加锁时间介于行表锁之间。会出现死锁。并发度一般
    3.行锁是怎么实现的？ //todo
        innodb通过索引实现,当使用索引采用行锁,内部通过位图表示,对主键索引key加锁,
            优点：1.通过位图表示加锁降低内存消耗(Oracle采用数据行加锁)  2.通过对主键加锁避免多个普通索引实际是一条数据情况
    4.间隙锁(GAP)
        当用范围查询数据时,范围内数据都会加锁,可以解决幻读问题。但是会造成性能下降
    5.InnoDB 锁的算法有哪几种？
        1.记录锁：只锁定索引,而不是记录
        2.间隙锁：索引记录间隙加锁
        3.Next-key lock: 记录锁和间隙锁结合,既锁住了索引,也锁住了间隙
    4.SQL命令：
        1.查看所有表加没加锁 。 show open tables；看 IN——use这个如果0没有锁
        2.加锁  lock table 表名 【read||write】
        3.解锁  unlock tables   所有表解锁
        4.show status like 'table%'   通过这个分析系统上的表锁定。
            1.tables_locks_immediate:产生表级锁定的次数。表示可以立即获取锁的查询次数。每次增加1
            2.table_locks_waited：出现表级锁定争用而发生的等待次数。这个值高说明存在严重的表锁争抢情况
        6.如何锁定一行：  begin；  select * from user where id = 8 for update ； 取消锁定commit；
        7.如何分析行锁定： show status like ‘innodb_row_lock%’
            1.innodb_row_lock_current_waits:当前正在等待锁定的数量
            2.innodb_row_lock_time:从系统启动到现在锁定总时间长度
            3.当等待次数很高并且等待总时长也不小的时候。就需要分析看看什么问题