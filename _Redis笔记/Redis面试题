1.Redis为什么这么快？
  1.Redis基于内存,不需要磁盘IO操作
  2.Redis数据结构简单,是KEY-VALUE形式,查询时间复杂度O(1)
  3.单线程设计,直接绑定CPU,避免线程切换带来时间开销。--》新版引入多线程可以支持的网络 I/O 多线程模块
  4.多路复用IO：Redis多线程8题
2.如果大量的KEY设置了同一个过期时间,一般需要注意什么？
  如果大量key同时过期,过期点可能出现短暂的卡顿,严重可能出现缓存雪崩,一般在时间上加一个随机值,让过期时间分散
3.那你使用过Redis分布式锁么，它是什么回事？
  先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。
4.如果在setnx之后执行expire之前进程意外crash(死机)或者要重启维护了，那会怎么样？
  这个锁就永远得不到释放了，我记得set指令有非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的！
5.假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？
  使用keys指令可以扫出指定模式的key列表。
6.如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？
  keys指令阻塞线程一段时间,直到指令执行完毕,服务才能恢复。
  scan指令可以无阻塞的提取出指定模式的key列表,但是有重复概率,需要客户端去重。并且需要时间比keys指令长
7.使用过Redis做异步队列么，你是怎么用的？
  一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。
8.如果对方追问可不可以不用sleep呢？
  list还有个指令叫blpop，在没有消息的时候，它会阻塞住直到消息到来。  但是只有一个客户端可以消费消息
9.如果对方接着追问能不能生产一次消费多次呢？
  使用publish/subscribe主题订阅者模式，可以实现 1:N 的消息队列。
10.如果对方继续追问 pub/sub有什么缺点？
  客户端不能退出,退出后消息接收失败,而且消息没有持久化,后订阅接收不到前面发布的消息
11.如果对方究极TM追问Redis如何实现延时队列？
  使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。
12.一个字符串最大内存容量？  512M
13你了解最经典的KV、DB读写模式么？
  读的时候先读缓存,缓存没有读数据库,写的时候先更新数据库,在删除缓存。
14为什么是删除缓存，而不是更新缓存？
  因为缓存有时候不仅仅是直接查出来的数据,而进行了其他操作,所以删除缓存,下次查询出来操作完在存入缓存。
-----------------------------------------------------------------------------------------------------
1.Pipeline有什么好处，为什么要用pipeline？
  可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性。
  使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目。
2.对方追问RDB的原理是什么？
  fork和cow。fork是指redis通过创建子进程来进行RDB操作，cow指的是copy on write，子进程创建后，父子进程共享数据段，
  父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。
3.是否使用过Redis集群，集群的高可用怎么保证，集群的原理是什么？
  Redis Sentinal 着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。
  Redis Cluster 着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。
4.如果突然断电，数据能恢复多少？
  如果AOF是每条都sync同步到磁盘则不丢失数据,保证高性能一般都是每秒同步一次,这个时候会丢失几秒数据
5.如果多个系统并发操作带来的数据问题？
  ABC三个系统,本来顺序是123,如果A网络延迟成了231则流程错误,比方说下单,支付,退款,如果流程错误就成了先退款再下单,肯定会出问题。
  解决：1.zookeeper获得分布式锁,确保同一时间只有一个实例在操作key,其他实例不能读写.
      2.要修改数据肯定先从数据库查数据,查出来携带时间戳,写之前判断时间戳,判断是否比缓存中的时间新,如果是可以写,否则禁止覆盖数据
6.你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？
  如果系统允许数据有偶尔不一致。如果必须要强一致的话,读请求和写请求串行化,但是性能会降低,并发高可能会阻塞。
7.MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？
  redis内存到达最大内存,就会实行淘汰策略。淘汰策略LRU和LFU 最近最少使用和最近不经常使用。可以将不是热点的淘汰。保证最后都是热点
8.Redis变慢原因
  1.阻塞主进程
    1.持久化操作阻塞进程  (在Fork进程的适合阻塞,如果redis实例很大,阻塞时间也很长)
    2.大key操作         (创建分配内存和删除释放内存很耗时,可以使用子进程异步删除  UNLink命令。开启一个配置使用del也可以异步删除)
    3.从节点全量复制产生持久化文件
    4.到达最大内存使用交换区 或者使用淘汰策略  （使用的是异步删除,但是也会产生一定阻塞）
    5.命令复杂度高      （常见：如set list执行排序 时间复杂度高）
  2.操作系统
    1.使用了交换区
    2.网络延迟
-------------------------------------------------------------------------------------------------
redis缺点:
  1不好在线扩容。2.主机宕机会丢失部分数据3.主从机数据出现短暂不一致
为什么要用 Redis 而不用 map/guava 做缓存?
  缓存分为本地缓存和分布式缓存。以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，
  生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。
  redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。
  缺点是需要保持 redis 或 memcached服务的高可用，整个程序架构上较为复杂。
 缓存类型：
   1.本地缓存
     本地缓存是内存访问，没有远程交互开销，性能最好，但是受限于单机容量，一般缓存较小且无法扩展。
   2.分布式缓存
     分布式缓存一般都具有良好的水平扩展能力，对较大数据量的场景也能应付自如。缺点就是需要进行远程请求，性能不如本地缓存。
   3.多级缓存
     为了平衡这种情况，实际业务中一般采用多级缓存，本地缓存只保存访问频率最高的部分热点数据，其他的热点数据放在分布式缓存中。
Redis常见的性能问题和解决方案
  1.Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以Master最好不要写内存快照。
  2.Master AOF持久化，如果不重写AOF文件，这个持久化方式对性能的影响是最小的，但是AOF文件会不断增大，AOF文件过大会影响Master重启的恢复速度。
  Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化,如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。
  3.Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。
  4.Redis主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内。
