1.为什么While可以防止虚假唤醒而if不行？
  因为线程被唤醒后执行的是wait之后的代码,如果是if就执行完出if判断了  而while往下执行还会进行一次判断  所以能防止虚假唤醒
2.死锁 活锁、饥饿区别
  1.死锁：两个或者两个以上线程,因抢夺资源造成的相互等待,没有外力作用就一直等待。
  2.活锁：(自旋锁)因为条件不满足,一直失败然后重试。状态会改变,并且有可能自己解锁。
  3.饥饿： 线程无法获取资源,无法执行  1.优先级高的一直执行,导致优先级低的无法执行     2.线程await之后总是其他线程被唤醒。造成无法执行
3.线程调度算法是什么？
  时间片轮转方式切换，
  也可以通过设置优先级,抢占式,但是可能会造成线程饥饿
4.为什么要引入Executor框架？和Executors区别      todo：juc书签
  1.可以对线程统一管理,并且减少线程创建和销毁的开销,可以创建最大线程数和拒绝策略来控制线程数,实现线程复用,
  Executor框架包括：线程池，Executor，Executors，ExecutorService，CompletionService，Future，Callable等。
  Executors提供四张线程池创建。 single fixed schedule cached  但是可能造成OOM  推荐使用ThreadPoolExecutor
5.如何停止一个正在运行的线程？
   1.使用stop命令停止线程,是一种恶意中断,无论执行是否完整都会立即中断线程,可能会破坏原子性
   2.使用 interrupt 生成中断标记,使用isInterrupt判断是否存在终端标记,return中止
   3.当线程处于  sleep,wait,join 的时候,如果使用interrupt会抛出异常终止
   4.使用volatile共享变量实现线程中断  while(共享变量)  设置false可中断循环
Thread.interrupt()原理： 不会强制线程退出,因为可能导致数据不安全,所以通过通知让他自行结束
    只是一个通知,如果线程在阻塞状态,会抛出InterruptedException异常  如果线程正在运行,只是将中断标志设置为true,执行的线程判断标志位如果为true就自行中断
shutdown和shutdownNow区别
    shutdown:不接收新任务,但会执行完当前正在执行和阻塞队列中的任务
    shutdownNow：不接收新任务,丢弃阻塞队列中的任务,尝试中断正在运行的任务(不推荐使用 会造成线程安全问题)
线程常用的一些方法
    1.Join ： 如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才会继续执行
    2.wait,wait(long time):
    3.sleep
    4.notify,notifyAll:  随机唤醒一个被wait的线程  或者唤醒所有被wait的线程
    5.yield：暂停正在运行的线程,运行其他线程运行。问题：有可能还是他获得现场
    6.interrupt：中断线程  由运行状态到死亡状态   当前线程正在运行或阻塞，仅仅修改标示位，不在做其他的事，如果是join，sleep，yield，则会抛出Interrup异常，修改标示位为false
    7.setDaemon：设置当前线程为守护线程
    8.getPriority：设置优先级  也可以get获取优先级
    9.isAlive判断线程是否激活状态 (阻塞,运行)
-------------------
各种锁的理解：
    1.公平锁：非常公平 ，线程谁先来的谁限制性 不能插队
    2.非公平锁：不公平锁可以插队。比如一个任务三个小时。后来一个3s可以执行完。为了效率就让他插队。synchronized使用非公平锁
    3.可重入锁（递归锁）： 拿到了外面的锁就可以拿到(自动获得)里面的锁   所有的锁都是可重入锁。必须全部释放才行
       可重入锁 synchronized和lock区别： synchronized是一把锁  lock是两把锁。外面的锁解外面 里面的锁解里面
    4.自旋锁：cas底层就是自旋锁。如果条件成立交换 如果条件不成立就一直在循环里
    5.死锁：
    一个用户A 访问表A(锁住了表A),然后又访问表B；另一个用户B 访问表B(锁住了表B)，然后企图访问表A；这时用户A由于用户B已经锁住表B，
    它必须等待用户B释放表B才能继续，同样用户B要等用户A释放表A才能继续，这就死锁就产生了。
    6.闭锁(减法计数器)
    7.读写锁
乐观锁：原子引用的cas就类似乐观锁。在使用的时候判断一下版本是否被修改过
悲观锁：当要对数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。
行锁表锁 synchronized  lock都是悲观锁。在操作之前加锁其它线程等待  主要分为共享锁和排他锁：
