虚拟机：
    1.系统虚拟机：对物理计算机的仿真。VMware
    2.程序虚拟机：相当于应用。在操作系统上安装,代表JVM
--------------------------------------------------------------------------------------------------
JVM的生命周期：
  1.启动
    java虚拟机启动是通过引导类加载器创建一个初始类来完成的.这个类是由虚拟机的具体实现指定的
  2.执行：执行Java程序
    执行一个java程序的时候,真正执行的是一个Java虚拟器进程。   程序启动才执行,程序结束就停止
  3.退出
    1.程序结束正常退出
    2.遇到异常或者错误 终止
    3.操作系统错误  终止
    4.线程调用RunTime类或者System类的exit方法结束或者直接调用RunTime类halt方法终止线程
    5.JNI（JAVA native interface）:描述了用JNI加载或卸载虚拟机时,java虚拟器的退出情况
--------------------------------------------------------------------------------------------------
class二进制文件
  cafe babe (魔术)：表示这是一个java文件,
  0000 0034：小版本号,大版本号(十进制是52 对应JDK1.8   53对应JDK1.9)
  常量池信息  访问修饰符 全限定名  接口数量  属性 方法
java文件编译Class文件,常量池载入运行时常量池,方法字节码载入方法区,main方法运行分配操作数栈和局部变量表,执行引擎JIT编译器编译成机器指令交给CPU运行
----------------------------------------------------------------------------------------------------
指令
操作数栈
  bipush 将一个byte压入操作数栈   sipush 将一个sort压入操作数栈  ldc将一个int压入操作数栈  ldc2_w将lang分两次压入
  一个操作数栈的宽是4byte 不够0补齐,超过short范围的数字就放入常量池中,否则就和字节码指令放一起
局部变量表
  istore 将当前操作数栈的值放入局部变量表    iload  读取局部变量表的的值读入操作数栈

多态原理( JVM自己优化：1.同一个方法调用多次会增加到缓存中 2.当多态只有一个实现类会做成单态优化)  HSDB工具
  类的加载链接阶段生成虚方法表(vtable),vtable中记录了每个虚方法(静态和final修饰之外都是虚方法)的偏移量和内存地址
  1.一个方法被重写,对应vtable中的指针从父类方法改为自己方法 Object(equals,hashcode,finalize,toString,)
抽象方法和虚方法区别？
  1.虚方法有方法实现(方法体),抽象方法没有方法实现
  2.抽象方法只能在抽象类中定义,虚方法可以在任何类中定义
  3.抽象方法必须在派生类(子类)重写,和接口类似,但是虚方法不需要
多态概述？
  1.方法重载：典型构造方法,方法名相同,参数不同(参数个数,参数类型,返回值可以相同可以不同)
  2.方法重写：父类与子类的多态性,重写父类方法  方法名参数返回值都相同
---------------------------------------------------------------------------------------------------
Java执行流程
  1.java文件通过前端编译器生成.class文件
     1.词法分析-》语法分析-》语言/抽象语法树-》语义分析-》注解抽象语法树-》字节码生成器
  2.经过Java虚拟机
     1.类加载器
     2.字节码校验器
     3.执行引擎                 高级语言翻译成机器指令的过程
        1.翻译字节码(解释运行)：将字节码文件编译成字节码指令
        2.JIT编译器(编译运行) ：将字节码指令翻译成机器指令。同时将反复执行的代码缓存起来。保证执行性能
     4.操作系统
----------------------------------------------------------------------------------------------------------------------
运行时数据区（RunTime date area）
内存：非常重要的系统资源,是硬盘和CPU的中间仓库及桥梁,承载着操作系统和应用程序的实时运行。
    JVM内存布局规定了Java在运行过程中内存的申请,分配,管理的策略,保证了JVM的高效运行
    1.JVM运行一个应用有多个线程并发执行
    2.Hotspot的虚拟机里每个线程和操作系统的本地线程直接映射.
    3.当Java线程准备好执行后,操作系统的本地线程也同时创建,java线程终止后本地线程也会回收
    4.操作系统负责所有线程的安排调度到任何一个可用的CPU上,一旦本地线程初始化成功,就会调用Java线程中的Run方法
    5.本地线程回收前决定JVM要不要终止。看当前线程是不是最后一个非守护线程
虚拟机里主要的后台程序线程
    1.虚拟机线程
    2.周期任务线程
    3.GC线程
    4.编译线程
    5.信号调度线程

------------------------------------------------------------------------------------------------
垃圾回收

安全点(SafePoint)：
  GC垃圾回收之前,所有Java线程都需要进入安全点才能开始垃圾回收。
    1.循环的末尾
    2.方法返回前
    3.抛出异常的位置


垃圾回收调优
  1.
调优方向：
  1.GC调优
  2.IO调优
  3.锁竞争调优
  4.CPU占用调优
  5.内存调优
------------------------------------------------------------------------------------------------
JVM架构模型：
  1.基于栈式架构特点：
    1.涉及和实现更简单,适用于资源受限系统
    2.避开寄存器分配难题。使用零地址指令方式分配
    3.执行过程依赖于操作栈,指令集小,编译器更容易实现
    4.不需要硬件支持,可以执行更好,更好实现跨平台
    优点：跨平台性,指令集小
    缺点：指令多,频繁入栈出栈.执行性能比寄存器方式差
  2.基于寄存器架构特点
    1.典型的应用式X86二进制指令集
    2.指令集架构完全依赖于硬件,可移植性差
    3.性能优秀,执行更高效
    4.花费更少的指令去完成一个操作。一般是一地址指令,二地址指令和三地址指令。而基于栈的架构是零地址指令
  3. 总结
    1.优化跨平台设计。java的指令都是基于栈方式实现的
    2.不同的CPU架构不同,所以不能设计为寄存器的
-------------------------------
新生代大小                    -Xmn(-XX:NewSize初始  -XX:MaxNewSize)
GC详情：                     -XX:PrintGCDetails -verbose:gc
幸存区比例（动态和固定）  晋升阈值    设置FullGC之前是否进行MinorGC,一般开启 可以加速FullGC


如果想要手写一个JVM虚拟机,主要考虑那些结构？   类加载器和执行引擎

数组+链表  链表长度超过8变成红黑树      下层是table数组   key value可以为空   默认是16  加载因子0.75   就是一个最优的设置
数组长度超过12数组扩容  扩容后就是重新has计算
hastable  key不为空
单链表：开始节点是头节点  只保存下一节点指针 删除只需要改变引用 不需要移动数据  时间复杂度 O(n)  只能从前向后查
双向链表：头和尾引用null 前后都可以查    删除只需要改变引用 不需要移动数据     时间复杂度 O(n)
二叉树时间复杂度  O(n)
红黑树和二叉平衡数  时间复杂度O(lgn)
b 和  1到树深之间  b+树  稳定在树高

冒泡排序：  一个一个比较 最大的放最后面                           时间复杂度：O(n方)    空间复杂度 O（1）
选择排序：  每次从已知数据中拿最小的放到前面                       时间复杂度：O(n方)    空间复杂度 O（1）
插入排序：  每次插入一个值,放到链表中相应位置                      时间复杂度：O(n方)    空间复杂度 O（1）
