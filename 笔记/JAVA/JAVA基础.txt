JAVA体系结构
    1.java程序设计语言(语言 C/C++)    2.java class 文件格式     3.java应用编程接口(Java API)     4.JVM
    使用java语言调用Java API编写Java文件 编译成Class文件  提供JVM执行
1.面向对象和面向过程的区别？
    1.面向对象：将一个功能分析有哪些实体,实体中属性和方法.通过方法调用完成功能。 优点：复用性高,容易扩展  缺点：创建对象实例需要消耗性能
    2.面向过程：将一个功能自顶向下拆分,逐步细化的一个过程                    优点：性能高           缺点:复用性和扩展性低
2.JAVA(面向对象)的特性
    1.封装:将具体功能封装成方法,提高代码复用性
    2.继承:使子类继承父类的属性和方法,既可以直接使用也可以重写覆盖
    3.多态原理(invokeVirtual)
        1.重写(运行时多态):运行时才确定具体掉用的方法,
        2.重载(编译时多态):方法名相同,参数列表不同(参数个数,参数类型,参数顺序)
        1.通过栈帧中对象引用找到堆中类对象  2.分析对象头找到方法区的Class详细信息  3.每个类都有一个虚方法表(vTable)在链接阶段就生成好了  4.查找虚方法表得到方法具体地址  5.执行方法字节码
    4.虚方法:Java种所有被重写的方法都是虚方法
    5.字节码方法调用方式 1.invokeStatic执行静态方法 2.invokeSpecial执行init方法(静态属性静态代码块) 3.invokesVirtual执行虚方法  4.invokeInterface执行接口
3.构造方法相关问题
    1.子类调用构造方法默认会执行父类的无参构造(因为可能用父类的属性和方法,所以必须先创建父类对象在创建子类对象)
    2.super()调用父类构造this()调用重载构造,他们都只能放到构造方法第一行,不能同时出现
4.static和final //todo 2023.4.17
    static：1.静态属性和代码块类加载时加载,所以不能使用this和super  2.静态方法可以通过类名调用(可被继承不可重写),静态内部类(只是方便管理)
    final： 1.static final必须赋值  2.final修饰的引用类型内部非final属性可以被修改
            3.final存在内存屏障,其他线程使用必须要等构造方法执行完赋值。防止获取未初始化的对象(包装类内部都是用final的原因)
5.Java 中创建对象的几种方式？
    1.new关键字    2.反射创建    3.clone拷贝    4.反序列化
6.深拷贝和浅拷贝的区别(其实是针对Object和Array这种引用类型的)
    浅拷贝：只是复制指针,两个对象指向一个内存。修改新对象会影响到原对象
    深拷贝：深拷贝会开辟内存复制对象,两个对象修改互不影响
    深拷贝实现：
        1.clone方法内部包含引用对象则需要链路上全部重写clone方法           性能最高,但是容易一环漏掉产生问题
        2.通过第三方工具实现 cglib、commons-beanutils都提供了深拷贝方法   性能中等,使用方便   (项目中如果存在工具类就没必要换)
        3.反序列化创建的对象是深拷贝                                    性能很低,不推荐
7.值传递和引用传递
    值传递：基本数据类型都是值传递  传递的是值的副本                  特殊：数组都是引用传递
    引用传递：引用数据类型传递的是地址 修改对应数据会导致原数据变动      特殊：String存在字符串常量池中,副本改变不会影响原本的值
8.序列化和反序列化： 对象和字节序列转换过程
    序列化反序列化：对象和二进制流的相互转换
    注意： 1.transient字段不序列    2.建议手动声明serialVersionUID,防止编译器不同产生报错   3.选择序列化工具 看功能、性能、兼容性 常用jackson、fastjson、kryo
9.接口和抽象类(抽象类不可实例化,接口实例化采用lambda表达式实现方法即可) //todo 2023.4.17
    抽象类：单继承,可实例化(匿名内部类),子类必须重写抽象方法,否则就需要把自己变成抽象类
    接口： 多继承(为了解决抽象类单继承),方法(public abstract)、常量(public static final),JDK8支持存在default和static方法
10.数据类型：  整数型默认int  浮点型默认Double
    1.整形默认0（byte 1字节 ，short 2字节，int 4字节，long 8字节） 浮点型默认0.0（float 4字节 double 8字节） 布尔型默认false boolean 1字节 字符型默认空 char 2字节
    2.自动类型转换：byte->short<->char—> int —> long—> float —> double    如果不按这个顺序编译报错(需要强制类型转换) char转换按照ASCII码转换
Integer //todo 2023.4.17
    1.Integer 有缓存数组-128<=value<=127 超过范围才会new  所以不建议使用==比较
    2.new Integer(123) 每次都会新建一个对象；  Integer.valueOf(123) 会使用缓存池中的对象
float、Double:
    因为浮点数采用尾数+阶码所以  基本数据类型用==,包装类型用equals比较出问题
    解决： 1.在一个范围内就认为相同      2.采用BigDecimal进行运算比较操作
BigDecimal //todo 2023.4.17 (1)
    1.new BigDecimal传入double会产生精度问题,建议将构造方法改为valueOf,内部会先将double类型转成String类型传入,避免阶码造成影响
    2.两个BigDecimal使用equals可能会产生问题,因为会比较精度   建议使用compareTo比较
    3.BigDecimal做除法运算一定要处理精度和舍入模式,因为可能产生无限小数
    4.当BigDecimal输出String类型使用toString会采用科学计数法(E+)   可以使用toPlainString不采用科学技术
Char是否可以存中文字符 //todo 2023.4.17
    Java的编码是UTF16,一个中文占两个字节. 当编码改成UTF8一个中文占三个字节. char采用Unicode包含中文所以UTF16下可以存中文,而UTF8情况下会变成？
String
    1.为什么String是不可变的类？ 主要为了节约内存提高效率
        1.字符串常量池作用就是节约内存资源,如果类可变两个String共用一个指针会导致线程安全问题   2.String创建就包含了hash作为属性,提高集合使用效率
11.String、StringBuilder、StringBuffer
    String："+" --> StringBuilder.append.toString(new String)   适合少量字符串操作,每次创建对象所以效率最低,发生GC才会清理不使用的
    StringBuilder: 线程不安全,不创建新字符串,单线程循环中使用,效率最高
    final 修饰 StringBuffer 后还可以 append 吗？     //todo 2023.4.17
        可以,因为final只是外层引用不可变,而StringBuffer内部是一个引用类型char数组,所以可以修改内部引用数据
    StringBuffer:  线程安全,不创建字符串,多线程循环中使用       区别：（*加没加锁）
    他们扩容机制: 无参构造默认存放16个字符,有参String类型默认String长度+16个字符,有参int类型默认是设置的int值大小 。扩容大小为原始*2+2   之所以加2是因为拼接后末尾存在多于字符
12.Switch上可以使用 char、byte、int、String、enum  不能使用 float、double、boolean
13.equals 和 hashCode 和 ==
    equals:引用类型默认调用Object的equals使用==比较地址。 String重写后会先比较地址,地址一致返回true不一致会遍历字符数组,全一模一样也会返回true否则返回false  Integer则是转成int进行==
    ==：基本数据类型比较值是否一致,引用数据类型则是地址
    hashCode引入背景：集合中判断重复如果全用equals 效率很低,hashcode是一个优化,先通过hash计算位置然后找到使用equals判断,提高效率 也就是说hashCode和equals都相同就认为重复
    问题：集合中如果key的hashCode不相同就会认为不存在,所以可以一直put
    解决：所以重写equals必须要重写hasCode
14.常用函数：
    Math.floor()   表示向下取整，返回double类型   （floor---地板）
    Math.ceil()    表示向上取整，返回double类型    （ceil---天花板）
    Math.round()   四舍五入，返回int类型
15.你对泛型有多少了解？
    泛型的引入是一种优化,之前用Object表示任意对象,获取时强制类型转换可能存在异常,而且执行阶段才能复现.程序不安全。泛型编译通过则运行不会产生强转异常问题
    类型擦除：在字节码中实际存储和取出都是使用泛型的顶层父类,正常情况下都是Object,当我们指定<t extends String>的时候会使用String,在取出时从字节码中获取类型进行强转
    泛型通配符: 1.<? super T> 传入参数为T或T的父类   2.<? extends T> 传入参数为T的子类不包含T (*所以这样设置最终类只能传null,因为没得子类)
16.反射
    作用：运行期间根据配置决定要获取的类,避免代码耦合度高修改时需要重新改代码编译打包
    优点：运行期判断获取类,灵活度高,提供了代码扩展性  缺点：性能低(反射动态加载类,无法使用解释器编译器进行优化),动态操作修改类可能导致线程不安全
    场景：1.JDBC加载驱动  2.Spring配置文件实例化class方式  3.Tomcat的Servlet,对外配置web.xml加载用户配置的Servlet
17.代理模式： //todo 2023.4.17 具体继承实现方式
   作用： 1.可以对方法进行增强,例如AOP实现增强方法   2.控制是否可进行目标方法的调用
   静态代理： 需求变了改代码实现功能    优点：容易理解,使用方便 2.如果改动较大,大部分类都要修改
   动态代理： 增强方法写在代理类中,只需要将业务代码生成一个代理对象即可   优点：耦合度低,灵活度高便于维护
       JDK Proxy: 实现 InvocationHandler接口 重写invoke方法进行增强。 基础是反射机制,因为执行方法调用method.invoke。创建实例调用proxy.newProxyInstance
       CGLib Proxy：实现 MethodInterceptor接口 重写intercept方法进行拦截增强。 原理是创建目标类子类,setSuperClass实现,覆盖其中方法进行增加。所以final方法不可用
       差异性：
           1.JDK代理是JAVA原生提供的,JDK8性能提高很多而且写起来方便,但是只能对接口进行增强   CGLib都可以进行增强,Spring提供的还需要引入ASM.jar,基于ASM(字节码操控框架)实现
           2.JDK代理直接编译生成字节码加载到JVM而CGLIB使用ASM效率较低,但是执行方法JDK使用反射而CGLIB使用FastClass为代理类和被代理类各一个类,通过index确定调用方法  整体：CGLIB速度快
           3.JDK代理生成的代理对象继承Proxy,所以只能基于接口实现完成动态代理(非继承),只能代理接口实现类   CGLIB创建子类方式：所以private,final方法不可代理
18.访问修饰符
    public:   当前类、同包内(同包子类、同包其他类)、不同包子类  其他包 都可以访问
    protect： 当前类、同包内(同包子类、同包其他类)、不同包子类                              除了当前类和同包下和不同包子类 其他都不可以访问
    default： 当前类、同包内(同包子类、同包其他类)、                                      除了当前类和同包下都不可访问
    private： 当前类                                                                除了当前类都不可访问
19.来讲讲什么是注解？
    1.代码中的特殊标记,可以在编译,加载,运行时执行相应的处理    原生@Overried、@FunctionalInterface
    2.自定义注解自动继承 Annotation(元注解),
    3.元注解专门的一些注释
        1.@Target ：用来限定注解的位置,比如接口,属性,方法等  一般来说使用方法
        2.@Retention：用来表示注解的生命周期,包括 源文件阶段、编译到class阶段、运行阶段       默认CLASS
            源文件阶段：不会参与到编译和运行 一般就是注释作用
            编译到class阶段：编译期间可能会做一些处理,运行期读不到    Lombok就是这个编译阶段完成的get\set方法嵌入  继承一个类实现方法
            运行阶段：一般配合AOP 通过反射获取到注解然后执行相应的操作
        3.@Documented注解，是被用来指定自定义注解是否能随着被定义的java文件生成到JavaDoc文档当中。
        4.@Inherited注解，是指定某个自定义注解如果写在了父类的声明部分，那么子类的声明部分也能自动拥有该注解。@Inherited注解只对那些@Target被定义为ElementType.TYPE的自定义注解起作用。
20.IO流 //todo 2023.4.17 (2、3)
    1.字符流和字节流区别？
        1.读取的最小单位不同,字节流为一个字节,java默认UTF16下字符流占两个字节   2.Reader和Write都是字符流,Stream一般都是字节流
    2.IO流的细分种类
        1.StringReader/StringWriter：字符串流,专门操作String字符串
        2.FileInputStream/FileReader：文件流,专门操作文件读取
        3.InputStreamReader/OutputStreamReader:转换流,提供了字节流和字符流之间的转换
        4.BufferedInputStream/BufferedOutputStream：缓冲流,读取进行缓冲减少IO操作,提高性能
    3.字节流和字符流如何选择？
        1.大多数情况下选字节流,因为字节流是字符流的包装,大多数IO操作都是操作磁盘文件,在传输时是按字节传输.（图片等文件都是按字节存储的）
        *如果操作大文件时,推荐使用带缓冲的字节流或者字符流,可以提高性能, BufferedReader | BufferedInputStream 等
21.五种IO模型： //todo 2023.4.17
    什么是IO(数据包准备好后,将数据包拷贝到内核缓冲区,再从内核缓冲区拷贝到用户缓冲区)
        1.文件IO：将磁盘文件读取到用户空间
        2.网络IO：用户发起读请求,服务器将数据发回来,应用程序将数据拷贝到用户空间
    1.BIO(同步阻塞IO): Socket都是BIO
        用户发起读请求,如果内核没有准备好数据包就会发生阻塞
    2.NIO(同步非阻塞IO):
        用户发起读请求,如果内核没有准备好数据包就会返回错误,用户一直发送请求
        缺点：用户不断发起请求,占用CPU
    3.多路复用IO(同步阻塞IO):
        内核用一个线程来顺序轮询多个socket状态,当数据就绪后,将数据拷贝到内存
        缺点：顺序轮询连接数据大会导致后面阻塞时间长 2.大部分判断都是没有准备好
    4.信号驱动IO(同步非阻塞IO)：
        内核数据准备好时发送信号给用户,用户发起读请求
        缺点:用户需要增加信号处理函数,并且需要保证信号不丢失,否则会一直阻塞
    5.AIO(异步非阻塞IO):
        用户发起读请求不会阻塞客户端,内核数据准备好后自动拷贝到用户内存然后通知客户端已完成
        注意：异步IO是需要操作系统的底层支持，在Java 7中，提供了Asynchronous IO
    BIO和NIO使用场景？
        1.当连接数很多,但是每次都是少量数据,比如聊天服务器,选用NIO比较好
        2.当连接数较少,每次发送大量数据时,BIO更适合。  实际选择： 阻塞时间和内核处理时间进行衡量
22.底层IO设计模式
    1.TPR模式
        传统的Server/Client模式,服务器为每个客户端创建一个线程,线程多会导致上下文切换,降低性能,所以引入线程池,控制线程数量
        缺点：当线程数被所有长连接占用会导致新的客户端无法连接,所以线程池只适合大量短连接场景
    2.Reactor模式
        所有客户端请求都发送到一个多路复用器上,内核一个线程判断是否就绪,就绪后将事件分发到相应处理器执行,处理完毕后线程继续轮询,结果响应给客户端
        核心组件：
            1.描述符：每次socket生成一个描述符,用于区分事件
            2.事件分发器：根据事件类型分发到具体的执行器
            3.事件处理器：根据时间请求处理事件
            4.I/O多路复用函数：根据系统自动选择最佳函数,select、poll、epoll、kqueue
    3.Proactor模式
        客户端注册事件绑定事件分发器,向内核发起调用,内核处理完拷贝到用户内存后通知通知客户端分发给处理器执行事件,将分发处理过程移交给客户端处理
23.Kafka为什么快
    1.页缓存：
        为了优化读写,利用操作系统内存进行读写,内存操作性能高,加上顺序读写性格高于随机读写,所以实现读写数据的高性能
    2.顺序读：
        数据顺序存储到硬盘,所以在读的时候按顺序读取,而不是随机访问
    3.零拷贝：
24.零拷贝实现方式
    1.传统读写方式:读的时候拷贝到系统内存,然后系统内存拷贝到用户内存,写完在拷贝回系统内存,最后拷贝到网卡
        1.需要四次上下文切换和四次文件拷贝
    2.(MMAP+write),读的时候先拷贝到系统内存,通过内存映射方式访问。写的时候从系统内存拷贝到网络缓冲区,操作完拷贝到网卡
        1.需要四次上下文切换和三次文件拷贝   java直接内存、kafka的插入数据都是采用mmap+write方式
    3.(SendFile)方式,调用sendFile函数后切换到内核态,将文件拷贝到系统内存,然后通过CPU拷贝到网络缓冲,最后拷贝到网卡,最后切换回用户态
        1.需要两次上下文切换和三次文件拷贝   缺点：虽然降低了上下文切换次数,但是文件用户不可见,Kafka的发送数据使用的就是这种方式
25.直接内存访问技术(DMA)
    通过CPU调用IO操作会导致CPU长时间等待,浪费性能,直接内存访问技术是一种无须CPU参与就可以数据在设备和系统内存进行双向传输提高CPU的效率
26.内部类种类和作用 //todo 2023.4.19
    1.成员内部类:可以访问外部类的属性和方法,静态方法可以直接调用。  外部类需要先实例化内部类后才能访问
    2.静态内部类:只能访问外部类 静态变量和静态方法【私有也可以】,例：单例模式实现
    3.匿名内部类:类似对函数式接口进行实例化,对抽象类进行实例化重写抽象方法
    4.局部内部类:定义在代码块中
    内部类作用
        1.可以调用外部类的私有或保护方法
        2.通过内部类继承其他类,间接实现多继承（外部类和继承类都可以访问）
23.SLF4J、JCL 和 Log4j、LogBack区别？ //todo 2023.4.19
    1.Log4j、Log4j 2、LogBack、JUL 属于日志系统,主要用来输出日志(并且Log4j出现过漏洞 导致JNDI注入问题)
    2.SLF4J、JCL 属于日志框架,提供统一的API使用,底层切换日志系统时不需要修改业务代码。 相当于JDBC,切换数据源不需要改代码,修改配置即可
24.Comparable 与 Comparator //todo 2023.4.19
    Comparable 是排序接口,重写compareTo 即可进行比较,实现方便但是一个类只能有一种比较方式,如果需要多种比较算法没办法解决
    Comparator是比较器,当一个类需要多个比较算法时通过创建新的比较器类进行实现,灵活性和扩展性高

25.静态代码不会重复加载,非静态代码和构造方法是一组(执行父类 非静态+构造 ->执行子类 非静态+构造)
-----------------------------------------------------------------------------------------------------
异常处理
1.finally  *坑(1.finally中最好不要写return  2.finally中修改基本数据类型对返回无影响)
    1.finally中有return就不会执行try或catch的
    2.finally中修改引用类型和基本类型是因为压入操作数栈的如果是引用就会被关联修改,如果是值传递则不会变(i++一样,i已经放进去了修改局部变量表不影响返回)
    3.进入try代码块那么finally一定执行,没有进try就报错finally也不执行
2.throwable
    1.Error：系统错误,程序无法处理,出现只能暂停程序解决问题   例：系统崩溃、内存溢出。
    2.Exception:异常,程序可以处理
        1.checkException：编译时异常,需要显示try catch处理  常见：IOException、FileException
        2.RuntimeException：运行时异常,不需要捕获,全局异常处理掉即可
3.throw 和 throws
    1.throw:代码中表示要抛出异常，如果运行时异常不需要其他处理,非运行时异常需要需要方法上申明,并且调用方需要try catch处理或继续申明抛出
    2.throws：申明方法可能抛出异常,需要调用者处理异常
4.主线程怎么捕获子线程异常
    1.callable：使用FutureTask.get可以捕获子线程异常
    2.使用线程池的submit方法可以捕获子线程异常
5.全局异常处理 //todo 2023.4.17
    1.在全局异常处理类增加 @RestControllerAdvice 作用到所有 RequestMapping 的控制器方法上
    2.如果方法抛出异常可以通过 @ExceptionHandler 捕获进行统一封装,通过异常类型进行响应分类处理
-----------------------------------------------------------------------------------------------------
Java8新特性
1.lambda：解决new 接口时代码冗余的现象,但是接口中只能有一个未实现方法,一般会增加 @FunctionalInterface 防止别人误以为普通接口增加方法
2.lambda表达式forEach如何提前中止？ //todo 2023.4.17
    1.lambda中return本身是针对方法的,所以不会中断后续执行。改用原始For循环,通过break或return终止
    2.抛出异常,通过异常中止后续执行,然后通过异常捕获来保证遍历之后的代码继续执行
3.函数式接口
    1.consumer：消费型接口 accept方法 有输入 没有返回
    2.function：函数型接口 apply方法 传入参数T返回参数R
    3.predicate: 断定型接口 test方法  输入一个参数  返回一个Boolean
    4.supplier：供应型接口           没有输入 只有返回
4.Stream流式计算
   定义：只是进行数据的处理,并不存储,从A端进入管道,进行排序,筛选等操作从另一端输出就类似于流,可以传入集合,数组数据
       1.parallelStream和Stream  生成串行流和并行流
       2.forEach：迭代流中数据      3.filter：过滤元素              4.limit：指定数量
       5.sorted：排序              6.distinct：去重               7.map映射每个元素进行相应操作
       8.Collectors：数据合并,返回集合或者字符串
5.新的时间处理API：之前的util.data都是可变的,线程不安全
   LocalDate/LocalTime ：now方法获取现在时间

