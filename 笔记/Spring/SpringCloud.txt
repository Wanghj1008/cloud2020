微服务: Spring Boot
    将一个应用拆分成多个微服务,每个服务可以独立部署,服务之间通过http、RPC交互
    优点
    1.多个服务可采用不通技术栈  2.负载高时关闭非热点服务  3.部署快,修改bug只需要重启对应服务
    缺点
    1.微服务搭配分布式整体架构复杂,运维难度增加  2.工具类等不能共享,代码冗余增加
分布式: Spring Cloud、Dubbo
    一个微服务部署在多台机器上,多台计算机组合部署一个应用,提高性能和可用性
    难点
    1.服务接口开放产生安全性问题  2.网络传输信息丢失  3.分布式产生的难点(服务发现、服务限流、负载均衡、链路跟踪等)
云原生: Docker
    将分布式应用部署在云平台
    难点
    1.根据服务流量弹性伸缩(流量大自动多部署几台,流量小减少)
    2.服务自愈(服务器崩溃自动在其他计算机部署)
    3.自动化部署
    4.灰度发布(服务升级少部分替换,没问题全部服务替换)
SpringCloud 和 Dubbo 区别？ //todo 2023.04.15
    Dubbo 采用 Zookeeper做注册中心、采用RPC方式远程调用、性能高因为数据二进制传输,比HTTP报文方式节约性能
    Spring Cloud 可以自主选择组件、采用HTTP远程调用、性能不如Dubbo但是提供了多种分布式解决方案
RestTemplate 和 RPC 区别？
    1.RestTemplate采用HTTP协议,基于TCP协议,消息封装比较臃肿,发送速度慢.
    2.RPC基于Socket,速度快效率高,典型代表Dubbo、WebSocket、ES集群间调用
常用RPC远程调用框架有哪些？
    1.httpclient   2.GRPC   3.dubbo   4.openFeign
RPC实现原理？
    1.采用TCP建立通讯-->通过IP+端口进行服务寻址-->对参数进行序列化进行网络传输-->收到后反序列化得到参数进行服务调用做出响应(代理增加响应发送)
微服务之间如何独立通讯的?
    同步通讯：Dubbo采用RPC、SpringCloud采用HTTP
    异步通讯：采用消息队列
什么是RESTFul API?
    就是REST风格的API,跟编程语言无关,采用HTTP协议,通过URL即可进行远程调用
--------------------------------------------------------------------------------------------------------
版本选型：
SpringBoot：
    截至2023年3月,最新版本(3.0.4)
SpringCloud：
    截至2023年3月,最新版本(2022.0.1)版本,之前版本是字母开头命名,现在用年份开头命名
注意：
    选用Cloud后需要去官网查看和SpringBoot的依赖关系,目前 (2022.0.X) 支持 SpringBoot(3.0.X)
官网：
    Maven坐标：https://mvnrepository.com/
    SpringCloud下层依赖版本：https://start.spring.io/actuator/info
技术选型 //todo
Eureka 2.X版本已经停止维护,用什么替换？
    1.ZK
    2.Consul 优点：1.基于Raft协议,比较简洁  2.同时支持HTTP和DNS协议,支持跨数据中心WAN集群  3.跨平台,支持 windows、Linux、Mac
    3.Nacos
Ribbon 用什么替换？
    Spring cloud目前自己还在用,后续会通过 SpringCloud LoadBalance 替代
Feign 进入维护
Hystrix,进入维护 用什么替换？
    SpringCloud
--------------------------------------------------------------------------------------------------------
当前笔记依赖版本：SpringCloud H版 SpringBoot2.2.2

Eureka 是什么？
    Eureka 是分布式服务注册中心,提供了服务治理和服务发现等功能
Eureka 服务治理是什么？ //todo 2023.04.09
    服务注册中心：提供注册和发现功能
    服务提供者：提供服务的应用会将自身注册到注册中心
    服务消费者：根据注册中心进行服务发现,进行远程调用
什么是服务续约？
    服务提供者通过配置指定心跳时间(默认30s),心跳来维持注册中心保存服务,防止被注册中心删除
什么是服务下线？
    当服务关闭的时候,会发送Rest请求给注册中心,注册中心收到后删除服务,并广播给所有消费者
什么是失效剔除？
    当服务发生异常时(如网络延迟),注册中心如果超过最大配置时间(默认90s)没收到心跳会将服务设置为失效服务,失效服务会被定时清理线程(默认60s)删除
Eureka 自我保护机制
    防止网络阻塞导致服务被删除,如果30s没收到客户端心跳,Eureka并不会立刻清理客户端,依旧对该服务进行保留,如果丢失三次心跳则进行删除

ZK //todo 2023.04.09
Zookeeper 做注册中心,生成临时节点还是持久节点？ 临时
Eureka 和 Zookeeper 区别？
    1

Consul 是什么？
    Consul 是分布式服务发现和配置管理系统,基于GO语言开发,提供了 服务治理、服务发现、配置中心、消息总线等功能
Consul 命令？
    启动命令：consul agent -dev
    页面访问：http://localhost:8500

CAP理论：
    一致性(Consistency):所有节点访问的数据一致
    高可用性(Availability)：节点出现异常其他节点提供服务,保证可用性
    分区容错性(Partition tolerance)：允许出现分区导致数据不一致
    注：在分布式系统中,CAP不可同时满足,多节点联通情况下,肯定会出现断开连接的情况,断开时一致性和高可用性就不能同时满足
        CA：单机操作,满足一致性和高可用性系统,但是违背了分布式多节点的初衷
        CP：满足一致性和分区容错性,如金融行业的支付流程
        AP：满足高可用性和分区容错性,如电商,互联网业务处理
四个注册中心的区别：
    Eureka:Java语言编写,实现高可用性和分区容错性,支持HTTP协议,提供WEB界面管理
    zookeeper:Java语言编写,实现一致性和分区容错性
    Consul：Go语言编写,实现一致性和分区容错性,支持HTTP、DNS协议,提供WEB界面管理
    Nacos: AP和CP可以切换,底层融合Ribbon实现负载均衡,支持HTTP、DNS、TCP协议,提供WEB界面管理,并且可以和Rubbo、k8s整合


Ribbon 是什么？ //todo 2023.04.15
    主要提供客户端 负载均衡(Load Balance) +  远程调用(RestTemplate) 并提供了超时、重试等配置项
负载均衡有哪些方式？
    Nginx服务器负载均衡:客户端将请求发送给Nginx,Nginx实现请求转发,从而实现负载均衡
    Ribbon客户端负载均衡：在调用微服务接口时,通过注册中心获取对应服务节点,通过负载均衡算法实现负载均衡
        1.先选择 注册中心集群中负载少的进行节点查询   2.找到所有节点根据负载均衡算法选择要使用的具体节点进行远程调用
负载均衡算法有哪些？ 如何切换？在配置类重新注入IRule的Bean然后创建其他算法
    1.轮询算法(RoundRobinRule):默认算法,通过记录请求次数计算服务节点
    2.随机算法(RandomRuleO)
    3.重试算法(RetryRule):先按照轮询,服务调用失败选择可用服务重试
    4.响应权重(WeightedResponseTimeRule)：对响应时间加权重,响应速度越快,权重越大,越容易被选择
    5.过滤选择(BestAvailableRule):先过滤掉熔断的服务,然后选择一个负载低的调用
负载均衡算法如何替换？
    官方提示,修改负载算法的配置类不能放到 @ComponentScan 所扫描的包及子包下,否则所有Ribbon客户端算法都会替换,达不到特殊替换目的
    1.在非扫描子包下创建配置类,修改使用算法
    2.在主启动类上 @RibbonClient(name = payment-service,configuration = 配置类) 指明哪个服务需要使用此算法,其他服务如果没配默认使用轮询


Feign 是什么？
    Feign是SpringCloud组件中一个轻量级RestFul的HTTP客户端,内置了Ribbon做负载均衡,使用注解就可以调用注册中心里的服务
OpenFeign 是什么？
    在Feign基础上支持了SpringMVC注解,OpenFeign的@FeignClient可以解析@RequestMapping注解下的接口,并通过动态代理产生实现类,实现负载均衡调用
OpenFeign 超时时间问题？
    默认1s超时,如果服务端没处理完毕会报错,可通过配置指定 连接超时时间 和 业务执行超时时间
        1.连接超时时间：ConnectTimeout
        2.执行超时时间：ReadTimeout
OpenFeign 日志打印功能？
    通过日志了解 OpenFeign 中HTTP请求的细节,对接口调用进行监控和输出
    日志级别：
        1.默认(NONE):不显示任何日志
        2.BASIC:仅记录方法URL、响应状态码、执行时间
        3.HEADERS：在上述基础上增加记录请求头和响应头
        4.FULL：在上述基础上增加请求和响应的Body信息


Hystrix 的作用？
    主要通过服务降级、服务熔断、服务限流方式防止雪崩
什么是服务雪崩？
    当多个服务链路调用时,如果一个服务不可用或响应时间过长,会导致调用方超时重试一直调用,请求一直堆积导致Down机,连锁效应使所有服务Down机导致雪崩
    服务雪崩的原因？
        1.访问量突然变大,服务器负载不过来导致连锁崩溃
        2.程序BUG导致服务不可用,或者运行缓慢造成流量堆积
        3.缓存击穿,导致所有流量打到服务上导致连锁Down机
什么是服务降级 Fallback？
    当服务运行报错,超时等情况发生时,返回友好提示,防止客户端一直重试造成请求堆积导致雪崩
    什么时候会执行降级方法？
        1.客户端指定超时时间,服务器没有响应,执行降级方法
        2.服务发送异常,执行降级方法
        3.服务被熔断,执行降级方法
如何指定一个调用的超时时间？
    在方法上增加@HystrixCommand注解,里面增加HystrixProperty设置超时时间. 如果需要全局配置可以在配置文件设置Hystrix.Command中的超时参数
什么是服务熔断 Break？
    当服务出现异常或响应时间太长时进行降级,降级次数超过一定阈值,熔断该服务调用,当检测到该节点正常时恢复链路调用
如何配置服务熔断？默认10s内20次请求,当失败率超过一半时熔断
    在配置中指定请求次数和失败率,当失败率达到阈值熔断服务,根据指定时间恢复成半熔断状态,当发现服务正常时关闭熔断,恢复服务调用
Hystrix 工作流程
    1.先查看服务响应是否存在缓存,如果存在缓存直接返回
    2.如果没有缓存,判断该服务是否被熔断,如果被熔断直接调用降级方法
    3.如果没有被熔断查看线程池是否被占满,如果沾满调用降级方法
    4.调用服务看是否报错或响应时间过长,调用降级方法
    5.如果都没问题响应正常结果,如果调用降级方法后续判断是否到达熔断阈值执行熔断操作
    6.熔断后到达指定周期判断服务是否正常可用,如果正常关闭熔断
Hystrix Dashboard了解吗？
    1

什么是服务限流 FlawLimit？
    秒杀高并发等操作,严禁一窝蜂过来拥挤,大家排队，一秒N个有序进行
JMeTer压力测试


Zuul服务网关
    对API进行过滤,转发到对应的微服务节点上
为什么选择 gateway而不选择Zuul
    1.Zuul已经进入维护阶段并且采用阻塞IO,性能不如gateway高
    2.gateway内部集成了Hystrix(限流、熔断、降低)和服务发现等的功能
    3.可以对路由指定
Gateway 核心功能？
    1.路由route
        基于异步非阻塞模型开发的底层使用Netty,对API请求通过断言匹配,转发到对应节点,并在转发前后增加过滤器,实现权限控制、熔断、限流、日志等功能
    2.断言predicate
        After：在什么时间之后生效
        Before：在什么时间之前生效
        Between：在什么时间之中生效
        Cookie：cookie必须携带某个key、value
        Header：头中携带什么参数名，必须符合什么正则表达式
        Method：get  post
        Query：必须携带的参数名称, 正则表达式规定参数的值
    3.过滤器filter：在请求前后进行过滤
        自定义过滤器：实现import GlobalFilter,Order


分布式配置中心(SpringCloud Config)
    随着服务节点的增加,重复的配置文件越来越多,引入config来提供一套集中的配置来解决配置重复的问题
Config如何解决配置重复？
    1.configServer：一般在Git或SVN上创建一份公共配置
    2.configClient：在运行阶段拉取Git或SVN服务器上的配置,加载到本地
        通过bootstrap.xml获取 configServer加载好的配置文件  bootstrap.xml是系统级配置文件。优先级高
        application是用户级的
分布式配置中心的优势？
    1.集中管理配置文件,发生变化时无需重启服务即可感知到变化并拉取最新配置
    2.不同环境不同配置,通过configClient指定拉取对应环境的配置
    3.将配置以接口形式暴露
分布式配置中心存在问题？
    1.github服务器修改配置文件,configServer可以立马读取到,但是configClient需要重启才能读取到
    解决方案：当发生变更时发送Post请求刷新配置,避免重启
    缺点：虽然可以脚本批量修改,但是还是比较麻烦

消息总线(BUS)：
    通过整合消息中间件实现配置自动刷新,简化运维操作。 目前只支持：RabbitMQ和kafka
设计思想：
    1.通知一个客户端刷新,从而刷新所有客户端,打破服务的单一性和平等性,一般不使用
    2.通知一个服务器刷新,从而刷新所有客户端,推荐使用
        当github配置文件修改时,只需要发送一个Post请求到服务器即可实现客户端自动刷新,也可以通过参数控制部分客户端更新


消息驱动：Stream
     如果系统中存在两种消息中间件,屏蔽底层消息中间件的差异,降低切换成本,统一消息的编程模型

分布式链路跟踪：
     当微服务系统越来越多,各模块调用链路越来越长,就需要引入链路跟踪,对服务进行监控,方便快速定位响应时间长或出现异常的服务
常用的分布式链路跟踪？
    1.SpringCloud Sleuth + Zipkin
    2.阿里的鹰眼(EagleEye)
    3.SkyWalking
    4.Pinpoint
    上述技术核心思路？
        第一个收到请求的服务会生成一个全局【traceId】和【spanId】,并随着链路传递到下游系统,后续服务对【spanId】进行维护,方便堆栈排序
        当发生异常时,收集所有服务日志查询【traceId】链路,根据【spanId】进行调用堆栈排序
    可以解决什么问题？
        1.通过链路恢复可以快速定位故障,发现服务调用时间长可以及时进行优化
        2.通过标签信息可以分析 服务不同节点的流量,实现流量预估,对节点进行精准扩容
    分布式链路跟踪系统如何选择？
        Pinpoint界面UI好,但是性能和扩展性比较差
        采用SkyWalking比较多,采用字节码增强,不需要修改业务代码。并且探针支持语言比较全,并且性能高
什么是探针？
    作用就是收集数据,根据不同语言有不同实现,像JAVA一般通过字节码植入或拦截,通过HTTP或PRC方式发送到平台后端
什么是平台后端？
    用于数据聚合,数据分析,将服务发来的日志数据聚合,提供后续分析

-------------------------------------------------------------------------------------------------------------
Nacos(8848)服务注册中心、服务配置+BUS总线
如何实现服务配置+BUG总线？
    服务启动时,通过bootstrap拉取Nacos服务地址的公共配置,然后读取application封装自身其他配置
    优势：当Nacos配置发送变动,客户端会自动刷新,不需要想BUG一样调用Post实现动态刷新
Nacos中公共配置文件命名规范？
    ${prefix}-${spring.profile-active}.${file-extension} 采用前述方式命名
    1.prefix：默认实例名称[spring.application.name],也可以修改前缀【spring.cloud.nacos.cofig.prefix】
    2.spring.profile-active：当前读取环境【dev、test】
    3.file-extension：文件格式,目前只支持【yml、properties】
Nacos如何进行多项目分类配置？
    namespace（默认公共的为public） + group（默认Default_group） + dataID 进行多项目、多环境区分
    1.namespace：用于区分部署环境,默认采用Public
    2.groupID+dataID：逻辑上区分两个目标对象  默认集群(cluster)也是default
    好处：
        1.当我们部署异地多活时,可以通过组进行异地区分,服务在同一个组中调用可以降低网络延迟
        2.通过namespace区分多项目,实现隔离
Nacos集群和持久化配置：
    自身携带嵌入式数据库 derby：
    问题：集群模式下多个默认配置存放在多个内置的数据库中,数据一致性存在问题
    解决方案：采用Mysql外部存储来支持集群的部署,目前只支持mysql的存储
    切换方案：1.Nacos配置中包含[建库建表]SQL脚本  2.修改Nacos配置文件【application.properties】切换 mysql数据源


Sentinel
    分布式中提供的限流、熔断、降级、监控等功能,通过jar包即可启动控制台,不需要像 hystrix 自己配置监控模块运行
Sentinel 如何启动控制台
    1.下载Sentinel-dashboard.jar包到本地,通过java -jar启动,注意：默认采用8080端口、用户名密码都是Sentinel
Sentinel 限流规则
    资源名：唯一名称、默认请求路径
    针对来源：可以通过配置指定哪个服务调用时进行限流,默认default不区分来源
    阈值类型：1.QPS(每秒请求数量)  2.线程数(当调用API的线程数到达阈值限流)
    是否集群：不需要集群
    流量控制：
        1.直接(API达到限流条件,直接限流)
        2.关联(当关联的资源达到阈值,则限流自己)   场景：支付接口处理不过来、对订单接口进行限流
        3.链路(针对某一链路进行限流)
    流量效果：
        1.快速失败(直接失败抛异常)
        2.预热/冷启动(Warm UP)：冷因子(3).经过一段时间才将QPS提升到阈值  场景：秒杀系统开启瞬间可能导致系统崩溃,经过预热限流慢慢控制流量进来
        3.排队等待：按照先后顺序进行处理,设置超时时间,超过响应失败
Sentinel 熔断降级规则.
    熔断降级会根据调用资源异常情况、超时情况进行判断,到达阈值后降级快速失败,防止雪崩,在接下来时间窗口期会熔断,窗口期结束恢复服务【没有hystrix 半开模式】
    资源名：唯一名称、默认请求路径
    降级策略
        1.平均响应时间(RT): QPS大于5并且平均响应时间超过阈值发生降级,时间窗口内熔断,窗口期结束恢复服务
        2.异常比例：QPS大于5并且异常比例超过阈值发生降级,时间窗口内熔断,窗口期结束恢复服务
        3.异常数：每分钟异常数超过阈值发生降级,时间窗口内熔断,窗口期结束恢复服务
Sentinel 热点规则限流
    统计一段时间内经常访问的数据,对该热点数据进行限流配置,通过@SentinelResource配置降级方法
    资源名：唯一名称、默认请求路径
    参数个数：指定第几个参数进行先流规则限制
    阈值配置：指定多长时间内阈值多少次
    额外配置项：指定参数值等于多少的时候配置额外的限流方式,进行区分值限流
Sentinel 系统规则配置
    通过配置CPU、QPS、线程数、平均响应时间进行阈值管理,当超过阈值后整个系统不可用
@SentinelResource  注意：不支持private方法
    value：指定对应资源名(必填)
    blockHandClass：执行降级方法所在类
    blockHandler：指定降级方法名
    fallback：业务异常降级方法名
    ignoreException：忽略部分异常,返回原样结果
Sentinel 整合ribbon、openFeign、fallback


多台服务器接收到相同的请求怎么处理?如何保证幂等性？为什么会出现请求重复？
    当页面刷新、后退都会产生重复请求,一般情况下会禁用浏览器刷新和后退按钮
    1.前端限制频率,防止按钮重复点击
    2.增加防重日志表,通过唯一ID查询,如果存在舍弃请求
    3.通过分布式锁,如果获取锁失败舍弃请求
    4.通过数据库状态判断,例如退款时要判断数据库状态为已下单,重复请求也不会重复退款
怎么做接口限流？
    1.分布式架构采用SpringCloud使用hystrix    2.如果使用阿里巴巴采用Sentinel     3.采用中间件：消息队列    4.代理层Nginx限流
    限流底层实现方式？
        1.计数法：对分钟/秒钟内的请求进行累加,到达指定阈值进行降级处理
        2.滑动窗口法：将一个时间周期拆分成多个小周期,分别采用计数法统计,随着时间推移慢慢剔除过期时间的窗口,统计时通过当前时间向前查询窗口进行计算
        3.漏桶算法：创建一个固定大小的桶,控制流速进行处理
        4.令牌桶算法：创建一个固定大小令牌桶,请求先获取令牌,获取成功执行,获取失败剔除。  优势：可以控制每次生成令牌个数,控制流速
        sentinel的预热限流效果就是通过令牌桶实现,控制流量接入缓慢增加,防止瞬间压入大量请求导致系统崩溃
熔断和降级的实现原理？
    通过try catch对异常,超时进行通过,当发生异常或超时进行降级,当失败率超过一定阈值发送熔断,到达一定时间窗口恢复接口调用
QPS、TPS、RT、吞吐量 是什么？
    QPS(Queries Per Second)：每秒钟请求数量
    TPS(Transactions Per Second):每秒钟处理的事务个数,注意：访问页面会请求两次服务器,则QPS是2,TPS是1  关系QPS>=TPS
    RT(Response-time):响应时间,请求到响应结果花费的总时间
    并发数：系统能同时处理请求的数量,也反映服务器的负载能力
    吞吐量：请求对CPU销毁越低,则系统吞吐量越高

解决分布式事务的几种方案
    1.阿里的Seata(AT模式)：无侵入的分布式事务解决方案,保证强一致性
        1.一阶段：Seata拦截业务SQL,对事务执行前后的数据备份,生成行锁,全部在一个事务中完成,保证原子性
        2.二阶段提交：二阶段如果是提交,删除对应行锁和备份数据
        3.二阶段回滚：二阶段如果是回滚,先判断修改后备份数据是否一致,如果不一致说明出现脏数据需要人工处理,如果一致通过修改前备份数据做回滚
        优点：一阶段和二阶段都是由Seata框架完成的,我们只需要写SQL就能接入分布式事务,对业务无侵入
    2.消息队列,保证最终一致性(TCC) todo 消息队列和TCC一样吗
        业务代码中try进行判断事务提交(Confirm)还是回滚(Cancel)
        优点：整个过程基本没有锁,性能高   缺点：侵入性比较强,需要我们自己实现事务逻辑
    技术选型：如果对数据一致性要求较高,比如一些资金交易采用Seata,如果对数据一致性要求不高可以采用消息队列,失败重试等处理
分布式事务相关提交协议
    2PC提交协议：参与事务的节点将成功失败结果响应给协调者,协调者根据所有节点的结果决定提交还是回滚
        1.准备阶段(Prepare):协调者发送消息给参与节点,参与节点根据自身执行结果返回同意或者中止,并会在自己节点记录redo和undo 日志
        2.提交阶段(Commit):如果协调者收到了中止或超时,会给每个节点发送回滚(Rollback)消息,否则发送commit,每个节点处理完毕释放所占用锁
    2PC缺点：
        1.同步阻塞问题：所有参与节点都是阻塞事务,当参与者占用公共资源时,其他节点访问需要等待节点释放锁
        2.单点故障：如果协调者出现故障,会导致所有参与者无法释放锁
        3.数据不一致：当提交阶段出现网络分区可能导致部分节点收不到提交请求,部分提交导致数据不一致
        4.二阶段无法解决的问题：协调者发出commit之后宕机,收到commit的节点也全部宕机,即使重新选举协调者,该事务状态依然没办法确认是提交还是未提交
    3PC提交协议：
        1.CanCommit阶段：协调者向所有参与者发送commit请求,参与者可以提交则返回Yes,否则返回No
        2.PreCommit阶段：当所有响应都是yes时,协调者会给所有参与者发送预提交请求,参与者执行事务操作,记录redo和undo日志,成功执行返回ACK确认
        3.doCommit阶段：当所有参与者都响应成功ACK时,发送doCommit正式提交释放锁资源,如果超时或响应存在NO的请求,给参与者发送中断操作进行回滚
    区别：
        1.3PC引入超时机制,如果协调者一定时间内没收到响应会进行中断操作
        2.3PC增加了一层CanCommit校验,如果不能执行则不会执行事务,相对比2PC的直接记录redo和undo来说减少资源占用快速响应失败

Seata的三大角色
    1.TC(Transaction Coordinator)事务协调者:维护全局或分支事务状态,实现全局事务的提交或回滚
    2.TM(Transaction Manager)事务管理器【发起方】:定义全局事务范围,开始全局事务、提交、回滚全局事务
    3.RM(Resource Manager)资源管理器:管理分支事务处理的资源,与TC协调注册分支事务和报告分支事务状态,并驱动提交或回滚分支事务
    处理流程：
        1.事务发起方向协调者申请一个全局事务,协调者生成一个全局事务ID放到 ThreadLocal 中
        2.Seata数据源会代理发起方和参与方数据源,将前置镜像和后置镜像写入undo中,方便后续回滚使用
        3.发起方获取全局事务ID,改写Feign请求头将全局事务ID传给参与方
        4.参与方解析出事务ID后存入ThreadLocal,并将该本地事务ID注册到全局事务中
        5.如果发生没有异常,发起方通知协调者,协调者通知所有参与分支,通过全局事务ID和本地事务ID删除undo_log日志
        5.如果发生异常,发起方通知协调者,协调者通知所有参与分支,通过undo_log日志生成逆向SQL执行,然后删除undo日志完成回滚
    优点：1.带入侵入性小   2.通过全局锁实现读写隔离
    缺点：1.性能损耗比较高(1.解析SQL查询对应数据  2.备份修改前数据  3.备份修改后数据  4.写入undo  5.写入redo),粗略估计会增加5倍响应时间
         2.性价比不高,按照28比例相当于为了解决20%的回滚问题将所有SQL的性能都降低
         3.全局锁,虽然可以实现读写隔离但是性能不高,并且增加了死锁的概率












