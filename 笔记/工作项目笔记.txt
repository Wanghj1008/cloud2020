SSO单点登录升级
    核心原理：一级域名共享cookie,二级域名共享Session。 将所有系统的登录抽取到认证中心
    处理流程：
        1.浏览器访问A系统,将用户重定向到认证中心的登录页,并携带自身URL(后续认证中心重定向使用)
        2.认证中心登录成功后将cookie和session放入Redis缓存,重定向会A系统对应的URL
        3.当浏览器访问B系统时,因为一级域名共享cookie所以会拿 cookie中ticket 去访问B系统
        4.B系统查询Redis中保存的Session信息,查询成功完成登录,如果值为空重定向到认证系统登录页,并携带URL

OAuth2.0单点登录
    核心原理：采用JWT实现令牌生成和验证
    处理流程：
        1.用户点击第三方授权,会跳转到第三方登录页面,登录成功后会响应一个Token
        2.用户下次访问携带token,服务器验证通过后允许访问
    OAuth2.0常用于第三方授权来访问资源。

JWT实现登录认证
    1.用户登录后,服务器生成一个Token响应给客户端
    2.客户端将token保存到全局缓存或cookie中,后续访问携带token
    3.服务器检验token有效,允许访问

JWT和Session方式区别？
    1.JWT保存在客户端,分布式下只需要验证是否有效即可。SessionId保存在服务器,分布式情况下需要共享session
    2.JWT采用base64加密,安全性低,不建议存储敏感数据。 Session存储在服务器端,相对比安全
    3.JWT经过编码后很长,可能导致Head头比body体大，而SessionId只是一个字符串。所以性能JWT要慢一些
    4.JWT需要搭配Redis来设置过期时间

JDK升级
    1.升级完毕后和其他服务通讯异常,而且错误是在HTTPS的TLS层,经过排查因为JDK6(TLS1.0)升级JDK8(TLS1.2)因为TLS协议不一致导致报错
        解决方案： 1.升级本地JDK版本  2.在JVM里面配置向下兼容协议   3.修改代码SSLSocket中配置TLS向下兼容(采用)
        延申发现JDK升级对 【某些不安全算法】修改了长度限制,导致部分加解密不可用,其中就有可能导致证书无法解密？
        解决方案： 因为这个不好测试,而且属于运行时才会出现的BUG,所以直接修改JDK8 JRE目录中的配置的参数和旧JDK一致,预防此问题
    2.JDK8升级后sun包被弃用,代码中有使用导致报错,后来具体查看发现并未实际使用,把相关代码删掉了
        回想如果使用了的话,首先了解实现了什么功能,然后查询有没有替换方式,如果实在没办法只能将sun包手动引入,但是一般不太推荐这样做
    3.调整JAR包启动的指令,JDK8取消永久代的概念,删除对应JVM参数,因为元空间会自动增长所以不需要配置
    4.考虑：垃圾回收器是否需要切换(6-8默认Parallel)
Memcached切换Redis
    为什么要切换？ 1.因为上云要求  2.redis支持存储类型多样并且提供了持久化和高可用机制   3.避免服务启动被【击穿、穿透、雪崩导致数据库宕机】
    切换流程：
        1.删除 memcached 相关配置
        2.引入Redis【1.redis服务器配置  2.配置类增加修改序列化方式】
            1.value采用Json序列化   key采用String序列化       默认是JDK序列化,可能出现乱码
        3.将编译报错的项切换到 Redis 中
    如果生产环境在线切换需要考虑什么？
        建议参考Redis分库分表处理,先采用双写,然后读的时候先读Redis然后再读MedCached缓存进行处理,模拟运行一段时间如果不出问题将Memcached剔除
SSM升级SpringBoot
    1.引入SpringBoot相关依赖,将SSM的部分配置迁移
    2.将web.xml中的 监听器、过滤器、拦截器切换到配置类
        webapp目录对应SpringBoot中static目录,templates中存放一些错误页面
    3.解决依赖冲突

Maven的属性配置
    1.compile：默认,使依赖包参与 编译、测试、运行 阶段,打包会包含此依赖
    2.provided：仅参与项目 编译、测试阶段  例如：Servlet API,因为Tomcat容器内部会提供
        A-->B-->C 如果C是provided,C将参与B的编译、测试阶段,但是C不会传递给A,如果A需要则自行引入
    3.runtime：不参与编译,只参与测试运行阶段
    4.test：仅参与测试阶段 例如：Junit
    5.import：一般都是父工程在<dependencyManagement> 中指定依赖版本,后续子工程不需要版本号

什么是依赖冲突？
    项目升级过程中引入新的依赖,出现间接依赖版本不一致,导致依赖关系图出现红色冲突,由于Maven仲裁结果不满足运行需求进而导致运行报错
Maven依赖仲裁机制？
    1.路径近原则：如果POM文件中指定了依赖版本,就算其他依赖间接引入也不会使用
    2.先声明原则：如果POM文件中无指定,其他依赖都间接引入某个依赖,选择时按照POM文件中依赖顺序使用
    * 建议在POM中引入,通过<properties>指定版本  优势：方便管理查看,间接依赖引入需要通过依赖图查看版本,相对繁琐
如何解决依赖冲突？
    1.依赖关系图变红,可以通过Maven依赖工具查看冲突,手动配置<properties>指定版本解决,避免Maven自动仲裁
    2.Maven仲裁导致运行失败：
        1.通过<exclusions>标签来排除依赖
        2.升降依赖版本：排除后还是出现未找到类、未找到方法等报错,通过升级版本来处理
        3.查看对应方法想要完成功能,查询资料高版本有没有同等替代,或者考虑自己实现
        4.阿里中间件潘多拉：Pandora,通过隔离技术构建出容器,实现依赖隔离,在应用使用时作为参数传入。
            后续升级 Pandora-boot 可以在IDEA中直接启动,方便调试

监听器、过滤器、拦截器
    1.过滤器Filter是Servlet中定义的,可以对请求进行拦截,过滤字符编码,判断是否有权访问！
    2.拦截器Intercepted 是Spring中的定义,动态代理就是一种实现,在方法执行前后执行简单逻辑,例如PageHelper
    3.监听器listener 是Servlet中定义的,可以的作用域创建、修改、销毁进行监听,执行相应回调函数
过滤器和拦截器区别
    过滤器基于函数回调,不能获取IOC中Bean
    拦截器基于反射实现的,可以获取IOC容器中的Bean,调用业务逻辑.在Spring架构中优先使用拦截器
    请求流程：请求-->进入Tomcat容器-->过滤器-->进入Servlet容器(Servlet的请求分发)-->拦截器-->controller


数据库坏表导致流程切断 -》被拷贝
webService syslog  WebSocket