服务注册与发现：
Eureka 服务注册中心          Java语言    Ap  A高可用P:(分区容错性)                     对外暴露接口：HTTP
zookeeper 服务注册中心没看   Java语言    CP  C数据一致P:(分区容错性)                                客户端
Consul  服务注册中心         Go语言      Cp  C数据一致P:(分区容错性)                                HTTP/DNS
服务健康检查上述三种都可以支持   都集成了SpringCloClod    redis CP  Mysql CA
CAP理论的核心是：一个分布式系统不可能同时满足一致性，可用性和分区容错性这三个需求
CA：单点集群  满足一致性 可用性系统 通常可扩展性不强大
CP：满足一致性和分区容错性  性能不高
AP：满足可用性和分区容错性   通常对一致性要求低一些
discovery  服务发现  在8001
@LoadBalanced     开启负载均衡注解  在80



 Ribbon
 Ribbon就是------------》》》(Load Balance负载均衡)  +  (RestTemplate调用)：
将用户请求平摊的分配多个服务器上，达到系统HA(高可用性)  常见软件：Nginx 、LVS、 硬件F5
Nginx是服务器端的负载均衡(集中式)     分布式负载均衡
     ：客户端所有请求都交给Nginx。Nginx实现转发请求。既负载均衡是由服务器实现的
Ribbon是客户端的负载均衡 (进程内)      集群式负载均衡
     ：在调用微服务接口时候,会在注册中心上获取注册信息服务列表,之后缓存到JVM本地。从而在本地实现RPC远程调用技术
Ribbon工作分成两步:
第一步：先选择EurekaServer，它优先选择同一区域内负载比较少的server
第二步：根据用户指定策略，在server的服务列表中选择一个服务地址
以下七种算法 都是IRule接口的实现
com.netflix.loadbalancer.RoundRobinRule   轮询(默认算法)    手写轮询--  Order80
    原理(rest请求第几次请求数 % 服务器集群总数 = 实际调用服务器位置下标 每次服务重启 rest请求数更新为1)
com.netflix.loadbalancer.RandomRuleO      随机
com.netflix.loadbalancer.RetryRule        先按照轮询策略 如果服务获取失败会在指定时间内进行重试，获取可用服务
WeightedResponseTimeRule                  响应时间加权重   对轮询的扩展，响应时间越快 权重越大 越容易被选择
BestAvailableRule                         会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务
AvailabilityFilteringRule                 先过滤掉故障实例然后选择并发较小的实例
ZoneAvoidanceRule                         默认规则，复合判断server所在区域的性能和server的可用性   选择服务器


Feign：
可以设置超时时间  默认1s ribbon:
                            #指的是默认连接所用时间，适用于网络状态正常情况下，两端连接所用时间
                            ConnectTimeout: 5000
                            #指的是建立连接后从服务器读取到可用资源所用的时间
                            ReadTimeout: 5000
日志打印功能：可以通过配置来调整日志级别，从而了解Feign中Http请求的细节 就是对Feign接口的调用进行监控和输出
日志级别：
NONE：默认的，不显示任何日志
BASIC：仅记录请求方法，URL，响应状态码及执行时间
HEADERS：除了BASIC中定义的信息之外，还有请求和响应的头信息
FULL：除了HEADERS中定义的信息之外，还有请求和响应的正文及元数据


Hystrix断路器
断路器：
    本身是一种开关装置,某个服务发生故障，通过断路器故障监控，向调用方返回一个备选响应，
    而不是长时间等待或者抛出异常,保证调用方线程不被长时间不必要占用,从而避免雪崩

服务雪崩：多个微服务之间调用的时候，A调B B调C  B和C之间又调用E，访问量大的时候，如果E服务不可用或者响应时间过长，B和C超时或重试机制就会被执行
         新的调用不断累积产生大量的等待或者重试，慢慢B和C的CPU会被耗尽然后也down机，A会堆积对B、C调用 然后耗尽CPU宕机  这就是雪崩
雪崩原因：
          程序bug导致服务不可用，或者运行缓慢
          缓存击穿，导致调用全部访问某服务，导致down掉
          访问量的突然激增。
          硬件问题，这感觉只能说是点背了⊙︿⊙。
Hystrix:
    是一个用于处理分布式系统延迟和容错的开源库，在分布式调用中不可不免调用失败(超时或异常),Hystrix保证一个服务出现问题的情况下，不会导致整体雪崩

服务降级Fallback：  服务器忙，请稍后再试，不让客户等待的友好提示
            程序运行异常
            超时
            服务熔断触发服务降级
            线程池/信号量打满也会导致服务降级

超时导致服务器变慢(转圈)--超时不再等待   对方服务超时了，调用者不能一直卡死等待，必须又服务降级
出错(宕机或程序运行出错)--出错要兜底     对方服务down机了，调用者不能一直卡死等待，必须又服务降级
对方服务OK，调用者自己出故障或者有自我要求(自己的等待时间小于服务执行时间)，必须有服务降级
1）客户端服务降级  启动类注解@EnableHystrix（回路） 在方法上定义@(HystrixCommand)属性             服务器端运行报错或者超时都会降级
                  属性内定义FallbackMethod回调方法和CommandProperties属性(属性里面可以设置超时时间)
      注解：启动类@EnableHystrix(断路器)    中  包括---》@EnableCirCuitBreaker（回路）
2）上述改进：每一个方法都需要一个FallbackMethod降级方法，导致程序代码臃肿,所以可以在Controller类名上统一全局默认降级方法
             类名上加@@DefaultProperties(defaultFallback = "方法名")    在需要降级的方法上继续写@(HystrixCommand)属性
3）继续改进：上述方法可以实现代码臃肿，但是还是和其他业务类混淆起来了。所以提出一种新的降级方案，
             给每个service接口生成对应的实现类  在接口的FeignClient(多加一个fallback属性)值为实现类Class文件
服务熔断break：
    熔断是应对雪崩效应的一种微服务链路保护机制,当扇出链路的某个微服务不可用或响应时间太长,会进行服务降级,进而熔断该节点的调用,快速返回错误日志,当检测
    到该服务响应正常后,恢复该链路。相当于保险丝到达最大服务访问后,直接拒绝访问,拉闸限电,然后调用服务降级的方法返回友好提示
      @HystrixCommand(fallbackMethod = "paymentCircuitBreakerFallback",commandProperties = {
         @HystrixProperty(name = "circuitBreaker.enabled",value = "true"),  //是否开启断路器
         @HystrixProperty(name = "circuitBreaker.requestVolumeThreshold",value = "10"),  //请求次数(次数必须大于等于十次才能开启)
         @HystrixProperty(name = "circuitBreaker.sleepWindowInMilliseconds",value = "10000"), //时间窗口期(熔断后10s进入一次半熔断状态)
         @HystrixProperty(name = "circuitBreaker.errorThresholdPercentage",value = "60"), //失败率达到多少熔断
          })
1）熔断打开：请求不再进行调用当前服务,内部设置时钟一般为MTTR(窗口期),当打开时长到达窗口期进入半熔断状态
2）熔断关闭：熔断关闭不会对服务进行熔断
3）熔断半开：部分请求根据规则调用当前服务，如果请求成功且符合规则就会任务服务恢复正常,关闭熔断

服务限流FlawLimit： 秒杀高并发等操作,严禁一窝蜂过来拥挤,大家排队，一秒N个有序进行

Hystrix工作流程：1先看缓存,缓存有返回,没有判断是否开启熔断,开启直接降级,没开启判断是否线程池满了,满了降级,没满调用服务看是否报错或者超时,是降级
                则执行成功返回。。如果熔断开启的话会在一定的窗口期进入半熔断。

服务网关
Zuul服务网关(代理+路由+过滤三大功能)
    路由:将外部请求转发到具体的微服务实例上,是实现外部访问统一入口的基础
    过滤器：对请求处理过程进行干预，实现请求校验、服务聚合等功能的基础
    Zuul自身注册进Eureka，同时从Eureka中获取其他微服务消息，也既以后的访问微服务都是通过Zuul跳转后获得
gateway异步非阻塞模型上开发的
   动态路由：能够匹配任何请求属性   可以对路由指定Predicate(断言)和Filter(过滤器)
   集成Hystrix的断路器功能        请求限流功能
   集成SpringCloud服务发现功能
   易于编写的Predicate(断言)和Filter(过滤器)
   支持路径重写




















