虚拟机：就是一台虚拟的计算机   计算机上操作系统-》软件   操作系统是系统软件.qq软件是应用软件
    1.系统虚拟机：对物理计算机的仿真。VMware
    2.程序虚拟机：相当于应用。在操作系统上安装,代表JVM

sun公司的 hotspot 虚拟机  主学   还知道IBM的J9虚拟机。apache的 harmony
JVM：支持多语言混合编程。只需要关心如何编译成字节码文件即可
    一次编译到处运行。  java文件编译成二进制字节码文件。  可以在不同的操作系统JVM中解析运行
    1.自动内存管理
    2.自动垃圾回收
    3.数组下标越界检查   实现多态
    优点：降低内存泄漏风险
    缺点：弱化程序员处理OOm的经验
JVM-》JRE(JVM+基础类库)-》JDK(JRE+编译工具)-》开发JavaSE程序(IDEA+JDK)->开发JavaEE程序(IDE+JDK+应用服务器)
JRE是Java运行时环境：比JVM多出来一些java类库
JDK是Java开发工具包  集成了javac.exe、java.exe、jar.exe
--------------------------------------------------------------------------------------------------
JVM的生命周期：
  1.启动
    java虚拟机启动是通过引导类加载器创建一个初始类来完成的.这个类是由虚拟机的具体实现指定的
  2.执行：执行Java程序
    执行一个java程序的时候,真正执行的是一个Java虚拟器进程。   程序启动才执行,程序结束就停止
  3.退出
    1.程序结束正常退出
    2.遇到异常或者错误 终止
    3.操作系统错误  终止
    4.线程调用RunTime类或者System类的exit方法结束或者直接调用RunTime类halt方法终止线程
    5.JNI（JAVA native interface）:描述了用JNI加载或卸载虚拟机时,java虚拟器的退出情况
--------------------------------------------------------------------------------------------------
Java执行流程
  1.java文件通过前端编译器生成.class文件
     1.词法分析-》语法分析-》语言/抽象语法树-》语义分析-》注解抽象语法树-》字节码生成器
  2.经过Java虚拟机
     1.类加载器
     2.字节码校验器
     3.执行引擎                 高级语言翻译成机器指令的过程
        1.翻译字节码(解释运行)：将字节码文件编译成字节码指令
        2.JIT编译器(编译运行) ：将字节码指令翻译成机器指令。同时将反复执行的代码缓存起来。保证执行性能
     4.操作系统
JVM整体结构：
  上层
    1.类装载子系统(类加载器)字节码文件通过类加载器生成大的Class对象
  中层（运行时数据区 Runtime date Area）   其中方法区和堆是多个线程共享的,而Java栈,本地方法栈和pc寄存器是每个线程都有一份的
    1.方法区(method Area)元数据区:有可能造成OOM
    2.堆（heap）:有可能造成OOM
    3.Java栈(虚拟机栈):没有GC 有可能造成OOM
    4.本地方法栈：:有可能造成OOM
    5.程序计数器(PC寄存器)：没有OOM,没有GC
  下层
    1.执行引擎(计算机只执行机器指令,而字节码文件不等同于机器指令,执行引擎将字节码文件翻译成机器语言)
      1.解释器
      2.编译器(JIT编译器)
      3.垃圾回收器
    2.本地方法接口
    3.本地方法库

----------------------------------------------------------------------------------------
类加载区
插件jclasslib  java编译成class字节码文件。可以通过这个插件查看
    1.init  是类的字节码文件
    2.clinit 如果有静态代码块或者静态变量赋值就会自动生成
父类静态字段-》父类静态代码块-》子类静态字段-》子类静态代码块-》父类成员变量(非静态字段)-》父类非静态代码块-》父类构造器-》子类成员变量-》子类非静态代码块-》子类构造器
类加载器(类加载子系统)
    这四种加载器是包含关系。不是父子类继承的关系    ClassLoader是一个抽象类
 1.Bootstrap ClassLoader引导类加载器(启动类加载器)。C和C++编写,嵌套在JVM内部
    1.获取引导类加载器  ClassLoader BootStrapClassLoader = extClassLoader.getParent();  结果为null
    2.Java的核心类库(rt.jar,resource.jar)都是由引导类加载器加载的,只加载包名为java,javax,sun开头的类
    3.扩展类加载器和应用类加载器是由引导类加载器加载的
 2.Extension ClassLoader扩展类加载器。Java编写 ExtClassLoader
    1.获取扩展类加载器 ClassLoader extClassLoader = systemClassLoader.getParent();
    2.继承于ClassLoader。也属于自定义加载器。  父类加载器是启动类加载器
    3.加载的是jre/lib/ext目录下的文件
 3.System ClassLoader系统类加载器(应用类加载器)。Java编写    AppClassLoader
    1.获取系统类加载器  ClassLoader systemClassLoader = new getSystemClassLoader();
    2.用户自定义的类默认是由系统类加载器加载
    3.继承于ClassLoader。也属于自定义加载器。  父类加载器是扩展类加载器
 4.自定义类加载器
    1.什么场景下需要自定义加载器（为什么要自定义类加载器）？
        1.隔离加载类：避免重名类冲突
        2.修改类加载方式
        3.扩展加载源
        4.防止源码泄露
    2.如何创建自定义加载器？
        1.创建一个类继承ClassLoader类 覆盖findClass方法
        2.创建一个类继承URLClassLoader方法
 作用  ：将class字节码文件转换成Class对象
   1.类加载器负责加载class文件,class文件在文件开头有特定的文件标识  CAFEBABE魔术
   2.加载器只负责加载文件,是否可以运行由执行引擎决定
   3.加载类的信息存放于一块方法区的内存空间,除了类的信息外,方法区还会存放运行时常量池信息
 1.加载阶段(loading)
   1.通过一个类的全限定名获取定义此类的二进制字节流
   2.将这个字节流代表的静态存储结构转换为方法区的运行时数据结构
   3.在内存中生成一个CLASS对象。作为方法区这个类的各个数据的访问入口(通过对象访问具体方法)
 2.链接阶段（linking）  将 Java 类的二进制代码合并到 JVM 的运行状态之中的过程。 在链接之前，这个类必须被成功加载
   1.验证(Verify):
       1.确保Java类的二进制表示在结构上是完全正确的。 如果错误会抛出VerifyError
       2.主要包括四种验证：文件格式验证、元数据验证、字节码验证、符号引用验证
   2.准备(prepare):
       1.创建Java类中的静态域，并将这些域的值设为默认值。int(0) 引用类型(null) boolean（false）
       2.如果是final常量在编译的时候已经分配值了,所以这个阶段会显式初始化
   3.解析(resolve)
       1.确保当前类引用的其他类被正确地找到，该过程可能会触发其他类被加载。 符号引用
 3.初始化阶段(initial)
   1.Java类第一次被真正使用到的时候，JVM会进行该类的初始化操作。主要操作是执行静态代码块和初始化静态域。
   2.准备过程就是将静态变量分配默认值。而这个阶段会按照代码的顺序执行静态代码块和初始化静态变量。
双亲委派机制 ： Java虚拟机需要Java类的时候才加载成Class对象。加载方式是双亲委派机制。既把请求交给父类处理。任务委派模式
    1.如果一个类加载器收到加载类请求,并不会直接加载。而是向上委托给父类依次递归到启动类加载器
    2.如果父类加载器可以完成加载任务，就成功返回。如果如类加载器无法完成,交给子类尝试。依次递归
    优势：避免类的重读加载。   2.保护程序安全,防止API被篡改
    禁止自定义类使用引导类加载器加载。不然会报错。也即是不要使用引导类加载的路径。java,javax,sun
沙箱安全机制：
    就是对Java的源代码的一种保护机制。   自定义java.lang.String类 写一个main方法执行。报错没有main方法,因为加载的是rt.Jat包下的String类
在JVM中表示两个Class对象是否为同一个类的条件？
    1.类的完整类名必须一致。包括包名
    2.加载这个类的ClassLoader必须是一个
JVM必须知道一个类型是由启动类加载的还是用户类加载的,如果是用户类加载的,JVM会将类加载器的一个引用作为类型的一部分保存在方法区中
当解析一个类型到另一个类型引用的时候,JVM要保证这两个类型的加载器是相同的

Java程序对类的使用方式：主动使用和被动使用。
    区别：主动使用会初始化类。被动使用不会导致类初始化

----------------------------------------------------------------------------------------------------------------------
运行时数据区（RunTime date area）
内存：非常重要的系统资源,是硬盘和CPU的中间仓库及桥梁,承载着操作系统和应用程序的实时运行。
    JVM内存布局规定了Java在运行过程中内存的申请,分配,管理的策略,保证了JVM的高效运行,不同的JVM对内存的划分方式和管理机制存在差异
Java虚拟机定义的运行时数据区,其中一些会随着虚拟机(进程)启动而启动,虚拟机(进程)退出而销毁。比如 堆和堆外内存(永久代或元空间,代码缓存)
另一些则与线程一一对应，这些与线程对应的数据区域会随线程的开始和结束而创建和销毁。 比如：程序计数器(PC寄存器),栈,Java栈(虚拟机栈)
线程：
    1.JVM运行一个应用有多个线程并发执行
    2.Hotspot的虚拟机里每个线程和操作系统的本地线程直接映射.
    3.当Java线程准备好执行后,操作系统的本地线程也同时创建,java线程终止后本地线程也会回收
    4.操作系统负责所有线程的安排调度到任何一个可用的CPU上,一旦本地线程初始化成功,就会调用Java线程中的Run方法
    5.本地线程回收前决定JVM要不要终止。看当前线程是不是最后一个非守护线程
守护线程和普通线程
虚拟机里主要的后台程序线程
    1.虚拟机线程
    2.周期任务线程
    3.GC线程
    4.编译线程
    5.信号调度线程
---------------------------------------------------------------------------------------------
PC寄存器（程序计数器）PC Register
作用：    用来存储下一条指令的地址。由执行引擎读取下一条指令。解释器解析一条指令交给CPU
    1.占用空间最小,运行速度最快的内存区域。是线程私有的
    2.保存下一条指令地址。如果是Native方法计数器是空的(undefined)
    3.不存在内存溢出的区
使用PC寄存器存储字节码指令有什么用（为什么使用PC寄存器记录当前线程的执行地址）？
  并发执行多个线程。CPU需要不停切换各个线程,切换回来需要知道从哪开始。并且JVM解释器需要改变PC寄存器的值来确定下一条指令
PC寄存器为什么被设置为线程私有的？
  因为多个线程的话如果公用一个PC寄存器存储。A如果执行了3行,CPU切换到B则会直接从3开始,会产生问题。所以需要每个线程独有一份
---------------------------------------------------------------------------------------------------
栈是线程运行时需要的虚拟空间,堆是存储的单位
栈：每个线程运行需要的内存
栈帧：每个方法运行时需要的内存(参数、局部变量、返回地址 都需要占用内存)

Java栈(虚拟机栈)是什么？
  虚拟机栈是线程私有的.内部是以栈帧为单位保存.一个栈帧对应一个Java方法
栈的执行原理是什么？
  1.栈是先进后出,以栈帧为单位。虚拟机的操作指令只针对栈顶的方法. 执行引擎运行的字节码指令是针对当前栈帧操作的
    栈帧：是一块内存。存放方法的各种数据信息(参数、局部变量、返回地址)。当前执行的栈帧叫当前栈帧，不同栈帧不能相互访问,一个栈帧
    的返回结果会传递给上一个栈帧。           return  都会返回函数,导致栈帧弹出  异常
  栈帧内部结构： 1.局部变量表(local variables)本地变量表：
                   1.主要存储方法的参数和定义在方法体内的局部变量(这些数据类型包括8种基本数据类型,应用类型,redurnAddress)
                   2.局部变量表在栈帧内,栈帧在栈内,一个线程拥有一个栈,所以不存在数据安全问题。单线程操作
                   3.局部变量表的最大容量是在编译的时候就确定的。运行期不会改变
                   4.局部变量表中的局部变量只在当前方法有效.当方法结束局部变量表会随栈帧一起销毁
                   5.局部变量表基本存储单位是slot(槽)  是一个数值类型的一维数组。32位以内一个槽64位2个槽
                        1.如果占两位的访问拿起始位置索引。
                        2.如果是构造方法或者实例方法。会在开始多一个该对象的引用。this
                        3.slot是可以重复利用。如果局部变量失效新变量会占用局部变量空出来的位置
                2.操作数栈(operand stack)表达式栈： 后进先出
                   1.在方法执行过程中,根据字节码指令,在操作数栈里写入数据或提取(复制,交换,求和)数据
                3.动态链接(Dynamic linking):指向运行时常量池的方法引用：
                4.方法返回地址(return Address)正常或者异常退出的定义：
                5.一些附加信息
-------------------------------------------------------------------------------------------------------
本地方法栈： 本地方法运行所需要的内存就是本地方法栈
   本地方法：
      java有一些限制,不能直接跟操作系统底层打交道,所以需要用C或C++编写的本地方法来真正于底层操作系统打交道
   本地方法有哪些
     wait  notify  hasCode
------------------------------------------------------------------------------------------------------
堆和方法区是线程共享的区
堆：通过new关键字创建的对象都使用堆的内存
  特点：
    1.线程共享的,堆中对象都需要考虑线程安全的问题
    2.有垃圾回收机制  (不再使用的内存就会垃圾回收)
堆内存诊断
  1.jps工具
     查看当前系统中有哪些Java进程    直接在IDEA的Terminal命令窗口中 输入jps 可以返回进程号
  2.jmap工具
     查看堆内存占用情况     jmap -heap 进程号  查看堆内存
  3.jconsole工具
     图形界面的,多功能检测的工具,可以连续检测.  可以检测线程数量,CPU占用率,堆内存和加载类的数量   Terminal命令窗口jconsole
  4.jvisualvm  可视化虚拟机   于jconsole类似,但是有一个堆抓取工具可以将占用对的对象进行排序查看,以此来排查优化堆内存
--------------------------------------------------------------------------------------------------------
线程运行诊断
1.CPU占用过高
  top命令可以查看CPU占用  从而获取进程ID(PID),使用PS命令可以查询具体进程内所有线程id(TID)对cpu占用情况
  PS H -eo   (H打印线程的进程数)(打印感兴趣的信息 后面跟PID进程 TiD线程 %CPU cpu占用)
  jstack Pid 可以查看具体信息,将线程id转换成16进制,可以查看具体Java代码行数
2.程序一直没有结果
  jstack pid 查看具体信息,如果存在死锁下面会告诉存在死锁的两个线程及代码行数。
死锁原因：1线程锁住方法A然后sleep3s 再此期间2线程锁住方法B然后要访问方法A 所以需要等待,1线程sleep结束访问方法B 也需要等待
         相互若无外力 一直等待造成死锁
------------------------------------------------------------------------------------------------
方法区
  1.6内存结构 ：
    方法区占用JVM内存,使用的 PermGen(永久代)的实现。
      1.class(类的信息)
      2.classLoader(类加载器信息)
      3.运行时常量池 ：其中最重要的就是字符串常量池StringTable (hastable结构,不能扩容,初始没有遇到会增加字符串)
         String s1=“a"; String s2="b";  String s3="ab";  都是存放在字符串常量池中的
         String s4=s1 + s2;   s1,s2是变量可能被修改,所以在运行期间用Stringbuilder拼接
           相当于StringBuilder().append(s1).append(s2).toString();  new String("ab");堆中
         String s5="a"+"b"; javac在编译期间的优化,编译期间结果就是ab了 去常量池中寻找,没有就创建
  1.8内存结构
    方法区占用本地内存,使用 Metaspace(元空间)的实现
      1.class(类的信息)
      2.classLoader(类加载器信息)
      3.运行时常量池 其中StringTable被移到堆中
StringTable(字符串常量池)特性
  1.字符串加载延迟加载,并不是直接放入常量池中,而是第一次引用的时候才加入常量池,后续存在直接使用
  2.可以避免创建重复字符串  字符串变量拼接原理时Stringbuilder的append方法而字符串常量是在编译期优化
  3.可以使用 intern
     1.8尝试将字符串放入串池,如果有不放入,没有就放入并且返回串池中的对象
     1.6尝试将字符串放入串池,如果有不放入,没有就复制一份放入并且返回串池中的对象
  4.当堆内存紧张时,不用的字符串常量也会被垃圾回收
二进制字节码文件(类基本信息,常量池,类方法定义(包含虚拟机指令))  javap -v  *.class 反编译
  静态常量池：
     存放在class文件中,类似于一张表,虚拟机指令根据这张表找到要执行的类名,方法名,参数类型,参数值等信息
  运行时常量池
     将常量池中的类被加载时,他的常量池信息就会放到运行时常量池中,把里面的符号变成真实的内存地址

------------------------------------------------------------------------------------------------
JVM架构模型：
  1.基于栈式架构特点：
    1.涉及和实现更简单,适用于资源受限系统
    2.避开寄存器分配难题。使用零地址指令方式分配
    3.执行过程依赖于操作栈,指令集小,编译器更容易实现
    4.不需要硬件支持,可以执行更好,更好实现跨平台
    优点：跨平台性,指令集小
    缺点：指令多,频繁入栈出栈.执行性能比寄存器方式差
  2.基于寄存器架构特点
    1.典型的应用式X86二进制指令集
    2.指令集架构完全依赖于硬件,可移植性差
    3.性能优秀,执行更高效
    4.花费更少的指令去完成一个操作。一般是一地址指令,二地址指令和三地址指令。而基于栈的架构是零地址指令
  3. 总结
    1.优化跨平台设计。java的指令都是基于栈方式实现的
    2.不同的CPU架构不同,所以不能设计为寄存器的
-------------------------------




如果想要手写一个JVM虚拟机,主要考虑那些结构？   类加载器和执行引擎






































