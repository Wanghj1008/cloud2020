并发工具类
CountDownLatch(减法计数器)
   1.调用countDown方法 减一,当为零的时候 await方法继续执行   (王者荣耀加载游戏界面 开启十个线程分别加载,一个线程完毕调用一次-1 全部加载好进入游戏)
CyclicBarrier（同步屏障）
   CyclicBarrier可以用于多线程计算数据,先每个线程计算学生平均成绩,最后计算班级平均成绩
区别：
   1.CountDownLatch只能使用一次,而 CyclicBarrier 执行完会进行重置,可以重复使用
   2.CyclicBarrier某个线程中断,那么所有await的线程都无法使用, 而CountDownLatch一个线程中断只是一个await线程不能使用
   3.CountDownLatch使用的 AQS,操作的是AQS的state  而CyclicBarrier使用的ReentrantLock
Semaphore(信号量)
   1.同时访问线程的数量,可以用作限流控制 控制可访问线程数量,其他线程等待  (停车场例子)   acquire(取得)  release(释放)
Exchanger(交换者)
   1.用于线程间进行通信、数据交换  当两个线程都调用(交换点)exchange方法 就会进行数据交换,为了避免一方中断可以设置超时时间  避免一直等待
---------------------------------------------------------------------------------------------------------------
并发容器和框架
Fork/Join：分支合并   分而治之和工作窃取算法。
    1.首先将一个大任务拆分成多个小任务多个线程去执行,最后合并小任务的结果
    2.工作窃取：拆分成多个线程如果某个线程执行完不会等待其他线程而是会窃取其他线程任务继续执行,提高效率(维护的双端队列)
---------------------------------------------------------------------------------------------------------------
线程池： （池化技术）
什么是线程池？
   简单理解其实它就是一个管理线程的池子。
   好处：
      1.管理线程,避免了创建和销毁线程的资源消耗:线程其实也是一个对象,创建过程需要类加载,销毁需要GC垃圾回收.都需要消耗系统资源
      2.提高响应速度:如果直接从池子里拿和创建一个线程 来比较的话速度肯定快
      3.线程复用：线程用完，再放回池子，可以达到重复利用的效果，节省资源。
能说说工作中线程池的应用吗？
   1.首先发送验证码类似接口,可以通过线程池去发送,用户无需等待
   2.我们和第三方安管一些接口,我们需要上报一些审计数据,下发策略等东西。 当数据发生变动就会使用线程池去开启线程上报数据
线程池：三大方法   七大参数
    1.Executors.newSingleThreadExecutor       //单个线程
    2.Executors.newFixedThreadPool(int值)     //创建一个固定大小的线程池
    3.Executors.newCachedThreadPool()         //可伸缩的，遇强则强
    4.Executors.newScheduledThreadPool()      //定时线程 延时3s处理
三种方法本质都是new ThreadPoolExecutor  这个方法的七个参数
    1.corePoolSize                                       核心线程池大小(最小)
    2.maximumPoolSize                                    最大线程池大小 (可伸缩的创建最大21亿  OOM内存溢出)
    3.keepAliveTime                                      超时释放时间(超时没人调用,)
    4.TimeUnit                                           时间单位 (上面超时时间的单位)
    5.BlockingQueue<Runnable>                            阻塞队列
    6.ThreadFactory                                      线程工厂，创建线程的,一般不用动
    7.RejectedExecutionHandler                           拒绝策略
    最大线程到底改如何定义？
      1.CPU密集型：几核CPU就是允许最大线程    Runtime.getRuntime().availableProcessors()获取
      2.IO密集型：判断程序中十分耗IO的线程, 只要大于这个数就行 一般两倍
四种拒绝策略
    1.new ThreadPoolExecutor.AbortPolicy()  //丢弃任务并抛出RejectedExecutionException异常。
    2.new ThreadPoolExecutor.CallerRunsPolicy() //由调用线程处理该任务 【谁调用，谁处理】
    3.new ThreadPoolExecutor.DiscardPolicy()   //也是丢弃任务，但是不抛出异常。
    //当任务被拒绝添加时，会抛弃任务队列中最旧的任务也就是最先加入队列的，再把这个新任务添加进去。
    //在rejectedExecution先从任务队列种弹出最先加入的任务，空出一个位置，然后再次执行execute方法把任务加入队列。
    4.new ThreadPoolExecutor.DiscardOldestPolicy()
---------------------------------------------------------------------------------------------------------------
什么是JMM？
     java内存模型,是一个不存在的东西,共享变量存储在主内存,每个线程又有线程内存。 线程操作共享变量必须要拿到线程内存进行使用,最后要刷新回主内存
线程：  工作内存        主内存    涉及到8种操作  4组
    1.lock     （锁定）：作用于主内存的变量，把一个变量标识为线程独占状态
    2.unlock （解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
    3.read    （读取）：作用于主内存变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用
    4.load     （载入）：作用于工作内存的变量，它把read操作从主存中变量放入工作内存中
    5.use      （使用）：作用于工作内存中的变量，它把工作内存中的变量传输给执行引擎，每当虚拟机遇到一个需要使用到变量的值，就会使用到这个指令
    6.assign  （赋值）：作用于工作内存中的变量，它把一个从执行引擎中接受到的值放入工作内存的变量副本中
    7.store    （存储）：作用于主内存中的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用
    8.write 　（写入）：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中
有序性可见性原子性
    有序性：程序按照指令一行一行执行                             synchronized和synchronized可以保证
    原子性：要么同时成功要么同时失败,要统一执行,不可分割,不可中断     通过锁保证原子性
    可见性：一个线程修改了共享变量的值,其他线程要立即知道            synchronized和synchronized可以保证
指令重排：
    1.执行程序的时候,为了提高性能,处理器和编译器可能会对程序的指令进行重新排序
    比如：指令重排导致DCL懒汉式出现问题
指令重排有限制吗？通过哪两个规则可以约束？
    1.happens-before：是JMM中保证多线程操作可见的一个机制
          定义1.如果一个操作 happens-before 另一个操作,那么这个操作的结果对另一个操作是可见的。
              2.如果操作顺序被指令重排,但是结果保持一致,那么它并不是非法的
          规则：1.锁定规则：一个线程的unlock操作要先于另一个线程的lock操作
               2.volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；
    2.as-if-serial：所有指令都可以被重排序,但是需要保证是在单线程下而且执行结果不变。 他其实不会对有依赖关系的指令进行重排
请你谈谈 volatile 的理解？ volatile的原理？
   volatile是轻量级的同步机制
   1.保证可见性: 他不操作线程内存,直接操作主内存进行读写,所以保证可见性
   2.不保证原子性
   3.保证有序性: 会在指令前后加读写内存屏障,从而限制一些情况的重排序。在它符合的规则内还是可以进行重排的
---------------------------------------------------------------------------------------------------------------
synchronized用过吗？怎么使用
   1.对实例方法加锁:锁的是对象实例
   2.对静态方法加锁:锁的是Class类模板
   3.对代码块加锁:
synchronized锁住的是什么呢？
   1.基于Monitor实现的。HotSpot中,Monitor是由ObjectMonitor实现的,也叫内部锁
   ObjectMonitor的工作原理
       1.两个队列:：_WaitSet、_EntryList，用来保存ObjectWaiter 对象列表。
       2.当线程进行 _owner 区,_count +1 如果线程调用wait方法,_count-1 如果_owner为空,进入_WaitSet队列
synchronized可见性，有序性，可重入性怎么实现？
   保证可见性:加锁前情况线程内存的值,加锁后重新读取最新值,然后其他线程是不可读取操作共享变量,解锁时把修改值维护回主内存
   保证有序性:加锁的代码只会被一个线程执行,符合as-if-serial,可以保证最终结果的有序性,但是不保证不会指令重排
   可重入性  :通过 ObjectMonitor内部维护的count实现可重入性,重入+1 执行完-1 如果为零释放锁
锁升级：    方向  无锁-》偏向锁-》轻量级锁-》重量级锁 // todo
锁宏观分类
1.悲观锁:每次读数据都认为数据被修改过,所以读写都要进行加锁。 如 synchronized
2.乐观锁:认为数据是安全的,只需要判断版本号是否一致,不一致禁止。  如CAS自旋锁
为什么要有锁升级？
线程的阻塞和唤醒是需要操作系统介入,频繁切换会消耗系统资源,浪费时间。synchronized争抢不到就会阻塞,被称为重量级锁。所以JDK5开始引入锁升级进行优化
对象头,Mark Word
锁状态标志位   01 无锁或偏向锁 具体通过是否是偏向锁标志位判断  00轻量级锁标志   10重量级锁标志
偏向锁
  获取：状态为01偏向锁状态为1,判断线程ID是否是当前线程,是直接执行代码块,不是CAS自选获取锁,获取成功更新线程ID然后执行代码 不成功说明线程有竞争,偏向锁升级轻量级锁。 获取到锁的线程要在安全点STW进行锁升级,升级完毕继续执行代码
  撤销：偏向锁不会主动撤销,只有遇到竞争才会撤销,持有锁的线程有两种状态 1.代码已经执行完毕,则可以直接撤销偏向锁变成无锁 2.线程还在执行,要进行安全点等待 升级轻量级锁
  适用场景： 只有一个线程情况下,不存在竞争.  如果竞争多时会频繁进行STW造成性能下降,所以一般并发高的应用建议关闭偏向锁
轻量级锁
  获取：当前线程划分一块空间作为锁记录,拷贝锁对象头mark word到锁记录中,然后将owner指针指向对象头mark word,如果更新成功,就获取到轻量级锁,如果获取失败 判断对象mark word是否指向当前线程的锁记录,是的话执行代码 不是CAS自选 锁升级
synchronized和lock区别
    1.synchronized 是一个关键字                            lock 是一个java类
    2.synchronized 会自动释放锁                            lock 手动释放锁   不释放就是死锁   手动释放更加安全
    3.synchronized 默认可重入,不可中断,非公平                lock 默认可重入,可判断中断,非公平(可以自己设置)
    6.synchronized 底层使用监视器                          lock 底层使用AQS
AQS：同步队列    父类AbstractOwnableSynchronizer 内部维护了一个Thread属性,是当前占有锁的线程 提供了get/set进行获取当前持有锁的线程 //todo
    减法计数器,reentrantLock和信号量都是用的AQS,思想就是通过volatile修饰state,多线程通过CAS自旋来修改state,修改成功就标识占有锁,其他线程进入队列休眠,当释放锁后队列中线程继续自旋获取锁的一个过程
    CLH:虚拟的双向队列,不存在队列实例,只有node之间的关联关系,获取不到锁的线程会被加入到队列中
    队列是CLH的一个改进,CLH就是FIFO的队列,AQS内部维护Node节点,每个线程都会封装成Node节点然后通过前后指针组成一个链表的结构  具体状态在AQS内部类Node中有说明
    出队过程：当一个节点竞争到时会踢出上一个头节点,将自己设置为头节点。 释放后也需要等下一个获取到的将自己提出
    唤醒队列的规则： 判断当前节点waitStatus是否为0,如果为0不会唤醒后续节点,会造成死锁。 所以当节点入队休眠的时候需要将前驱节点的状态设置成等-1
    为什么唤醒要从尾巴开始：新节点入队1.将前节点指向最后节点2.将尾节点指向当前节点3.将上一个节点的next指向当前节点  可能存在第二步执行完CPU切换线程执行,这个时候从头向尾找可能漏掉节点,从尾向头可以降低漏扫的问题
    共享锁(SHARED)    大致方法差不多,主要区别就是共享锁获取成功的节点会继续启动后续节点获取,而独占锁只有释放后才会启动后续节点获取
      获取
      acquireShared，共享，忽略中断
      acquireSharedInterruptibly，共享，可中断
      tryAcquireSharedNanos，共享，可设置超时，可中断
      释放
      releaseShared
    互斥锁(EXCLUSIVE)
      获取
      tryAcquire(独占锁 忽略中断)方法获取独占锁,线程调用addWaiter创建Node节点添加到队列,获取成功替换成头节点然后执行,获取不成功就会进入队列阻塞。
      acquireInterruptibly独占锁 可中断
      tryAcquireNanos 独占锁 可超时可中断  到了超时时间就返回false
      释放
      release 忽略中断
ReentrantLock  默认非公平 ,传true设置公平锁  非公平吞吐量大但是可能导致一些优先级低的线程饥饿而无法执行
    非公平锁：调用lock执行进行一次抢占,不成功入队排列,发现锁被释放会进行CAS自选争抢  而公平锁会判断前面是否有其他线程处于等待,有则进行等待排到后面
CAS：比较并交换 (比较当前工作内存的值和主内存的值是否一致 一直就交换,不一致一直循环阻塞)
    缺点: 1.ABA 问题      2.循环性能开销        3. 只能保证一个变量的原子操作(如果多个变量可以通过锁保证原子性   或者变量封装成对象通过原子引用保证原子性)
单例模式：
    1.饿汉单例：Hangry
    2.懒汉单例：Lazy             DCL懒汉式               静态内部类单例模式
    3.但是他们通过反射都可以破坏单例    可以通过ENUM解决   内部提供的是一个有参构造函数,但是反射无法破坏Enum对象
---------------------------------------------------------------------------------------------------------------
ThreadLocal：线程本地变量
为什么要引入ThreadLocal？
    多线程共享资源修改线程不安全,加锁效率又低,所以对部分数据使用ThreadLocal让每个线程都有一份自己修改自己的,线程隔离保证线程安全
ThreadLocal用处？
    1.拦截器将用户信息存入ThreadLocal,就可以在任意地方取值  2.pageHelper
ThreadLocal实现原理
    Thread类中属性ThreadLocalMap,ThreadLocalMap内部使用Entry数组.entry的key是ThreadLocal弱引用,value是存入数据
    扩容：初始16 达到3/4扩容为2倍然后重新hash计算迁移到新数组中,最后改变引用指针
    hash冲突：存的时候如果位置冲突就会向后找空位置存,取的时候定位到判断是否一致,不一致向后找
为什么使用ThreadLocal作为key不使用Thread？为什么采用弱引用
    一个线程中可能存放多个ThreadLocal。这时候使用Thread就无法区分！
    强引用问题：采用强引用的话线程池不销毁,线程一直存在所以ThreadLocalMap也会保留从而ThreadLocal也无法回收造成内存泄露
如何解决内存泄露
    使用完之后通过finally方法执行remove将key和value都设置为null就会被GC回收
为什么ThreadLocal建议设置成静态
    因为一个线程对应一个ThreadLocalMap,只需要创建一次即可.不加静态每次创建对象都创建一个相同的ThreadLocal浪费资源
父子线程传递数据？线程池传递数据？  //todo
    1.JDK自带InheritableThreadLocal解决父子线程传值问题,init方法判断父线程是否有Map拷贝到子线程
    2.阿里巴巴开源TransmittableThreadLocal解决线程池传值问题。
---------------------------------------------------------------------------------------------------------------
线程的状态  Thread.state 可以查看状态
    1.new 线程被创建,但是没有调用start方法
    2.Runnable 运行：java线程将操作系统的就绪和运行都统称为运行
    3.Blocked 阻塞： 表示线程阻塞
    4.Waiting 等待的一个状态(死等)： 线程进入等待,需要等待其他线程通知或者中断
    5.Timed_Waiting 等多少秒就不等了  不同于等待是可以在固定时间内自行返回
    6.Terminated  终止  代表执行完毕

wait和sleep的区别？
    1.wait存在Object类           sleep存在Thread类
    2.wait会释放锁               sleep不会释放锁
    3.wait只能在同步代码块中使用    sleep任何地方都可以使用

工具类
读写锁
  独占锁(写锁)：一次只能被一个线程占用
  共享搜(读锁): 多个线程可以同时占用

阻塞队列：   一般在d多线程并发处理和线程池用到
    1.当队列满了,不能继续存的时候需要阻塞.等待取出然后在存
    2.当队列没有的时候,必须阻塞等待生产才能取
阻塞队列对应的四组API
    1.抛出异常                 添加:add          移除:remove            查看队首元素:element
    2.不抛出异常,有返回值        添加:offer        移除:poll              查看队首元素:peek
    3.超时等待                 添加:offer有参     移除:poll有参
    4.阻塞等待                 添加:put          移除:take
同步队列SynchronousQueue
    进去一个元素，必须等待元素取出 才能继续存放元素   存   put   取  take
顶级 collection --》queue---》blockingQueue
    blockingQueue：阻塞队列   》》》一边存 另一边取
    AbstractQueue：非阻塞队列
    Deque：双端队列           》》》 两边都可以存取
---------------------------------------------------------------------------------------------------------------
JAVA基础
   1.ArrayList->多线程下会出现 并发修改异常
        解决方案：1.Vector 本质就是加了 synchronized
                2.Collections.synchronizedList()
                3.copyOnWriteArrayList
   2.HashSet->多线程下会出现 并发修改异常
        解决方案：1.Collections.synchronizedSet()
                2.copyOnWriteArraySet
   3.HashMap->多线程下会出现 并发修改异常
        解决方案：1.Collections.synchronizedMap()
                2.concurrentHashMap()

HashSet底层？
   1.底层就是HashMap,值为HashMap的key, value是一个固定值,所以hashSet不可以重复

函数式接口
   1.supplier 提供者:只有返回值没有参数
   2.consumer 消费者:只有参数没有返回值
   3.function 函数  :传入一个类型返回另一个泛型
   4.Predicate 运算符：传入一个值返回true和false
