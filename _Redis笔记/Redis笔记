发展历程
90年代：使用单机数据库 +静态html页面。  访问量不大  单个数据库足够使用
        1.数据量总大小 一个机器放不下 ----》300w必须创建索引
        2.数据的索引（B+ Tree）一个机器的内存放不下时
        3.访问量多(读写混合)--》一个服务器受不了
        16G内 存能放下大概 2000W 行数据的索引，  简单的读和写混合访问量3000/s左右没有问题，
Memcached（缓存）+MySQL + 垂直拆分
        1.网站80%都在查询。每次操作数据库十分麻烦,为减轻数据库压力。可以使用缓存
        2.但是数据量大了还是会出现最初内存不够  访问量大无法承受的问题
读写分离：主库承担写的压力，分库承担读的压力
        1.对于读多写的少  适用
        2.写入量大  会造成主库无法承受
水平拆分：数据量变成1/n,,可以提高并发量和稳定性
        1.分片式事务不好解决
        2.跨库join性能降低。而且维护难度提高。
云数据库：
  缓存适用于数据变动不大。但是像用户日志。数据量大变动又快的东西 关系型数据库就不适用了

NOSQL四大分类
  1.键值对key value存储：Redis（C编写） 、Tair 、memcache
     优点：查找速度快
     缺点：数据没有结构,通常只被当作字符串和二进制数据
     应用场景：数据缓存，日志
  2.文档型数据库： 基于分布式文件存储的数据库 MongoDB(C++编写) 主要用来处理大量的文档 介于关系和非关系之间是最像关系型数据库的
     优点：数据结构要求不严格
     缺点：查询速度低
  3.列存储数据库： Hbase 、 分布式文件系统
     优点：查找速度快,可拓展性强
     缺点：功能相对局限性。因为是以列存储的
     应用场景：分布式文件系统
  4.图形关系数据库： 比如朋友圈,社交网络,广告推荐  Neo4j
     优点：利用图结构算法,查找最短路径
     缺点：很多时候需要所有数据才能得出结论,不好做分布式集群
     应用场景：社交网络,朋友圈,广告推荐
----------------------------------------------------------------------------------------------------
RDBMS（关系型数据库）
  优点1.通用sql,表形式便于理解,降低数据冗余和不一致概率
  缺点1.高并发下读写效率低 2.数据库很难横向扩展  3.复杂sql,多表连接
NOSQL区别：
  优点 1.方便扩展(数据直接无关系,很好扩展)
      2.大数据量高性能(1s读11万。写8w,nosql缓存是一种细粒度的缓存,性能比较高)
      3.不需要事先设计数据库。数据类型多样型
---------------------------------------------------------------------------------------------------
Redis：全称 远程字典服务
  是一个开源的使用c编写的、支持网络、可基于内存可持久化的日志型、key-value类型的数据库,提供多种API。也被称为结构化数据库
  优点：
    1.支持持久化,效率高(高速缓存),支持事务,数据类型丰富,支持主从复制,哨兵,集群
    2.用于发布订阅、地图信息分析、set实现的共同好友推荐等、string实现的计数器、zset排行榜
  缺点：
    1.基于内存的,受物理内存限制,不能做海量数据筛选。不具备容灾恢复。主机宕机前没有同步给从机的数据会丢失
----------------------------------------------------------------------------
一、Redis高可用概述
我们知道，在web服务器中，高可用是指服务器可以正常访问的时间，衡量的标准是在多长时间内可以提供正常服务（99.9%、99.99%、99.999% 等等）。但是在Redis语境中，高可用的含义似乎要宽泛一些，除了保证提供正常服务(如主从分离、快速容灾技术)，还需要考虑数据容量的扩展、数据安全不会丢失等。
1、持久化：持久化是最简单的高可用方法(有时甚至不被归为高可用的手段)，主要作用是数据备份，即将数据存储在硬盘，保证数据不会因进程退出而丢失。
2、复制：复制是高可用Redis的基础，哨兵和集群都是在复制基础上实现高可用的。复制主要实现了数据的多机备份，以及对于读操作的负载均衡和简单的故障恢复。缺陷：故障恢复无法自动化；写操作无法负载均衡；存储能力受到单机的限制。
3、哨兵：在复制的基础上，哨兵实现了自动化的故障恢复。缺陷：写操作无法负载均衡；存储能力受到单机的限制。
4、集群：通过集群，Redis解决了写操作无法负载均衡，以及存储能力受到单机限制的问题，实现了较为完善的高可用方案。
----------------------------------------------------------------------------
官方自带的压力测试工具redis-benchmark
11集
Redis默认有16个数据库。索引0~15  默认是0数据库。
  select 3 ：切换数据库。
  keys *   ：查看当前库中所有的Key
  DBSize   ：查看当前库的大小
  flushAll ：清空全表
  flushdb  ：清空当前数据库
  move name 1 ：将name移动到1数据库
  expire name 10：10s过期时间
  ttl name：（time to live）查看name的剩余过期时间
  type     ：查看key 的基本类型         Exists key    ：判断是否存在


Redis：是一款开源的,内存中的数据结构存储系统,可以用做数据库,缓存和消息中间件.支持多种数据结构。String、Hash、List、set、Zset
与范围查找,bitmaps,hyperloglogs和地理空间geospatial索引半径查询,Redis内置了复制(replication)、事务和不同级别的磁盘持久化
并通过Redis哨兵和自动分区提供高可用性
--------------------------------------------------------------------------------------------------------
底层数据结构：
简单动态字符串SDS ：redis没有直接使用c的字符串而是自己构建简单动态字符串(引文缩写sds)
  Redis中所有的键都是字符串类型,底层是SDS：SDS包含free、len、buf
    buf：char类型的数组buf,每个位置存储字符,最后一个位置存储空字符‘\0’   c中\0会被看成结束
    free:代表未使用的空间大小        C语言修改长度可能溢出,而SDS会判断,如果不满足将进行扩容
    len:目前字符串的长度            C语言不会记录长度,需要遍历得到,而简单动态字符串SDS记录了长度
链表：  C中没有内置链表,Redis实现了自己的链表结构。List底层就是链表
  每个链表节点都有指向前节点和后节点的指针,是一个双向链表,内置表头表尾长度等信息.表头表尾前置后置是null是一个无环链表
字典：  C中没有。  (Redis的底层数据库、Hash)的底层就是字典
  字典用来保存键值对类型,任何一个键值对无论什么类型都可以存放在字典中。
跳跃表： 一个是实现有序集合键，另一个是在集群节点中用作内部数据结构
  是一种有序的数据结构,通过每个节点维持的多个指针从而快速访问节点
整形：   整形是set的底层结构
  包含了length属性,并且不会出现重复
压缩列表：  压缩列表是list和hash的键的底层实现
  当每个键值对的键和值要么小整形要么比较短的字符串,就会用压缩列表。节约内存
String类型               ：点赞。浏览量
  append key value：将这个key的值拼接value,如果key不存在就相当于set
  StrLen key ：获取字符串的长度
  incr key  :相当于i++  可以做浏览量   decr key ：相当于i--   配合incr可以做点赞
  incrBy key 5：相当于i+5    decrBy key 5 ：相当于i-5
  increase  increment     decrement  decrease
  getRange 0 3 :截取字符串下标0-3。[0,3]包含0 1 2 3。  如果想要获取全部 getRange 0 -1
  setRange key 1 XX  :将key的索引1位置字符替换成XX存入
  setex name 30 “whj”：相当于set name “whj”+expire name 30
  setnx(SET if Not eXists)：如果不存在进行set存在返回失败0.而set是覆盖
  mset:批量设置多个值 mset k1 v1 k2 v2 k3 v3       mget:批量获取多个key:mget k1 k2 k3
  msetnx:如果存在设置多个值。一个重复则全部失败。
  getset：先get值然后又set
List类型(列表)     Redis中List类型可以用来当成栈、(消息队列)队列、双端队列、阻塞队列   头尾操作效率高。中间效率低
  lpush list1 1 2 3 4 5:将1-5从左边压入   rpush list2 1 2 3 4 5:将1-5从右边压入
  lrange list1 0 -1： 5 4 3 2 1         lrange list0 0 -1：1 2 3 4 5
  lpop：将左边第一位取出来移除              rpop：将右边第一位取出来移除
  lindex key 3：从左面取索引为3的实际是第四个元素    llen：获取list长度
  lrem key 2 1；从左面删除第一个和第二个1    Ltrim key 0 2：从左边截取list的key索引为0-2然后赋值给key
  rpopLpush key key1：从右边取key的值并移除然后从左边将这个值压入key1
  lset key index value：将key左边索引为index的值更新成value
  linsert key before/after 值1 值2：找到key的值1位置在前面或者后面插入值2
Set类型：    共同关注,共同爱好,推荐好友,（六度分割理论）
  sadd key 值：给set集合插入值,值不可重复   smembers key：获取所有的值  scard获取集合里元素数量
  sismembers key value：查看集合是否存在这个value 返回0/1    srem key value：移除key中的value元素
  无序不重复集合：srandmember key 1:随机获取key集合的1个元素  spop key：随机删除key中的一个元素
  smove key1 key2 value：将key1的value移动到key2集合中 不指定value则是随机移动一个
  sdiff key1 key2：key1集合中key2没有的元素     sinter key1 key2：key1,key2都存在的元素
  sunion key1 key2；将key1和key2元素合并去重
Hash类型：也是键值对,值是map集合 key-map   存一个变更的数据。用户数据 适合存储对象session信息
  hset people name whj： 插入值      hget people name：获取值    hgetall people：获取people中所有键值对
  hmset people name whj age 20：插入多个值  hmget people name age：获取多个值  hdel people name：删除name键值
  hlen people ：获取people中的键值对个数   hexists 键名 值键名：判断是否存在返回0/1
  hkeys key：获取key中的所有key   hvals key：获取key中的所有值
Zset类型：  存储班级成绩 工资表  带权重执行  排行榜
  zadd k1 score v1：
  zrangeByscore salary -inf +inf：查询指定范围的元素 zrangebyscore salary (2500 5000 ====>(2500,5000]
  zrangeByscore salary -inf +inf withscore:查询最小到最大并携带成绩
  zrange salary 0 -1：查看所有元素     zrem salary xiaohong：移除小红
  zcard salary：查看元素数量   Zrevrange 0 1 ：成绩从高到低排列 (参数代表排序的索引。0到1取出来)
三种特殊的：geospatial(地理位置)：附近的人 朋友定位  打车距离计算    底层其实就是zset有序集合.可以使用zset命令查看全部和删除
  geoadd key 纬度 经度 name：添加经纬度和名称。 两级无法直接添加。一般会下载城市数据,在java中一次性导入
  geopos key name name1：查询key中name的经纬度。可以有多个name
  geodist key name name1：查询key中name和name1的距离(m\km\mi(英里)\ft(英尺))
  georadius key 经度 维度 500半径范围 单价km：以给定经纬度为中心,找出某一半径内的元素  附近的人
  georadius key 经度 维度 500半径范围  单价km  withdist(距离)或者withcoord(经纬度)  count 数量
  georadiusBymember key name 500 km：查找指定name的附近500km的地方
  geohash key name name1：将key中的name和name1转换成11位的hash字符串 二维经纬度变成一维字符串,越相似越近
hyperloglog：基数统计  一个key中不重复的值。数据量大可以接受误差
  优点：占用内存小 一个人访问多次网页算一个。这种如果要用set实现占用内存大
  PFadd key values：给key添加多个值      pfcount key:统计key的不重复数据个数。可以有多个key则为并集
  pfmerge 新key key1 key2：将key1和key2的值合并生成key3
bitmap：位图 数据结构。都是操作二进制来进行记录。 位存储   统计用户活跃不活跃 10101  登录未登录  打卡
  setbit sign 0 1：设置周一到周日的打卡,第一个是周一到周日,第二个是位0 1。 setbit sign 1 0  setbit sign 2 1
  getbit sign 3：获取周四打没打卡。     bitcount sign start end：默认查看所有为打卡1的个数
缓存：将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。
会话缓存：保存用户的session,token信息    优势是redis提供持久化 memcache没有提供持久化
全页缓存：用户访问过的页面缓存,第二次访问速度快。 因为有持久化,就算是Redis重启加载速度也不会下降
查找表：例如DNS记录使用Redis存储,和缓存类似,也是利用redis的快速查找特性,但是查找表的内容不能失效,缓存可以失效
-----------------------------------------------------------------------------------------------
Redis事务操作：
  一组命令集合,所有命令都会被序列化,会按照顺序执行。     单条语句具有原子性,多条没有原子性。支持一致性和隔离性,AOF支持持久性
  错误类型：
     1.编译错误    全部都不执行
     2.运行错误    错误的不执行,正确的都可以执行
     3.不支持回滚
  开启事务 multi    语句。。。。。    exec执行事务。   discard 取消事务
  其他实现方式：redis脚本(LUA)也可以实现事务
Watch 监控事务：
  watch命令可以决定事务会回滚还是提交。在事务multi开启之前开启watch监控一些键值对。exec提交的时候检查。键值对没有被其他线程修改
  则提交事务,如果值被修改,则回滚事务。 乐观锁的思想,类似于判断版本。和多线程中CAS的原子引用的乐观锁类似。
  开启：  watch key    取消1.事务exec执行完毕。无论成功失败监控都取消 2.客户端推出 3.手动unwatch 取消
Jedis：使用Java来操作redis,官方推荐java连接redis工具。相当于连接redis的中间件
  new Jedis()参数：ip 端口号 可选：ssl 超时时间       jedis.close()//关闭连接
整合Spring boot：
  Jedis：采用直连,多个线程操作是不安全的,避免不安全,加入jedis pool连接池，更像BIO模式
  netty:采用netty,实例可以在多个线程间共享,不存在线程不安全,可以减少线程数，更像NIO模式
  redisTemplate.opsForValue();//操作String类型  opsForList//操作list   opsForset//操作set
  redisTemplate.getConnectionFactory.getConnertion()//获取连接对象。结果可以进行 flushdb 和 flushall
---------------------------------------------------------------------------------------------
序列化： 任何存储,传输都需要进行序列化,只不过数据库内部已经解决了.在插入的时候进行序列化.在取出来的时候进行解析,而redis内部并没有
解决,redis的value是byte array字节数组。所以需要将数据结构转成字节数组。而字符串几乎就是字节数组,所以不需要转换
  序列化：把对象转化为可传输的字节序列(字节数组)过程称为序列化。
  反序列化：把字节序列(字节数组)还原为对象的过程称为反序列化。
  方式：JDK（不支持跨语言）、JSON、XML    技术选型关键点 1.序列化速度 2.序列化字节数组大小
  JAVA序列化中常见的问题: 问题一：static 属性不能被序列化
  原因：序列化保存的是对象的状态，静态变量属于类的状态，因此 序列化并不保存静态变量。
  问题二：Transient 属性不会被序列化   短暂的属性
  问题三：序列化版本号serialVersionUID  当对象有改动但是版本号一样。不会影响序列化和反序列化。只不过最新的改动会失效
  每个对象必须有版本号，如果没定义会自动生成,自动生成的版本号只要对象有改动就会变更,变更用户就需要更新版本。因此建议手动设置

-----------------------------------------------------------------------------------------------
Redis Config配置文件
注意单位:当需要内存大小时，可以指定   它的通常形式为1k 5GB 4M等:
# 1kb => 1024 bytes
# 1mb => 1024*1024 bytes
# 1gb => 1024*1024*1024 bytes
# 单位不区分大小写，所以1gB 1Gb 1gb都是一样的。
为了读取配置文件，Redis必须 以文件路径作为第一个参数开始:
# ./redis-server /path/to/redis.conf
################################## INCLUDES  包含###################################
#  类似下面 include /path/to/other.conf 可以把其他的配置文件配置进来
# include /path/to/other.conf
################################## MODULES #####################################
#  下载第三方的Redis modules模块，make编译
# loadmodule /path/to/other_module.so
################################## NETWORK  网络 #####################################
# bind 127.0.0.1   绑定IP 外网访问注掉这个  并且将下面保护关闭 0.0.0.0 所有
protected-mode no  # 保护关闭  不然外网访问报错
port 6380   端口号
################################# GENERAL 通用配置#####################################
daemonize yes  #守护线程开启 默认no 需要手动开启 不然退出 进程就结束
supervised no    #管理守护线程的  默认no
pidfile /var/run/redis_6379.pid   #如果守护线程开启 则是后台运行 就需要指定一个pid进程文件
# debug (a lot of information, useful for development/testing)大量的信息，一般用于开发/测试阶段
# verbose (many rarely useful info, but not a mess like the debug level)许多很少有用的信息，但不像调试级别那样混乱
# notice (moderately verbose, what you want in production probably)通知 适合生产 默认是这个
# warning (only very important / critical messages are logged) 警告  只记录非常重要的信息
loglevel notice  #日志级别
logfile ""   #日志文件输出名 为空
databases 16   #默认数据库数量
always-show-logo yes   #是否显示log  默认开启 启动的图案
################################ SNAPSHOTTING  快照  持久化RDB配置################################
#持久化规则  默认携带下面三种  可以自己定义
save 900 1    #900代表时间  如果900s内 有一个key进行了修改  就进行持久化操作
save 300 10    #如果300s内 有10个key进行了修改  就进行持久化操作
save 60 10000  #如果60s内 有10，000个key进行了修改  就进行持久化操作
stop-writes-on-bgsave-error yes   #持久化错误之后是否继续工作  默认开启 避免大量数据丢失.启用监控时考虑设置no
rdbcompression yes           #是否压缩 rdb文件  默认(LZF算法)开启  压缩会消耗CPU资源 但是可以减小RDB文件的大小
rdbchecksum yes             #保存 rdb文件的时候进行错误的校验  在写入文件和读取文件时都校验,关闭后文件损坏不容易发现
dir ./                   # RDB文件和AOF文件所在目录
dbfilename dump.rdb        #RDB文件名
################################# REPLICATION 主从复制#################################
role:master       #角色  主机
connected_slaves:0     #连接的从机   0个
second_repl_offset:-1
################################## SECURITY  安全 设置密码###################################
# requirepass foobared   可以将此行放开  后面foobared 换成密码
  config get requirepass 获取  set 插入密码   auth "密码" 验证
################################### CLIENTS 客户端####################################
# maxclients 10000   #连接redis的最大的客户端数,可以防止大量客户端连接消耗缓冲内存。
############################## MEMORY MANAGEMENT 内存配置################################
# maxmemory <bytes>   #Redis最大内存设置(不设置64位无限制 32位3G)字节类型需要转换 转换看配置开头。一般设置物理内存的3/4.
############################## APPEND ONLY MODE AOF配置###############################
appendonly no    # 打开aof设置，同时将快照功能置于低优先级的位置
appendfilename "appendonly.aof"     #持久化文件名字
# appendfsync always      #每次修改都会同步   速度比较慢 消耗性能
appendfsync everysec    #每秒执行一次  sync同步 可能丢失这一秒数据
# appendfsync no        #不执行sync同步  操作系统自己同步数据  速度最快 一般不用
no-appendfsync-on-rewrite:设置yes在AOF保存期间客户端操作保存在缓冲区,但是如果断电会丢失,最多丢失30s。如果设置NO,保存期间客户端阻塞等待
--------------------------------------------------------------------------------------------
Redis持久化：redis是内存数据库 如果没有持久化 那么数据断电就消失了
RDB(redis database)方式：  Mysql的Dump方式、Redis的RDB方式。
  在一定的时间间隔内,将内存中的数据库快照snapshot写入磁盘文件中,重启时通过读取RDB文件来还原数据库
  触发条件：
    手动触发：1.save：会阻塞Redis主进程,直到RDB文件创建完毕为止，在Redis服务器阻塞期间，服务器不能处理客户端命令请求
            2.bgsave: fork一个子进程去调用rdbSave方法,RDB文件生成后向主进程发送完成信号,服务器可以处理客户端命令请求
    自动触发：1.配置文件中的save m秒内发生n次变化时，会触发bgsave
             2.在主从复制场景下，如果从节点执行全量复制操作，则主节点会执行bgsave命令，并将rdb文件发送给从节点
             3.shutdown命令时，自动执行rdb持久化。但是使用kill杀掉进程会丢失部分数据
    配置中save的实现原理： 每100毫秒执行一次,判断当前时间戳-上一次成功的时间戳,计数器的次数是否满足sava的配置
                       周期函数：每100毫秒z执行一次,检查配置是否满足,满足就执行bgsave
                       计数器：记录服务器进行了多少次修改。类似binlog一条记录就是一次修改
                       时间戳：记录上一次sava/bgsave成功保存的时间戳
    执行流程：
      1.父进程首先判断是否有sava/bgsave/bgrewriteaof的子进程在执行,如果执行直接返回。不能同时执行,同时大量磁盘写影响性能
      2.父进程fork子进程会阻塞父进程,不能执行客户端指令, 子进程创建RDB文件,完成对原有RDB文件的覆盖
      3.通知父进程完成,父进程更新统计信息。---》更新计数器和时间戳
    保存路径：
      1.配置文件快照中  dir配置RDB目录  dbfilename 指定文件名 默认-》dump.rdb
      2.动态设定：磁盘损坏或空间不足时可以通过指令 config set dir {newdir}和config set dbfilename {newFileName}
    启动载入：
      AOF优先级高,当AOF开启,redis会优先加载AOF文件来恢复数据,AOF不开启会检测RDB文件,自动加载并且处于阻塞状态,文件损坏启动失败并在日志中打印错误
  原理：rdbsave:用于生成 RDB 文件到磁盘
       radload:用于将 RDB 文件中的数据重新载入到内存中
  优点：fork子进程去做持久化,而且恢复的时候比AOF速度快
  缺点：当redis宕机可能会丢失大量数据。而AOF丢失较少
       RDB在生成数据快照的时候,如果文件很大,会阻塞客户端较长时间
AOF(append only file 追加文件)方式：  Mysql的Binlog、Redis的AOF、Hbase的HLog。
  将每次执行的增删改命令保存在磁盘,恢复的时候将所有命令执行一遍。类似于mysql中的binlog 实时性好,丢失数据少,主流
    执行流程：
      1.所有的增删改命令会追加到 AOF 缓冲中。
      2.AOF 缓冲区根据对应的策略向硬盘进行同步操作。
      3.AOF保存条件满足,fsync/fdatafync函数被调用,将写入的内容真正保存在磁盘文件中
    AOF保存模式：
      4.第1种安全性最高效率最差 第二种通常情况下丢失不超过2s,安全性和效率兼顾
      1.appendfsync always 每次修改都会同步：写入和保存都由主进程执行,会阻塞主进程。  速度比较慢 消耗性能
      2.appendfsync everysec每秒执行：写入主进程执行,会阻塞,保存子线程调用的,不会阻塞,但是保存快慢影响写的阻塞时长
        1.save不在执行,距离上次保存成功超过1s,执行写入和保存
        2.save不在执行,距离上次保存成功没超过1s,执行写入但不保存
        3.save在执行,距离上次保存成功超过2s,执行写入但不保存
        4.save在执行,距离上次保存成功没超过2s,直接返回不保存也不写
        总结：官方说之丢失1s不准确,实际丢失可以超过2s的
      3.appendfsync no不保存：每次都会写入AOF文件末端,但是不保存。 写入和保存都由主进程执行，都会阻塞主进程。
        1.redis关闭2.AOF功能关闭3.系统的写缓存被刷新（可能是缓存已经被写满，或者定期保存操作被执行）
    AOF重写：
      AOF随着时间推移会越来越大,当超过阈值,会启用内容压缩,保留恢复数据的最小指令集,
      1.重写并没有读取原有AOF而是将内存中数据库用命令重写一份。类似RDB模式
      2.AOF后台重写 通过配置的大小和增长率。超过配置大小并且体积是上次重写体积的一倍会自动重写AOF   手动调用重写 bgrewriteaof
      3.触发机制  Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发。生产一般3g
      4.重写的时候除了缓冲区还会创建一个重写缓冲区,AOF创建完毕将重写缓存区保存的数据同步到AOF中,保证和服务器数据一致然后替换原本AOF文件,完成重写
    //RDB文件修复：会将错误的指令删除
    AOF数据恢复：    1.创建不带网络客户端2.取出写命令3.客户端执行写命令
       正常恢复：
         1.配置开启AOF 2.将AOF文件拷贝到Redis启动目录可以通过config get dir查看 3.重启redis
       异常恢复：
         1.配置开启AOF 2.AOF文件修复：会将错误的指令删除  redis-check-aof --fix appendonly.aof  3.重启Redis
    优点：
      1.相对比RDB丢失数据少,而且有文件修复工具
      2.AOF可以定时copy出一份文件。可以按照时间段恢复
    缺点：
      1.相对比RDB文件,AOF文件占用空间大,恢复速度比RDB慢
      2.AOF效率慢于RDB,每秒同步效率较好,不同步效率和RDB相同
如何选取：
  1.要是想保证数据丢失少使用AOF.如果可以允许几分钟数据丢失可以使用RDB
  2.推荐两种都开启,RDB适合用于数据备份,恢复速度快,而且可以避免AOF的程序bug
redis持久化数据和缓存扩容的方式  todo
  缓存扩容方式：
    使用一致性哈希实现动态扩容缩容
  持久化数据扩容方式：
    必须使用固定的keys-to-nodes映射关系，节点的数量一旦确定不能变化。否则的话(即Redis节点需要动态变化的情况），必须使用可以
    在运行时进行数据再平衡的一套系统，而当前只有Redis集群可以做到这样。
-----------------------------------------------------------------------------------------------------------------
List作消息队列：不能用lpop或rpop因为如果没有消息生产还会一直创建连接。  可以使用定时任务出列优化。
使用阻塞blpop和brpop：时间为0表示一直阻塞。会按照key的顺序进行弹出。弹出信息携带key可以作消息优先级  缺点只能一个客户端连接
延时队列  场景：订单未支付定时取消
  1.定时扫表,简单但是浪费资源
  2.使用消息中间件提供的延时队列    开源,但是成本大
  3.redis延时队列  使用zset的socre特性  zadd生产消息  zrangebyscore key -inf +inf withscore limit 0消费消息
    将redis作为消息池,以键值对存储消息,使用zset做优先队列,score存要执行的时间,每秒取出来要执行的消息。
   缺点：不支持太大的数据量。失败回滚方案需要自己处理
Redis消息订阅  发布（Publish）与订阅（Subscribe）：    发布者和订阅者都是客户端,订阅的频道(channel)是服务器端.
  每个Redis服务器进程都维持一个 redisServer.pubsub_channels 字典保存,建为被订阅的频道,值为订阅频道的所有客户端,当有消息的时候就遍历所有
  客户端发送消息
    subscribe channel channel1 ：订阅者订阅 channel 和 channel
    psubscribe a? d?* c*: 支持通配符通配符中?表示1个占位符，*表示任意个占位符(包括0)，?*表示1个以上占位符。 注意如果两个通配符包含了同一个频道。会收到两遍消息
    punsubscribe：命令可以退订指定的规则，用法是: punsubscribe [pattern [pattern ...]],如果没有参数则会退订所有规则。
    punsubscribe和unsubscribe只会退订相对应的类型。不能混着用。而且通配符退订必须规则一样。不支持通配符展开
    publish channel message：发布者指定发布给channel 的message  消息不会被持久化,新订阅的不会收到之前的

Redis发布订阅与ActiveMQ的比较
（1）ActiveMQ支持多种消息协议，包括AMQP，MQTT，Stomp等，并且支持JMS规范，但Redis没有提供对这些协议的支持；
（2）ActiveMQ提供持久化功能，但Redis无法对消息持久化存储，一旦消息被发送，如果没有订阅者接收，那么消息就会丢失；
（3）ActiveMQ提供了消息传输保障，当客户端连接超时或事务回滚等情况发生时，消息会被重新发送给客户端，Redis没有提供消息传输保障。
总之，ActiveMQ所提供的功能远比Redis发布订阅要复杂，毕竟Redis不是专门做发布订阅的，
但是如果系统中已经有了Redis，并且需要基本的发布订阅功能，就没有必要再安装ActiveMQ了，
因为可能ActiveMQ提供的功能大部分都用不到，而Redis的发布订阅机制就能满足需求。
------------------------------------------------------------------------------------------
主从复制：  默认情况每台Redis服务器都是主节点,一个主节点可以有多个从节点。从节点只能有一个主节点
  概念：          读写分离,主机写,从机读。80%都是读操作,减缓服务器压力。主要用来横向扩展,提高读吞吐量
    将一台redis服务器的数据复制到其他redis服务器.主机为主节点。数据复制是主到从。Master 以写为主。slave 以读为主
  主要包括：
    1.数据冗余：主从复制实现了数据的热备份,是持久化之外的一种数据冗余方式。
    2.故障恢复：当主节点出现问题,可以由从节点提供服务。实现快速故障恢复。实际上是服务的冗余
    3.负载均衡：配合读写分离,分担从机读数据的负载。提高并发量
    4.高可用基石：主从复制是哨兵和集群的基础，因此说主从复制是Redis高可用的基础。
  核心机制：
    1.一个主节点可以配置多个从节点,从节点也可以连接其他从节点
    2.主节点采用异步复制数据到从节点,不会阻塞主节点正常工作,也不会阻塞自己查询操作,同步完成删除就数据集加载新数据集的过程可能会阻塞
    3.建议主节点开启持久化,不然主节点宕机重启,哨兵没有检测到从节点的备份文件也会被清空。
  主从原理：
    1.当从机重新连接主机,那么主机只会同步缺少的数据,如果第一次连接,主机创建一个线程来生成最新的RDB文件,同时将收到的写指令缓存到内存中,文件生成后
    主节点将文件和缓存发送给从节点,从节点先先保存到磁盘然后加载到内存,然后将缓存的写命令进行同步。之后主节点收到写同步给从机,保证数据一致
    2.如果有多个从机断开重连,redis只会创建一个线程生成RDB然后发送给所有从机
    3.如果复制过程中断开,重连会从断开地方继续发送,而不是从头开始,内部会保存偏移量,如果没有找到偏移量则只能进行全量复制。
  无磁盘化复制：  固态硬盘和机械硬盘  机械效率低 所以出现无磁盘复制通过socket传输
    1.主节点在内存创建RDB文件,发送给从节点,可以设置等待事件,等待多个从节点连接一并发送
  过期key处理：
    1.从节点不会过期key,只会等待主节点过期key,然后发送del指令到从节点.所以可能出现主节点删除了而从节点还没有删除被读取到
  为什么要弄主从复制或集群：
    1.一个redis会发生单点故障,并且处理所有请求压力大。而且单个redis内存有限
  开启主从配置方式：只配置从库,不用配置主库
    1.slaveof host ip：设置自己的主机。将自己变为从机  可以使用 info replication #查看当前库的信息  Redis关闭失效
       1.先保存主节点信息2.创建连接
       3.发送ping指令
          1.socket正常连接,复制过程继续
          2.超时：说明socket连接不可用,断开连接并重连
          3.返回pong以外的结果,说明主节点无法处理。则断开重连。  无法处理原因：可能在处理超时连接的脚本
       4.权限认证5.同步数据集
       6.持续复制(命令传播)
          1.延迟与不一致 ：命令传播是异步的,数据不一致的程度跟网络状态,主节点写的频率和主节点中配置有关。
             repl-disable-tcp-nodelay：设置no,立即发送同步数据,没有延迟。 一致性高
             设置yes,会合并小TCP包从而节省宽带,但会增加延迟,造成主从数据不一致    一直关注性能  一直关注一致性
             多数设置NO,当数据一致性要求低,并且网络不好时设置yes
          2.心跳机制：   redis如何保证主从服务器一致处于连接状态以及命令丢失？
             命令传播阶段,从服务器会利用心跳机制定时向主服务器发送消息 。
             作用：1.检查主从服务器的网络连接状态2.辅助实现min-slaves选项 3.检测命令丢失
             解决数据丢失
               min-slaves-to-write 3
               min-slaves-max-lag 10
               1.三个从节点同步数据不能超过10s,否则的话主节点不进行任何操作,可以保持数据丢失在可控范围内
             配置淘汰不稳定节点,根据主从断开次数到达阈值就淘汰。  设置从节点优先级。提供哨兵选举使用
    2.配置文件修改replication中的 主机ip和端口号。 redis关闭重启也会自动选择主机
       复制配置文件。1.修改端口号 2.后台自启动开启 3.pidFile改对应端口  4.日志文件名改对应端口  5.RDB文件名+端口
    3.启动命令加入slaveof host ip配置主从复制
  链路主从复制：  主机-》从机1-》从机2-》从机3   虽然从机2的主机是从机1  但是1仍然是从机
    1.当主机1断开连接, 主机2手动输入 slaveof no one成为主机  其他节点会自动更新到这个主节点（哨兵没出来就是手动设置）。注意：主节点重新连接当从机.继续当主机数据会丢失
  Redis的CAP理论：
    redis是高可用性。不是强一致性。当网络断开,主从数据可能会产生很多不一致,但是当网络连接时,从节点会全量复制数据,然后增量复制数据。保证一致性
    全量复制：初次复制或无法部分复制会全量复制。
    增量复制：用于网络中断的情况后的复制,比全量复制效率高,但是当网络中断时间太长,主服务器没有完整保存中断的数据则会进行全量复制
---------------------------------------------------------------------------------------------------
哨兵模式(sentinel)：特殊的Redis节点        主从复制+3哨兵只能保证redis高可用  不能保证数据0丢失
  主从切换是主机宕机后手动设置一个从机当新主机,需要手动完成还会有一段时间无法使用.哨兵模式是主机宕机自动投票将一个从库切换成主库
哨兵模式是一个独立的进程。哨兵通过发送命令,等待Redis服务器响应,从而监控运行的多个Redis实例
  作用：   监控+消息通知+故障转移
       1.通过发送命令返回其主从机的运行状态   如果出现故障发消息给管理员
       2.检测到主机宕机,会自动切换slave为master.通过发布订阅模式通知其他从机修改配置文件。让他们切换主机
  缺点：一个哨兵来监控可能会出现问题。所以需要哨兵集群,各个哨兵直接还能互相监控.形成多哨兵模式
故障切换过程：      sentinel monitor mymaster 192.168.11.128 6379 2  监控host和ip的主机,当》=2个哨兵检测出不可用,进行failover
  假设主机宕机,哨兵1检测到了并不会立马进行failover(故障切换),仅仅是他认为故障了,称为主观下线,当后面的哨兵也检测到了问题,数量达到一定值,
  由一个哨兵发起投票,进行failover,成功后通过发布订阅,让其他哨兵的切换主机,这个称为客观下线
选举算法考虑因素：   1.优先级2.复制的偏移量(看谁复制的数据多)3.runID(标识符)4.主从机断开连接的时长
数据丢失
  1.异步复制：主从节点复制是异步的,如果复制过程中主节点宕机会产生数据丢失
  2.脑裂导致数据丢失：主机脱离正常网络,和其他从机无法建立连接,哨兵会认为主机宕机,然后选举新的主机,而客户端还没有切换新主机还在往旧主机写数据,
    新主机重启后哨兵自动设置成从机,新写的数据会丢失
解决数据丢失
  min-slaves-to-write 3
  min-slaves-max-lag 10
  1.三个从节点同步数据不能超过10s,否则的话主节点不进行任何操作,可以保持数据丢失在可控范围内
--------------------------------------------------------------------------------------------
缓存穿透和雪崩：
缓存穿透：（查不到）
  用户查一个数据发现redis没有(缓存未命中),然后取数据库查,也没有,如果大量这个请求就会给数据库带来很大负载.就是缓存穿透
  解决方案：
    1.用户查完之后在缓存中放一个空值,同时设置过期时间,再次查询直接返回redis的空值。缺点：空对象太多会影响性能,可能出现数据不一致。
    2.布隆过滤器：是一种数据结构,查询结果以hash存储,会在控制层先校验,不符合就会丢弃.避免底层存储系统压力
    3.接口增加校验拦截无效请求(用户权限校验和参数校验)
    4.网关Nginx配置,单个IP每秒访问次数做限制
缓存击穿：（能查到+缓存过期）
  当一个热点数据在不抗高并发时,如果key过期(访问数据库查询最新数据,并回写缓存),失效瞬间,高并发请求数据库导致数据库宕机
  解决方案：
    1.热点数据不过期：
    2.加互斥锁（分布式锁）：保证每个key只有一个线程查询后端服务,其他线程等待,将高并发压力转到分布式锁,因此对它考验很大
缓存雪崩：
  在某一时间段,缓存集中过期.Redis集群全部宕机。
  解决方案：
    1.并发小可以加锁排队
    2.手动设置过期时间,让缓存失效的时间点尽量均匀
    3.数据预热：在正式部署之前,将可能的被大量访问数据先访问一遍,提前加载进缓存.
    4.服务降级：比如双十一关闭一些不重要的服务,让他们走降级方法.来保证主服务的高可用性。
       1.参考日志自动降级 网络波动超时,可用率低。
       2.配置手动降级    出现错误 人工手动降级
热点数据和冷数据   热点数据放入缓存分担mysql压力,最少读取两次缓存才有意义,冷数据放入内存会被策略淘汰
缓存更新：
  1.删除redis中缓存
  2.更新mysql的数据
  3.查询的时候在增加redis的缓存
布隆过滤器：  基于bitmap实现的  是一种数据结构,可以用来查询某个东西是否存在。 查询结果是概率性的,不是确切的
  通过查询存不存在使用HashMap效率很高,但是它存储占用的空间也不小,如果上亿个值,hashmap的内存占用就很大了。
  布隆过滤器的原理是内存多个哈希函数,将一个key使用多个哈希函数运算,将多个结果的值对应放入bitmap中
  缺点：  当数据量非常大,一个新值通过多个函数运算发现对应位置值都为1.则可能出现不确切问题
  布隆过滤器越长,误报率越低, 哈希函数个数越多,效率越低,长度被占满的速率越快,而个数少了,误报率又会提高
数据大量插入：pipe mode(管道模型)     背景：原有客户端发送指令一问一答方式,多次网络交互,导致效率低
  采用非阻塞请求/响应实现异步处理,即使旧的请求没有响应,也可以发送新的请求。这样就可以把多条命令发送到服务器,而不用等待回复,在最后
  一步读取所有的回复,这就是管道。 而且服务器回复的是一个响应队列,如果大量命令,最好分批次发送。不然响应队列占用内存很大
pipeline原理是队列,先进先出,保证数据的顺序,默认个数是53个,累加到53条数据就会提交。但是具体能支持的个数和内存,缓冲区大小都有关系
查找指定模式的KEY
  1.keys指令
    优点：速度快
    缺点：数据量大会阻塞
  2.scan  scan 游标 match 条件* count 条数   Hscan Zscan Sscan 用于迭代hash,zset,set的元素
     游标0到0说明循环完毕。否则返回游标个数用于下次开始游标。  scan可能会有重复数据,需要客户端去重
    速度慢.无阻塞获取指定的key,由于无阻塞会有不准确的情况(因为执行此命令时会有其他命令执行)
Lua脚本：
  1.多个请求通过脚本一次发送,减少多次IO消耗
  2.原子操作,将整个脚本当成整体执行,中间不会插入其他命令,不需要事务
  3.脚本可以存在redis中  提供其他客户端使用

预防雪崩：
  事前：
    1.redis高可用：多设置几台redis。一台挂掉其他还能用（异地多活） 主从+哨兵+集群  避免全部宕机
  事中：
    1. ehcache本地缓存 所做的多级缓存架构的作用上了,ehcache的缓存,应对零散的redis中数据被清除掉的现象,另外一个主要是预防redis彻底崩溃
       多台机器上部署的缓存服务实例的内存中,还有一套ehcache的缓存 ehcache的缓存还能支撑一阵
    2.对redis访问的资源隔离
    3.对源服务访问的限流以及资源隔离
    4.Hystrix限流+降级 避免MYsql宕机
  事后：
    1.RDB+AOF重启恢复数据
    2.redis数据彻底丢失了,或者数据过旧,快速缓存预热,redis重新启动起来
--------------------------------------------------------------------------------------------------------------
Redis内存：  使用 info memory 命令可以查看内存信息
  1.used_memory：redis使用的内存总量(bytes字节数组长度)         2.used_memory_human：使用内存总量可读形式(具体的G或者M)
  3.used_memory_rss：占用物理内存总量
  4.used_memory_peak：redis使用内存总量的峰值                  5.used_memory_peak_human：峰值可读形式
  6.used_memory_lua：lua：引擎消耗的内存大小
  7.mem_allocator：redis使用的内存分配器,编译时候可以指定。默认 jemalloc   包含libc、tcmalloc、jemalloc
  8.mem_fragmentation_ratio： 3号(占用内存总量)/1号(使用内存总量)比值。内存碎片率
  mem_fragmentation_ratio>1:说明部分没有用于数据存储,而是内存碎片消耗,相差越大,说明内存碎片率越严重
  mem_fragmentation_ratio<1:说明redis使用了虚拟内存(媒介是硬盘)。硬盘操作速度慢于内存,Redis性能变差
Redis内存消耗的划分： Redis空进程占用used_memory_rss 大约3M 而used_memory大约800K  所以可以不计
  1.对象内存(数据)    123属于 used_memory (Redis分配器的内存总量,值Redis存所有数据占的内存)
     是redis中占用最大的一块,存储所有用户的数据,所有数据都采用key-value数据类型,每次都需要创建key对象和value对象,key对象是字符串
     而value包括String,list,hash,set,zset。每种存储方式使用长度,数据类型不同,所以占用的空间就不同
  2.缓冲内存   包括（客户端缓冲、AOF缓冲区、复制积压缓冲区）
     客户端缓冲：指的是所有接入到 Redis 服务器 TCP 连接的输入输出缓冲。
         输入缓冲区：输入缓冲区无法控制,最大空间1G,如果超过断开连接,而且不受最大内存限制,假设最大内存1G,已经存储900M输入缓冲区
                   使用了500M,最大内存已经超了,可能导致数据丢失或者OOM。输入缓冲区过大说明Redis处理速度跟不上输入速度,或者每次输入包含大量BigKey
         输出缓冲区：输出缓冲通过参数 client-output-buffer-limit 控制，
                 client-output-buffer-limit [hard limit] [soft limit] [duration]
                 hard limit：是指一旦缓冲区大小达到了这个阈值，Redis 就会立刻关闭该连接。
                 soft limit +duration时间：softLimit为64mb、duration为60。则只有当缓冲区持续60s大于64mb,Redis才会关闭该连接。
                 2.Redis默认对除了发布订阅和复制以外的普通连接没有限制,但是有大量慢连接接入,内存消耗也不能忽略,可以设置最大连接数
  3.自身内存
  4.内存碎片
        一块一块的不连续的小内存。一共加起来内存比如大于10M但是拿不出来连续的存储1M的空间。因为是断开的内存碎片
     解决：通过配置参数让内存碎片达到一定值进行自动清理,从而减少内存碎片
     默认内存分配采用
配置内存回收策略
  1.删除过期数据：
    Redis所有键都可以设置过期属性,进程内保存大量的键,由于精准删除过期键消耗大量的CPU,对单线程Redis消耗成本较高,所以采用两种策略回收
      1.惰性删除：
        不主动删除,当用户访问了过期对象的时候才进行删除
           优点： 节省CPU开销,不用的内存和TTL链表来维护删除信息
           缺点： 如果数据到期了但是一直没有被访问的话就不会被删除，会占用内存空间。
      2.定时任务删除：
        为了弥补第一种的缺点,redis内部维护一个定时任务,默认10s运行一次,定时任务中删除过期逻辑采用自适应算法,使用快、慢两种速率模式回收键
          流程：1.定时任务在每个数据库随机检查20个键,发现过期删除键进行删除。
               2.如果过期数超过25%,循环执行定时删除直到低于25%为止,或者时间超过25毫秒停止
               3.如果之前定时任务超时,则在触发内部事件之前再次以快模式运行回收过期键任务,快模式下超时时间为1毫秒,且2秒内只能运行一次。
          总结：快慢模式内部删除逻辑相同,只是执行的超时时间不同
  2.当内存使用情况达到maxmemory时触发内存回收策略
    1.volatile-lru：根据LRU算法删除设置了超时属性expire的键,直到腾出足够空间为止。如果没有可删除的键对象，回退到noeviction策略。
    2.allkeys-lru： 根据LRU算法删除键，不管数据有没有设置超时属性，直到腾出足够空间为止。
    3.volatile-lfu：根据LFU算法删除设置了超时属性expire的键,直到腾出足够空间为止。如果没有可删除的键对象，回退到noeviction策略。
    4.allkeys-lfu： 根据LFU算法删除键，不管数据有没有设置超时属性，直到腾出足够空间为止。
    5.volatile-random：随机删除过期键，直到腾出足够空间为止。
    6.allkeys-random： 随机删除所有键，直到腾出足够空间为止。
    7.volatile-ttl：   根据键值对象的ttl属性，删除最近将要过期数据。如果没有，回退到noeviction策略。
    8.noeviction：     不会删除任何数据，拒绝所有写入操作并返 回客户端错误信息，此 时Redis只响应读操作   默认
什么是LRU：                             操作系统的内存回收也是LRU LinkedHashMap也是LRU算法
    LRU是 Least Recently Used 近期最少使用算法,很多缓存策略都使用了这种策略进行空间的释放，
    类似的还有LFU（Least Frequently Used）最不经常使用算法
Redis内存用完会发生OOM,无法进行写操作,但是可以读。为了高可用可以设置最大内存,设置交换区,能使用hash,list等类型的尽量使用,不要一直用String
   建议设置和Redis内存一样大小的交换区,当需要内存大于当前系统可用内存时,redis虽然性能降低但是不会因为OOM被杀死
   设置最大内存,防止 redis所用内存超过物理内存,导致OOM被进程系统杀死,还可以使用LRU等删除策略释放空间
------------------------------------------------------------------------------------------------------------------
Redis线程模型
  Redis基于Reactor设计模式开发了网络事件处理器(文件事件处理器),因为该处理器是单线程,所以Redis是单线程模型
  多个套接字(socket)、IO多路复用程序 、文件事件分派器、事件处理器
  连接应答处理器：处理器会对客户端的连接请求进行应答，然后创建客户端套接字
  命令请求处理器：客户端建立连接后，向服务器发送命令，触发命令请求处理器执行
  命令回复处理器：执行命令获得相应的命令回复
  文件处理器使用IO多路复用程序监听多个socket(即将fd注册到epoll中),当监听到socket准备好应答(accept)、读取(read)、写入(write)、
  关闭(close)等操作时,就会产生与操作相对应的文件事件,多个文件事件可能并发出现,IO多路复用程序会将文件事件推送到队列中,有序交给文件
  分派器传送socket给处理器文件事件处理器会调用关联好的文件事件来处理事件,文件事件处理器以单线程运行
----------------------------------------------------------------------------------------------------------------
Redis集群   Redis集群不保证数据强一致,在特定条件下可能丢失写操作
  哈希槽：
    集群有16384个哈希槽,每个KEY通过CRC16校验后取模来决定放那个槽,集群的每个节点负责一部分hash槽
Redis分片(分区)
  分片就是将你的数据拆分到多个redis实例中,每个实例只包含所有键的子集
  分片作用：
    1.分区可以让Redis管理更大的内存,如果没有分区只能使用一台机器的内存
  分片方式：
    1.范围分片：
       0-1000进1实例 1001-2000进2实例   缺陷：需要维护一张范围表。效率低
    2.Hash分片：
       使用哈希函数如CRC32将键名转换成数字,进行取模运算,然后根据余数找到对应实例。几台实例就按几取余
  分区方案
    1.客户端分区：在客户端就已经决定数据会被存储到哪个redis节点或者从哪个redis节点读取
    2.代理分区：代理根据分区规则决定请求哪些Redis实例
    3.查询路由：客户端随机地请求任意一个redis实例，然后由Redis将请求转发给正确的Redis节点
  分区缺点：
    1.涉及多个key的操作通常不会被支持或比较麻烦
       例如你不能对两个集合求交集，因为他们可能被存储到不同的Redis实例（实际上这种情况也有办法，但是不能直接使用 交集指令）
    2.同时操作多个key,则不能使用Redis事务.
    3.分区使用的粒度是key，不能使用一个非常长的排序key存储一个数据集
    4.当使用分区的时候，数据处理会非常复杂
       例如为了备份你必须从不同的Redis实例和主机同时收集RDB / AOF文件
    5.分区时动态扩容或缩容可能非常复杂
       Redis集群在运行时增加或者删除Redis节点，能做到最大程度对用户透明地数据再平衡，
       但其他一些客户端分区或者代理分区方法则不支持这种特性。然而，有一种预分片的技术也可以较好的解决这个问题
集群方案
  1.官方集群方式(服务器路由)
      没有采用一致性哈希算法,采用槽的概念,一共分为16384个槽,请求发送到任意节点,都会被路由到正确的节点
    方案说明：
      1.通过哈希分片,每个节点均分存储一定哈希槽的数据,默认16384个槽,每个分片存储在互为主从的多节点上
      2.数据先写入主节点然后同步从节点(支持配置为阻塞同步)
      3.同一个分片的多个节点间的数据不保证一致性
      4.读取数据时,当key没有分配在该节点时会返回转向指令,指向正确的节点
      5.扩容时需要把旧节点的一部分数据迁移到新节点
      6.客户端可以指定数据,让他们走一个Hash槽。通过hash tag实现
    要点：
      1.redis需要开放两个端口,一个外部访问一个节点内通讯
    节点内部通讯机制：
      1.集中式：  todo
      2.gossIp式：
      节点通讯采用cluster bus通讯,用来进行检测,配置更新,故障转移授权。cluster bus采用一种二进制的gossip协议,
    分布式寻址算法：
      1.哈希槽算法：redis cluster使用
      2.hash算法：比较适合固定分区或者分布式节点的集群架构    缺点：扩容或缩容会导致缓存重建
      3.一致性hash算法(自动缓存迁移)：                    缺点：数据倾斜问题,无法保证数据均匀性
      4.一致性hash算法(自动缓存迁移)+虚拟节点(自动负载均衡)： 缺点：解决数据倾斜问题,为每一个设置多个虚拟节点(32或者更大),使得数据均匀分布
      应满足条件:平衡型、单调性、分散性、负载、平滑性
    优点：
      1.无中心架构,支持动态扩容。
      2.具有哨兵模式的监控和故障转移功能
      3.客户端不需要连接所有节点,连接任意一个节点即可
      4.高性能,直接连接服务器,免去中间代理层
      5.gossip协议占用更少网络宽带和处理时间,进行节点间的数据交换
    缺点：
      1.运维复杂,数据迁移需要人工干预
      2.只能使用0号数据库,不支持批量操作
      3.分布式逻辑和存储模块耦合
  2.基于客户端分配
    采用哈希算法将Redis数据的key进行散列，通过hash函数，特定的key会映射到特定的Redis节点上
    优点：
      1.服务端彼此独立无相互关联，每个redis像独立的服务一样
      2.非常容易线性扩展，系统灵活性强
    缺点：
      1.sharding 处理放到客户端，规模进一步扩大时给运维带来挑战
      2.不支持动态增删节点。
      3.服务端Redis实例群拓扑结构有变化时，每个客户端都需要更新调整。
      4.连接不能共享，当应用规模增大时，资源浪费制约优化
  3.基于代理服务器分片
    代理解析客户端的数据，并将请求转发至正确的节点，最后将结果回复给客户端
    特征：
      1.透明接入，业务程序不用关心后端Redis实例，切换成本低
      2.Proxy 的逻辑和存储的逻辑是隔离的
      3.代理层多了一次转发，性能有所损耗
    业界开源方案：
      Twtter 开源的 Twemproxy
--------------------------------------------------------------------------------------------------------------------
分布式问题
 分布式锁   实现方式：数据库,memcached,redis,zookeeper等   核心思想一致
   1.加锁：沙滩踩一脚留下脚印,其他线程看见脚印就认为加锁了,则等待
   2.解锁：把脚印抹去就是解锁
   3.锁超时：为了避免死锁,设置一阵风,单位时间后挂起,抹去脚印
 Redis实现分布式锁
   1.加锁  SET lock_key random_value NX PX 5000
      1.NX：键不存在进行插入
      2.PX：设置5000毫秒过期
      3.random_value 是客户端生成的唯一的字符串。
   2.解锁  解锁就是删除KEY的过程,但是需要对比客户端字符串保证是同一个客户端进行解锁操作
      1.取出key对应的客户端字符串  2.比对是否一致,一致就删除。   因为不是一个原子操作,则使用LUA脚本,保证原子性
   存在问题： 1.设置固定的过期时间,如果没有执行完或者网络延迟还是有问题
            2.不可重入锁
            3.如果加锁失败一直尝试加锁,太耗费性能
            4.主从模式下,主节点拿到没同步给从节点就锁宕机了,导致其他客户端也能拿到锁。两个客户端有锁。可能出现并发修改问题
   解决：
   1.引入 redisson 内部有一个watchDog看门狗,设置过期时间30s,每10s查看一次客户端有没有宕机,如果没宕机过期时间刷新30s。保证客户端全部执行完
   2.引入 redisson 内部使用hash 存储可重入次数,如果一个客户端 加锁使用incrby自增1,解锁decrby自减1实现可重入锁.当为0的时候删除key 解锁
   3.引入 redisson 使用使用订阅发布模式,加锁失败后订阅加锁的频道,当前锁解锁后发布一条解锁消息,订阅者看到解锁消息后重试
官方提出分布式锁方案  RedLock
  五个完全独立的Redis实例,1.客户端获取服务器端时间(毫秒) 2.使用相同key-value向五个实例获取锁,设置一个超时时间,超时时间远小于
  业务需要的时间如业务需要10s超时时间5-50ms。避免Redis已经宕机,但是客户端一直尝试获取锁.超时就跳到下一个节点,新当前时间减去
  1的时间小于超时时间,并且有一半以上客户端获取到锁,就认为加锁成功
   1.集群环境下,半数以上节点获得锁,才算加锁成功,否则就释放获取的锁
  特征：
    1.安全特征：互斥访问,永远只有一个客户端拿到锁  。2.避免死锁
    3.容错性：只要大部分节点存活就能正常提供服务
不推荐redis实现分布式锁,使用zookeeper实现  使用临时有序节点。同时也可以避免宕机而产生死锁。
  1.加锁时在对应目录下生成临时节点2.判断是否枷锁,判断有序节点序号最小的一个是否加锁3.释放锁,将临时节点删除



多路复用IO
集群分区    持久化数据扩容缩容
 内存划分
ssh  ifconfig-》ens33->inet   scp redis-6.2.1.tar.gz root@192.168.47.128     home/whj/桌面




