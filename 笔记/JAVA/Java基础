1.面向对象和面向过程的区别？
    1.面向对象：将一个功能分析有哪些实体,实体中属性和方法.通过方法调用完成功能。 优点：复用性高,容易扩展  缺点：创建对象实例需要消耗性能
    2.面向过程：将一个功能自顶向下拆分,逐步细化的一个过程                    优点：性能高           缺点:复用性和扩展性低
2.JAVA(面向对象)的特性
    1.封装:将具体功能封装成方法,提高代码复用性
    2.继承:使子类继承父类的属性和方法,既可以直接使用也可以重写覆盖
    3.多态原理(invokeVirtual)
        1.重写(运行时多态):运行时才确定具体掉用的方法,
        2.重载(编译时多态):方法名相同,参数列表不同(参数个数,参数类型,参数顺序)
        1.通过栈帧中对象引用找到堆中类对象  2.分析对象头找到方法区的Class详细信息  3.每个类都有一个虚方法表(vTable)在链接阶段就生成好了  4.查找虚方法表得到方法具体地址  5.执行方法字节码
    4.虚方法:Java种所有被重写的方法都是虚方法
    invokeStatic执行静态方法  invokeSpecial执行init方法(静态属性静态代码块)  invokesVirtual执行虚方法   invokeInterface执行接口
3.构造方法相关问题
    1.子类调用构造方法默认会执行父类的无参构造(因为可能用父类的属性和方法,所以必须先创建父类对象在创建子类对象)
    2.super()调用父类构造this()调用重载构造,他们都只能放到构造方法第一行,不能同时出现
4.static和final关键字
    static：
        1.修饰(变量、方法、类、代码块)   静态代码块优化性能:比如加载文件可以写在静态代码块中,只加载一次  类变量存随类存放在方法区  访问无需创建对象  直接类名.方法名 调用
        2.静态优先于对象的加载,所以不能使用this和super等关键字
    final：
        1.修饰静态成员必须进行初始化(立即赋值或者静态代码块赋值.只能赋值一次)
        2.final多线程下作用:通过内存屏障 防止线程获取到未初始化的默认变量
5.Java 中创建对象的几种方式？
    1.new关键字    2.反射创建    3.clone拷贝    4.反序列化
6.深拷贝和浅拷贝的区别(其实是针对Object和Array这种引用类型的)
    浅拷贝：只是复制指针,两个对象指向一个内存。修改新对象会影响到原对象
    深拷贝：深拷贝会开辟内存复制对象,两个对象修改互不影响
    深拷贝实现：
        1.clone方法内部包含引用对象则需要链路上全部重写clone方法           性能最高,但是容易一环漏掉产生问题
        2.通过第三方工具实现 cglib、commons-beanutils都提供了深拷贝方法   性能中等,使用方便   (项目中如果存在工具类就没必要换)
        3.反序列化创建的对象是深拷贝                                    性能很低,不推荐
7.值传递和引用传递
    值传递：基本数据类型都是值传递  传递的是值的副本                  特殊：数组都是引用传递
    引用传递：引用数据类型传递的是地址 修改对应数据会导致原数据变动      特殊：String存在字符串常量池中,副本改变不会影响原本的值
8.序列化和反序列化： 对象和字节序列转换过程
    序列化反序列化：对象和二进制流的相互转换
    注意： 1.transient字段不序列    2.建议手动声明serialVersionUID,防止编译器不同产生报错   3.选择序列化工具 看功能、性能、兼容性 常用jackson、fastjson、kryo
9.接口和抽象类
    抽象类：单继承
        1.只有声明没有实现,子类必须重写,所以不可以使用private和default这种子类可能访问不到的修饰符(编译报错！！)
        2.子类继承抽象类必须实现父类抽象方法或者将自己设置为抽象类    抽象类不可实例化 编译报错！！
    接口： 多继承
        1.接口的作用是解决多重继承的,一个类可实现多个接口,接口种的常量默认都是public static final 不可修改,方法默认public abstract来修饰
        2.接口种所有变量都是静态常量 所有方法都是抽象方法不能有方法体(可以存在默认方法default和静态static方法,有方法体通过类名和方法名调用)
    相同点：都不可以实例化
10.数据类型：  整数型默认int  浮点型默认Double
    1.整形默认0（byte 1字节 ，short 2字节，int 4字节，long 8字节） 浮点型默认0.0（float 4字节 double 8字节） 布尔型默认false boolean 1字节 字符型默认空 char 2字节
    2.自动类型转换：byte->short<->char—> int —> long—> float —> double    如果不按这个顺序编译报错(需要强制类型转换) char转换按照ASCII码转换
Integer
    1.Integer 有缓存数组-128<=value<=127 超过范围才会new  所以不建议使用==比较
    2.new Integer(123) 每次都会新建一个对象；  Integer.valueOf(123) 会使用缓存池中的对象
float、Double:
    因为浮点数采用尾数+阶码所以  基本数据类型用==,包装类型用equals比较出问题
    解决： 1.在一个范围内就认为相同      2.采用BigDecimal进行运算比较操作
BigDecimal
    1.new BigDecimal传入double会产生精度问题,建议将构造方法改为valueOf！  传入int、long、String不影响可以使用构造方法
    2.两个BigDecimal使用equals可能会产生问题,因为会比较精度   建议使用compareTo比较
    3.BigDecimal做除法运算一定要处理精度和舍入模式,因为可能产生无限小数
    4.当BigDecimal输出String类型使用toString会采用科学计数法(E+)   可以使用toPlainString不采用科学技术
Char是否可以存中文字符
    Java的编码是UTF16,一个中文占两个字节. 当编码改成UTF8一个中文占三个字节. char采用Unicode包含中文所以UTF16下可以存中文,而UTF8情况下会变成？
为什么包装类型内部值都是用final修饰？ 因为final也采用读写屏障来保证多线程下安全,防止线程拿到未初始化的默认值
11.Switch上可以使用 char、byte、int、String、enum  不能使用 float、double、boolean
12.equals 和 hashCode 和 ==
    equals:引用类型默认调用Object的equals使用==比较地址。 String重写后会先比较地址,地址一致返回true不一致会遍历字符数组,全一模一样也会返回true否则返回false  Integer则是转成int进行==
    ==：基本数据类型比较值是否一致,引用数据类型则是地址
    hashCode引入背景：集合中判断重复如果全用equals 效率很低,hashcode是一个优化,先通过hash计算位置然后找到使用equals判断,提高效率 也就是说hashCode和equals都相同就认为重复
    问题：集合中如果key的hashCode不相同就会认为不存在,所以可以一直put
    解决：所以重写equals必须要重写hasCode
13.常用函数：
    Math.floor()   表示向下取整，返回double类型   （floor---地板）
    Math.ceil()    表示向上取整，返回double类型    （ceil---天花板）
    Math.round()   四舍五入，返回int类型
14.你对泛型有多少了解？
   1.代码更加简洁,程序更加健壮(如果有类型转换异常编译会报错),平时在集合经常使用泛型.
   类型擦除：在字节码中实际存储和取出都是使用的Object,在取出时进行类型强转
   只支持封装类型,不能使用基本数据类型







来讲讲什么是注解？
   1.代码中的特殊标记,可以在编译,加载,运行时执行相应的处理    原生@Overried、@FunctionalInterface
   2.自定义注解自动继承 Annotation(元注解),
   3.元注解专门的一些注释
       1.@Target ：用来限定注解的位置,比如接口,属性,方法等  一般来说使用方法
       2.@Retention：用来表示注解的生命周期,包括 源文件阶段、编译到class阶段、运行阶段       默认CLASS
            源文件阶段：不会参与到编译和运行 一般就是注释作用
            编译到class阶段：编译期间可能会做一些处理,运行期读不到    Lombok就是这个编译阶段完成的get\set方法嵌入  继承一个类实现方法
            运行阶段：一般配合AOP 通过反射获取到注解然后执行相应的操作
       3.@Documented注解，是被用来指定自定义注解是否能随着被定义的java文件生成到JavaDoc文档当中。
       4.@Inherited注解，是指定某个自定义注解如果写在了父类的声明部分，那么子类的声明部分也能自动拥有该注解。@Inherited注解只对那些@Target被定义为ElementType.TYPE的自定义注解起作用。

SLF4J、JCL 和Log4j、LogBack区别？
   1.Log4j、LogBack属于日志系统,如果系统中出现多个日志系统需要分别维护(并且Log4j出现过漏洞 导致JNDI注入问题)
   2.SLF4J、JCL 属于日志框架,有利于维护,切换日志系统。与底层日志系统无关,有利于任意更换日志系统


JAVA体系结构
    1.java程序设计语言(语言 C/C++)    2.java class 文件格式     3.java应用编程接口(Java API)     4.JVM
    使用java语言调用Java API编写Java文件 编译成Class文件  提供JVM执行
访问修饰符
    public:   当前类、同包内(同包子类、同包其他类)、不同包子类  其他包 都可以访问
    protect： 当前类、同包内(同包子类、同包其他类)、不同包子类                              除了当前类和同包下和不同包子类 其他都不可以访问
    default： 当前类、同包内(同包子类、同包其他类)、                                      除了当前类和同包下都不可访问
    private： 当前类                                                                除了当前类都不可访问
String、StringBuilder、StringBuffer 区别  都是使用char数组,后两个区别就是有没有加锁
    String：包装类是一个类,内部使用 private static final char[] value;  适合 少量字符串操作 因为不可变字符串所以+会一直创建字符串  垃圾回收时才会把没有引用的回收掉  效率低
    StringBuilder:速度快但是线程不安全,适合单线程字符串频繁操作使用。 是在原有字符串上做更改
    StringBuffer:速度比builder慢但是线程安全,适合多线程字符串频繁操作使用  是在原有字符串上做更改
    他们扩容机制(区别是否有锁): 无参构造默认存放16个字符,有参String类型默认String长度+16个字符,有参int类型默认是设置的int值大小 。扩容大小为原始*2+2   之所以加2是因为拼接后末尾存在多于字符
    效率：  String + < String concat < StringBuffer  <StringBuilder         StringBuffer线程安全和String final修饰线程安全
Comparable 与 Comparator
    都是排序方法,用法:实体类实现 Comparable<T> 重写compareTo方法即可进行调用使用    String和Integer自己实现了Comparable可以直接使用  自定义类或者List集合可以使用Comparable进行排序
    不支持自排序的比如二维数组使用Comparator 匿名类的方式重写排序方法


5中IO模型和零拷贝








