SpringMVC：
    拦截用户请求,DispatcherServlet承担中介职责将用户请求通过HandlerMapping去匹配controller,然后controller执行具体操作
Mybatis：
    是对jdbc的封装,通过配置文件关联到实体类Mapper文件,mapper中配置 sql的映射。每次交互中通过sqlSessionFactory拿到一个sqlSession，再执行sql命令

架构分层：
    1.视图层：视图层和控制层结合紧密,视图层主要是页面的展示
    2.控制层：控制要调用的业务层代码
    3.业务层：业务代码的逻辑处理，可能会涉及到持久层接口的调用
    4.持久层：负责与数据库交互,进行CRUD的操作
SSM原理流程：
    1.客户端发送请求到DispatcherServlet
    2.DispatcherServlet控制器查询HandlerMapping,找到对应Controller
    3.Controller调用Service进行业务处理,处理中可能涉及到去DAO进行数据库操作。最终将响应返回给客户端
低耦合高内聚： https://blog.csdn.net/ws9029/article/details/116454153
    低耦合：模块和模块之间交互不可避免,交互性低也就是耦合低才能让模块直接增加独立性。实现多模块可拆卸
    高内聚：功能内聚,一个模块只需要做自己负责的事情,不过分关心其他事情。 保证模块拆卸过程中对功能控制的精准性
    总结：低耦合高内聚的思想其实就是将系统分成多个模块分而治之的思想。对系统来说将会有更高的可靠性.系统升级微服务也轻松一些
Spring： 开源的轻量级框架,简化应用程序开发,降低耦合度。
    1.IOC(控制反转):让Spring帮助创建对象以及管理对象之间的依赖关系,降低对象间耦合度
        容器初始化过程：
            1.XML方式
                1.创建 ClassPathXmlApplicationContext 调用构造方法时,
                    一、先是调用顶层父构造方法对部分属性初始化
                    二、调用父类setConfigLocations设置传入属性值,Spring配置文件路径
                    三、调用父类refresh方法对xml中bean进行载入封装
                        1.判断是否存在Spring容器,存在销毁然后创建,保证refresh创建的时新的容器
                        2.通过路径将XML解析成文档对象,然后封装程key-value存入一个Map中,这个过程加锁保证线程安全. key为String value为BeanDefinition（内部封装 单例、多例、参数）
            2.注解方式
                1.配置自动扫描路径,启动时会根据路径对所有类进行扫描
                2.直接将含注解的bean注册到容器中
        Bean实例化参数配置： //todo 了解动态代理和CGlib代码 搭配作用域scope使用
            1.scope(默认单例)  注解方式：@Scope(value = WebApplicationContext.SCOPE_SESSION,  proxyMode =ScopedProxyMode.INTERFACES)
                1.singleton：单例 ：每一个bean只有一个实例。Spring创建就会被加载,生命周期和Spring一致。
                2.prototype：多例 (懒加载,用的时候才走初始化用完就会销毁)：每次对bean的请求都会创建一个实例
                3.request：请求,每次HTTP请求都会生成一个bean,表示在一次HTTP内有效
                4.session：在同一个session内,使用一个bean
                5.global session：在一个全局session内 使用一个bean
            2.id、class：id自定义一般为类开头字母小写、class为全路径名
            3.init-method 初始化方法
            4.destroy-method 销毁方法
        Bean实例化方式
            1.无参构造
            2.工厂静态方法
            3.工厂实例方法
        依赖注入： 优点:将对象的依赖关系交给容器自动化完成,解耦合    缺点：实例bean源码复杂,不易学习。 通过反射创建对象有损耗,但是从便利性和实用性这点损耗可以忽略
            1.构造方法：优点：自动寻找bean进行注入 缺点：可能存在多个构造方法,不方便维护。 但是IDEA仍然推荐这种方法进行代码书写(优点：保证依赖不为空避免空指针)  如果一个依赖有多种实现推荐使用set注入
            2.setter方法：优点：可以继承、设置默认值、用的时候进行注入  缺点：无法在对象构造完成后立刻使用 需要调用set方法  可以搭配Required注解强制要求使用者注入该属性
            3.接口注入：使用较少,因为强制被注入对象实现接口
            4.P指针注入(本质就是set)：配置文件使用较多 优点：代码整洁  缺点：可维护性不高,如果属性多会导致配置过长
        依赖注入注解：
            1.Autowired:按类型自动装配
            2.Qualifier:不能单独使用,配合 Autowired按名称自动装配,需要Autowired后面增加装配名称
            3.Resource：默认按名称装配,找不到按照类型装配！  Spring提供注解 但是实现需要引入第三方工具 javax.annotation.jar
            4.Value：⽤于注⼊基本类型,可以标注在成员变量上,set方法上。不能标注构造方法上！！
            5.Bean：作用在方法上,将方法返回的类注入到容器中
            6.PathVariable：用来接收路径参数的注解
            6.Configuration：等同于Bean.xml,通过annotationConfigApplicationContext加载,
            7.Component:等同于application.xml,通过ClassPathXmlApplicationContext加载
            8.Repository|Service|Controller:DAO、业务层、控制层特殊的注解,作用和Component相同
            9.Configuration和Component区别：
                官方解释：1.加载方式不同   2.Configuration会进行cglib代理(简化就是获取bean 一种获取到的是代理对象  一种获取到的原始对象)
    2.AOP(切面编程): 代码重复部分抽出来,通过动态代理技术在不改变源码基础上进行代码增强  常用于：权限控制、日志处理、事务等
        1.相关注解
            1.Aspect：切面
                1.Before前置通知：目标方法调用前调用通知方法
                2.After后置通知：目标方法调用后调用通知方法     (始终执行)
                3.After-returning最终通知：目标方法成功执行之后调用通知方法  (异常不执行)
                4.After-throwing异常通知：目标方法抛出异常后调用通知方法
                5.Around环绕通知：目标方法调用前和调用后都调用通知方法
                区别：
                1.环绕通知和最终通知顺序：后置通知是在finally之前执行,最终通知是finally之后执行
                2.后置通知和最终通知顺序：会先执行最终通知然后才执行后置通知。。。是个大坑 要注意   所以环绕通知和拆开前后置通知 搭配最终通知结果不同
            2.JoinPoint：连接点,Spring只支持方法类型,也就是说拦截到的方法。 实际上连接点也可以是字段或者构造器
            3.Pointcut：切点,
        1.当bean实现接口时使用JDK Proxy,没有实现接口使用CGLib Proxy  可以通过配置强制使用CGLib
        AOP过程：

    3.事务控制
    4.方便集成测试
    5.降低API使用难度,对很多API进行封装提供Template调用
单例多例模式下线程安全问题：
   单例：方法局部变量、ThreadLocal是线程安全的,但是全局变量(普通变量和对象)、静态变量存在线程不安全情况
   多例：每次创建一个新对象,不存在多线程共享一个Bean。所以ThreadLocal、局部变量、全局变量(普通变量)都是线程安全的、只有全局变量(对象类型)、静态变量存在线程不安全情况
   为什么Spring中controller、service、dao却线程安全？
       答：因为通常情况下我们都是调用他们内部的方法,对于JVM虚拟机栈来说是线程私有的,不涉及线程安全问题。
代理模式：
   作用： 1.可以对方法进行增强,例如AOP实现增强方法   2.控制是否可进行目标方法的调用
   静态代理： 需求变了改代码实现功能    优点：容易理解,使用方便 2.如果改动较大,大部分类都要修改
   动态代理： 增强方法写在代理类中,只需要将业务代码生成一个代理对象即可   优点：耦合度低,灵活度高便于维护
       JDK Proxy: 实现 InvocationHandler接口 重写invoke方法进行增强。 基础是反射机制,因为执行方法调用method.invoke。创建实例调用proxy.newProxyInstance
       CGLib Proxy：实现 MethodInterceptor接口 重写intercept方法进行拦截增强。 原理是创建目标类子类,setSuperClass实现,覆盖其中方法进行增加。所以final方法不可用
       差异性：
           1.JDK代理是JAVA原生提供的,JDK8性能提高很多而且写起来方便,但是只能对接口进行增强   CGLib都可以进行增强,Spring提供的还需要引入ASM.jar,基于ASM(字节码操控框架)实现
           2.JDK代理直接编译生成字节码加载到JVM而CGLIB使用ASM效率较低,但是执行方法JDK使用反射而CGLIB使用FastClass为代理类和被代理类各一个类,通过index确定调用方法  整体：CGLIB速度快
           3.JDK代理对接口处理,所以不支持私有、保护、final。接口支持static但是没有实现方法不能代理    CGLIB创建子类方式：所以私有、保护、final、static等方法也不可代理
Spring Bean： 生命周期
     1.没有Spring管理通过JVM管理的对象,生命周期只有 实例化创建  然后垃圾回收销毁
     2.Spring管理的的对象生命周期
         1.实例化(Instantiation):
               1.BeanFactory :是在使用到Bean的时候才会实例化Bean
               2.ApplicantContext: 管理的Bean在容器初始化的时候就回完成Bean实例化
         2.属性赋值 Populate
         3.初始化 Initialization
         4.销毁 Destruction









































