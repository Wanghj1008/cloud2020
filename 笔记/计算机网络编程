计算机网络：
    将地理位置不同、具有独立功能的多台计算机,通过通讯线路连接起来。
    网络操作系统、网络管理软件及网络通讯协议的管理和协调下,实现资源共享和信息传递的计算机系统
网络编程：
    在网络通讯的协议下,实现网络互连下不同计算机运行的程序间可以进行数据交换
    三要素：
        1.IP：唯一标识计算机。计算机的标识号,用来区分计算机
            1.IPV4：按照TCP/Ip规定,每个IP为4字节的二进制形式地址,不好记所以一般写出十进制,192.168.1.1。点分十进制表示法
            2.IPV6: 由于互联网人数变大,IPV4不够用了,所以扩大地址采用16字节,采用16进制数。解决Ip资源数量不够问题
            3.ipconfig 查看本级IP地址
            4.ping IP：检查网络是否连通
            5.InetAddress类使用  该类表示internet协议IP地址    java.net包下
                1.getByteName(String Host)：获取与Host相对应的InetAddress对象 |参数可以是主机名也可以是IP地址
                2.getHostName：通过InetAddress对象获取的主机名
                3.getHostAddress：通过InetAddress对象获取IP地址
        2.端口号：唯一标识应用程序。每台计算机很多应用程序,使用端口号来区分应用程序
            1.取值范围0~65535.其中0~1023之间的端口用于一些知名的网络服务和应用
            2.普通应用需要使用1024以上的端口号,如果端口号被其他应用占用,会导致启动失败
        3.协议：通过计算机网络可以实现多台计算机连接。进行连接通讯的时候需要遵守一定的规则。对数据传输格式,传输速率,传输步骤做了统一规范
            1.UDP协议：用户数据报协议    无连接通讯协议
                1.发送端在发送时不会确定接收方是否存在就发送数据
                2.接收方收到数据,也不会反馈给发送方
            2.TCP协议： 传输控制协议      TCP协议是面向连接的通讯协议
                1.发送数据前需要发送端和接收端建立连接,然后在传输数据,保证可靠无差错的数据传输
                2.由客户端像服务器端发送请求连接,每次连接创建需要经过‘三次握手’
                    三次握手：TCP协议中,在发送数据的准备阶段,进行三次交互,保证可靠连接
                        1.第一次握手：客户端向服务器端发送连接请求：等待服务器端确定
                        2.第二次握手：服务器端向客户端发送一个响应,表示收到了请求
                        3.第三次握手：客户端再次向服务器端发送确定请求,确定连接
                3.断开连接
                       （1） TCP客户端发送一个FIN，用来关闭客户到服务器的数据传送。
                       （2） 服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。
                       （3） 服务器关闭客户端的连接，发送一个FIN给客户端。
                       （4） 客户端发回ACK报文确认，并将确认序号设置为收到序号加1。
            总结：
                1. UDP协议消耗资源小,通讯效率快,通常用于音频、视频、和普通数据传输   不能保证数据的完整性
                2. TCP协议保证数据传输安全      通常用于文件上传、下载文件、浏览网页等
A给B发送消息： 1.到达A的TCP发送缓冲区 2.网络传输数据 3.到B的接收缓冲区 4.B拿到属于自己的数据
五种IO模型：
    1.阻塞IO：传统IO,在读写数据的时候会发生阻塞
       1.用户发起Read操作后,内核将数据准备好之前,系统会一直阻塞
       2.内核数据好了,将数据从内核拷贝到用户内存(拷贝过程阻塞进程),然后内核返回结果,解除阻塞状态
       典型的阻塞例子：
          所有socket默认使用的都是阻塞IO的方式  如果数据没有就绪,就一直阻塞进程
    2.非阻塞IO(NIO)
       1.用户发起read请求后,如果内核中数据没有准备好,直接返回错误
       2.用户看到错误就知道数据没准备好,然后继续发送read请求,当内核中数据就绪,就将数据拷贝到内存中,然后返回
       在非阻塞状态下,recv()接口被调用后立即返回。
         1.返回值大于0：数据接收完毕,返回值是接受到的字节数
         2.返回0：表示连接正常断开
         3.返回-1且error等于资源暂不可用：数据还没有接收完毕
         4.返回-1且error不等于资源赞不可用：表示在recv过程中遇到其他错误
    3.多路复用I/O :  非阻塞IO需要用户不断询问是否就绪,会提高CPU占用,而且只是检测的作用,也可以使用多路复用一个线程检测多个fd
       内核用一个线程轮询多个socket的状态,当数据就绪后,将数据拷贝到内存,然后返回
       比较非阻塞IO：非阻塞是用户线程进行的,而多路复用是内核完成的。效率比用户线程高
       缺点：多路复用IO是通过轮询方式检测数据是否就绪,并且进行逐一操作,如果一个连接数据很大,会导致后面数据阻塞时间较长
       问题： 使用多线程和阻塞IO实现类似效果？   每个socket对应一个线程,会造成大量资源占用,如果大量长连接,降低性能
    4.信号驱动I/O     IO复用解决了一个线程监控多个fd的问题,但是轮询大部分情况都是没准备好。所以产生信号驱动,我准备好了通知你
       当内核数据准备好时,发送可读信号给线程,线程收到信号发送发送IO请求
          1.首先我们允许套接字接口进行信号驱动I/O，并安装一个信号处理函数
          2.线程发送监控信号后即可返回,不会阻塞。所以这种方式也可以一个线程监控多个fd
    5.异步I/O  信号驱动中,用户收到绪信号然后发送IO操作进行读写,而异步IO会直接进行读写然后通知用户已完成.不需要用户调用读写操作
       IO操作的数据准备和拷贝都不会阻塞客户端,内核完成通知用户操作已完成
       注意：异步IO是需要操作系统的底层支持，在Java 7中，提供了Asynchronous IO
多线程：一个客户端创建一个线程,模式简单但是资源占用很大,线程达到上限会造成瓶颈,可能会导致服务器崩溃
线程池：解决一直创建产生的问题,但是长连接占满线程,会导致一段时间不可用,所以线程池适合大量短连接应用。
因此两种高性能IO设计模式：
  1.Reactor反应器：  多路复用IO就是采用Reactor反应器设计,为了提高效率可以不按顺序交给多线程或线程池处理,Redis多线程使用方式
    会先对client注册事件,一个线程轮询每个client是否有事件发送,有事件发送时顺序处理事件,完成后继续轮询
  2.Proactor前摄器：异步IO模型采用的就是Proactor模式。Java AIO使用的这种
    当检测到有事件发生时,异步交给内核线程去处理,内核线程完成IO后,给用户发送已完成通知。
同步通信:
  调用者发起调用,一直等到有结果返回。就是由调用者主动等待这个结果.
  优点：
    1.传输效率高、速度高（因为一大串数据只需要一个前导码，数据有效率高）
    2.适用于高速大容量数据传输
异步通信:
  调用者发起调用直接返回,被调用者根据状态,通知调用者或通过回调函数处理这个调用
    1.一组数据发送间隔任意，自由度高
    2.硬件简单，容错率高
区别：
  1.时钟频率。
   同步通讯：相同时钟频率 发送持续的流
   异步通讯：不要求时钟频率同步,发送完一个字节可以间隔任意长时间发送下一个字节