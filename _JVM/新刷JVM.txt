sun公司的 hotspot 虚拟机     还知道IBM的J9虚拟机。apache的 harmony

定义：
   Java virtual Machine- java程序的运行环境(java 二进制字节码的运行环境)
好处
   1.一次编写,到处运行 (JVM屏蔽了字节码跟底层操作系统的差异,对外提供了一致的运行环境)
   2.自动内存管理,垃圾回收机制(C|C++没有)
   3.数组下标越界异常检查(防止数据覆盖)
   4.虚方法表 实现多态
缺点：
   降低了程序员对OOM的解决能力

JVM-》JRE(JVM+基础类库)-》JDK(JRE+编译工具)-》开发JavaSE程序(IDEA+JDK)->开发JavaEE程序(IDE+JDK+应用服务器)
JRE是Java运行时环境：比JVM多出来一些java类库(java.io java.lang java.util)
JDK是Java开发工具包  集成了javac编译器  jar打包工具  javadoc文档生成器
----------------------------------------------------------------------------------------------------------
JVM整体结构：
  上层
    1.类装载子系统(类加载器)字节码文件通过类加载器生成大的Class对象
  中层  JVM内存结构（运行时数据区 Runtime date Area）   其中方法区和堆是多个线程共享的,而Java栈,本地方法栈和pc寄存器是线程私有的
    1.方法区(method Area)元数据区:        有可能造成OOM                      有GC
    2.堆（heap）:                       有可能造成OOM                      有GC
    3.Java栈(虚拟机栈):                  有可能造成OOM(内存溢出、栈溢出)       没有GC
    4.本地方法栈：:                      有可能造成OOM(内存溢出、栈溢出)       没有GC
    5.程序计数器(PC寄存器)：                没有OOM                         没有GC      执行速度最快的内存区域
  下层
    1.执行引擎(计算机只执行机器指令,而字节码文件不等同于机器指令,执行引擎将字节码文件翻译成机器语言)
      1.解释器
      2.编译器(JIT编译器)
      3.垃圾回收器
    2.本地方法接口
    3.本地方法库
----------------------------------------------------------------------------------------------------------
类加载器
----------------------------------------------------------------------------------------------------------
运行时数据区
1.程序计数器(物理上是通过寄存器实现的  所以也叫PC寄存器)
  用来存储当前指令的地址,通过改变计数器的值来获取下一条指令,由执行引擎读取下一条指令。解释器解析成机器码交给CPU执行
优点
  1.占用空间最小,执行速度最快，没有内存泄露，线程私有
  2.保存当前线程指令地址,如果是本地方法  计数器为undefined
使用PC寄存器存储字节码指令有什么用（为什么使用PC寄存器记录当前线程的执行地址）？
  并发执行多个线程。CPU需要不停切换各个线程,切换回来需要知道从哪开始。并且JVM解释器需要改变PC寄存器的值来确定下一条指令
PC寄存器为什么被设置为线程私有的？
  因为多个线程的话如果共用一个PC寄存器存储。A如果执行了3行,CPU切换到B则会直接从3开始,会产生问题。所以需要每个线程独有一份
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
2.虚拟机栈  堆是存储的单位
   先进后出,以栈帧为单位,线程私有的,生命周期与线程相同,虚拟机操作指令只针对栈顶的方法,执行引擎运行当前字节码指令是针对当前栈帧操作的

栈：每个线程运行所需要的内存
栈帧：每个方法运行时需要的内存(参数、局部变量、返回地址 都需要占用内存)

栈帧内部结构： 1.局部变量表(local variables)本地变量表：
                  1.存放了编译期的基本数据类型和引用类型
                  2.存储单位用slot(槽)表示,32位占用一个槽。像long double这种64位占用两个槽
                  3.在进入方法的时候  一个栈帧中的局部变量表所分配的槽就是固定的,运行期间不会改变
               2.操作数栈(operand stack)表达式栈：
                  在操作数栈里写入数据或提取数据
               3.动态链接(Dynamic linking):
                  指向运行时常量池的方法引用
               4.方法返回地址(return Address)：
                  一个栈帧的返回结果指令地址  传给下一个栈帧
               5.一些附加信息
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
3.本地方法栈  本地方法运行所需要的内存就是本地方法栈
   本地方法栈和虚拟机栈类似  只不过虚拟机栈执行的是JAVA方法  本地方法栈执行的是本地方法
   本地方法：
      java有一些限制,不能直接跟操作系统底层打交道,所以需要用C或C++编写的本地方法来真正于底层操作系统打交道
   本地方法有哪些
     wait  notify  hasCode
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
4.堆：通过new关键字创建的对象都使用堆的内存     堆是虚拟机管理的最大的一块内存
     特点：
       1.线程共享的,堆中对象都需要考虑线程安全的问题
       2.有垃圾回收机制  (不再使用的内存就会垃圾回收)

堆内存诊断           排查堆内存溢出尽量将最大堆内存设置小一些,可以尽早发现堆内存溢出问题
  1.jps工具
     查看当前系统中有哪些Java进程    直接在IDEA的Terminal命令窗口中 输入jps 可以返回进程号
  2.jmap工具（只能检测某一时刻的堆内存占用情况  ）
     查看堆内存占用情况     jmap -heap 进程号  查看堆内存
  3.jconsole工具
     图形界面的,多功能检测的工具,可以连续检测.  可以检测线程数量,CPU占用率,堆内存和加载类的数量   Terminal命令窗口jconsole
  4.jvisualvm  可视化虚拟机   和jconsole类似,但是有一个堆抓取工具可以将占用对的对象进行排序查看,以此来排查优化堆内存

几乎所有对象实例都存放堆中,但是随着JAVA的发展,栈上分配,标量替换的方式
  栈上分配：如果一个变量只在当前方法有效,那么可以考虑将它直接在栈中分配内存做处理
  标量替换：一个对象就是一个聚合量,如果可以确定这个对象不会被其他线程使用,那么我就可以把这个对象拆成多个标量在栈上进行分配和读写,后续还可以对 对象的创建进行优化
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
5.方法区
  1.6内存结构 ：
    方法区占用JVM的堆内存,使用的 PermGen(永久代)的实现。
      1.class(类的信息)
      2.classLoader(类加载器信息)
      3.运行时常量池 ：其中最重要的就是字符串常量池StringTable(字符串常量池)
  1.8内存结构
    方法区占用本地内存,使用 Metaspace(元空间)的实现
      1.class(类的信息)
      2.classLoader(类加载器信息)
      3.运行时常量池 其中StringTable被移到堆中    JDK6存放永久代只有FULL GC才会进行垃圾回收,效率低,而且容易造成永久代内存溢出。而放入堆中 vener GC就会进行清理,
StringTable(字符串常量池)特性   hastable结构,不能扩容
  1.字符串懒加载,用到先查询串池,没有则创建
  2.字符串变量拼接 字节码中使用的StringBuilder  字符串常量拼接是在编译器就会优化
  3.可以使用 intern
     1.8尝试将字符串放入串池,如果有不放入,没有就放入并且返回串池中的对象
     1.6尝试将字符串放入串池,如果有不放入,没有就复制一份放入并且返回串池中的对象
  4.当堆内存紧张时,不用的字符串常量也会被垃圾回收
例子：
  String s1=“a"; String s2="b";  String s3="ab";  都是存放在字符串常量池中的
  String s4=s1 + s2;
    相当于new StringBuilder().append(s1).append(s2).toString();  new String("ab");堆中
  String s5="a"+"b"; javac在编译期间的优化,编译期间结果就是ab了,去常量池中寻找,没有就创建。而s1和s2可能被修改   s1,s2是变量可能被修改,所以在运行期间用Stringbuilder拼接
StringTable调优  (底层是hasTable)
  1.当系统中字符串常量非常多,可以适当调大字符串常量池中桶的数量,减少hash冲突  默认6w个   -XX:StringTableSize
  2.当系统中需要大量的字符串,并且存在重复的话可以考虑将字符串入池来节约空间
二进制字节码文件(类基本信息,常量池,类方法定义(包含虚拟机指令))  javap -v  *.class 反编译
  静态常量池：
     存放在class文件中,类似于一张表,虚拟机指令根据这张表找到要执行的类名,方法名,参数类型,参数值等信息
  运行时常量池
     将常量池中的类被加载时,他的常量池信息就会放到运行时常量池中,把里面的符号变成真实的内存地址
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
6.直接内存    可以通过任务管理器查看内存,Java的工具监视不到
  1.常见于NIO(非阻塞IO)操作,在数据读写时用作缓冲区
  2.分配回收成本高,但是读写性能非常高
  3.不受GC管理(底层unsafe对象完成创建和释放,内部使用cleaner虚引用监听bytebuffer,如果发现被释放就调用unsafe的释放方法 释放直接内存)
Java只能访问java分配的内存,不能直接访问系统内存。
   1.传统读写： 先将文件存入系统缓存,然后读到Java缓存,代码获取java缓存中的文件
   2.直接内存： byteBuffer提供了一个创建直接内存的方法(allocateDirect 里面new了一个directByteBuffer),直接内存既是操作系统内存但是JAVA代码也可以直接访问。这样就减少一次文件拷贝
问题： 系统动态扩容时使用-Xmx设置堆最大空间  可能导致JVM堆加上直接内存超过物理内存 从而报内存溢出
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
7.对象的创建过程(虚拟机角度)
  1.new 一个对象 首先检查这个指令参数能否在常量池中定位到一个类的符号引用
  2.检查这个类是否被加载,解析,初始化过。如果没有就交给类加载器去加载(加载后可确定内存大小)
  3.类加载通过后 为新对象分配内存
  4.内存分配完后,将分配的内存(不包括对象头)初始化为零值,作用是程序能访问到数据类型的默认值     如果采用缓冲区分配内存方式,可以将初始化为零的操作也提前到缓冲区
  5.最后设置对象头,对象头中包含(类的实例,对象的哈希码(实际上哈希码会延后到真正调用hashCode时才计算),GC分代年龄等信息)
java角度
  1.init方法还没有执行,所有字段都是默认零值。  所以还需要执行init方法

内存分配两种方式：
  1.指针碰撞(Serial和ParNew收集器)
     假设Java堆内存整齐,使用过的放一边,未使用过的放一边。中间指针作为分界点,指针向空闲区移动分配出空间。这种方式是指针碰撞
  2.空闲列表(Sweep收集器)
     如果JAVA堆内存不整齐,使用和未使用交叉起来,就没法使用指针碰撞的方式分配.这个时候虚拟机需要维护一个列表,找到足够分配的内存进行分配然后更新列表
  JAVA堆是否整齐是由垃圾回收器是由具有压缩整理的能力决定的

分配内存冲突,怎么保证线程安全
  1.采用CAS分配重试的方式来保证更新的原子性
  2.每个线程在堆中预先分配一小块内存,要分配内存的线程先在缓冲区中分配,只有缓冲区用完了,需要同步新的缓冲区才会同步锁定(可以通过参数设置)

对象的内存布局
  1.对象头
     自身运行时数据
        1.哈希码   2.GC分代年龄  3.锁状态标志  4.线程持有的锁  等 它是动态的结构，随着对象状态变化。
     类型指针
        即对象指向它类型的指针。如果对象是JAVA数组,那还应该有一块用于记录数组长度的数据
  2.实例数据
     对象真正存储的有效信息(各种类型的字段内容,无论父类继承还是自己定义的)
  3.对齐填充
     只是占位符作用,因为内存管理必须是8字节整数倍,对象头已经被设置为8字节的倍数,所以当实例数据不是8字节倍数时进行对齐填充

对象的访问定位
  1.句柄： 栈上reference指向句柄地址,句柄中存放 对象实例地址和对象类型地址     优点：对象移动只需要改变句柄中的地址
  2.直接指针： 栈上reference指向对象实例地址,对象实例对象实例中存放对象类型地址    优点：少做一次读取   对象访问在JAVA中非常频繁,所以效果很可观

内存泄露原因
  1.ThreadLocal使用不当,没有remove清理
  2.hash值变化,无法找到存入对象,也会造成内存泄露. 这也是为什么String设置为不可变类型
  3.变量不合理的作用域
  4.socket连接 不用不及时关闭
----------------------------------------------------------------------------------------------------------
垃圾回收
如何判断对象可以被回收
  1.引用计数法
     当对象被其他变量引用就计数加一,不再引用减一。归零就可以回收
     弊端：循环引用  A引用b  B引用A  没人引用他们两个 但是各自引用都不能归零导致内存泄漏
  2.可达性分析法
    确定根对象(GC root)：肯定不能被回收的对象,垃圾回收之前对堆中所有对象扫描,看是否被根对象引用,如果没有被引用就可以回收
    哪些对象可以作为根对象：
       1.虚拟机栈中引用的对象：正在运行的方法所使用参数、局部变量等
       2.本地方法栈中JNI引用的对象,
       3.静态属性引用的对象,
       4.常量池引用的对象常量池中的引用
       5.虚拟机内部的引用： 基本数据类型Class对象\空指针对象\类加载器等

Java中4中引用
强引用：等于直接赋值就是强引用  赋值null取消强引用  不会被垃圾回收。当引用全部断开时垃圾回收
软引用(SoftReference)：发生内存溢出前会去回收软引用关联的对象,如果回收完内存还不够 才会报OOM     如果没有关联对象可以放入引用队列,通过引用队列找到软引用   进行回收
  场景：使用软引用加载图片,内存不足前面加载过的就会释放, 防止OOM,要打开再次加载就可以
弱引用(WeakReference)：只要发生垃圾回收,不管内存是否充足都会回收弱引用关联的对象                如果没有关联对象可以放入引用队列,通过引用队列找到弱引用  进行回收
虚引用(Phantom Reference)：目的就是关联对象被回收时收到一个系统通知   必须配合引用队列,直接内存使用的就是虚引用,当bytebuffer被回收后   通过引用队列找对虚引用 从而释放直接内存

finalize方法： 可达性分析到不可达对象会对它进行一次标记,看你是否重写了finalize,如果重写了此方法并且和对象进行管理(比如this赋值给类变量) 他就不会被回收  如果没有任何关联就会被回收

垃圾回收算法：  实际使用中不是只使用一种,是多种混合使用的
   1.标记清除：将没有被GCRoot引用的对象做标记,清除标记地址并不是清除内存,而是将内存地址起始地址存放到空闲列表中提供使用
     优点：速度快  只需要将起始地址做记录就完成清除  缺点 容易产生内存碎片
   2.标记整理：将没有被GCRoot引用的对象做标记,将保留的对象整理成一块连续的内存,剩余一块连续内存
     优点：没有内存碎片   缺点：整理会移动对象,涉及东西多，效率低
   3.复制算法：将内存区划分成大小相等的两个区,其中一个空闲,将GCroot标记的对象复制到空闲区域,清空第一个区然后交换两个区位置
     优点 没有内存碎片   缺点  一部分空间没有使用，存在空间的浪费
   4.分代垃圾回收机制  (新生代(伊甸园、幸存区From、幸存区To   8:1:1)   老年代)
     1.老年代：有的对象需要长时间使用,放入老年代
     2.新生代：用完可以丢弃的对象放入新生代
     优点：因此可以设计不同的垃圾回收算法,老年代很久一次新生代垃圾回收频繁
对象创建存放在新生代的伊甸园中,当伊甸园空间不足时,触发MinorGc使用可达性分析算法进行标记,被标记的对象放入新生代幸存区To,将寿命+1
交换新生代From和To的内存区域,将伊甸园没有被标记的释放,第二次伊甸园空间不够继续MinorGC,区别就是可达性分析算法还要多加一个From内存
然后标记的放到To,交换位置寿命+1,当寿命到达一个限制就将这个对象放入老年代.
使用复制算法,并且在发送MinorGC时暂停所有用户线程,垃圾回收结束恢复运行  寿命最大15    4bit( 1111 )
当老年代空间不足,会执行FUllGC,其他线程暂停时间更长,清理速度较慢。如果fullGC结束还不够就OOM

Minor GC/Young GC、Major GC/Old GC、Mixed GC、Full GC都是什么意思？
   1.Minor GC/Young GC：指目标只是新生代的垃圾收集。
   2.Major GC/Old GC： 指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。
   3.混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。
   4.整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。

什么时候会触发FULL GC：
   1.Young GC之前检查老年代：进行Young GC时,检查老年代可用连续空间 < 所有升入老年代的平均大小 说明本次可能会造成空间不足,那就会触发 Full GC。
   2.Young GC后老年代空间不足
   3.老年代内存使用率达到一定比例
   4.JDK8之前永久代内存不足会出发FUll GC
   5.System.gc()等命令触发

新生代晋升老年代方式                创建的线程发送OOM不会影响主线程继续执行
   1.长期存活,对象头中存放GC分代年龄,超过15直接放入老年代   因为15是最大值
   2.GC后幸存区放不下,只能放入老年代
   3.动态年龄判断,当幸存区内存超过一半,找到年龄最大的加一作为阈值,如果下次minorGC还存活就放入老年代
   4.特别大的对象,伊甸园清空也放不下,就会直接放入老年代









-XSS                   分配虚拟机栈内存 linux默认:1024KB
-Xmx(-XX:MaxHeapSize)  分配最大堆空间
-Xms                   分配初始堆空间
  最大内存：当物理内存小于200兆,默认最大堆空间是物理内存1/2,否则是物理内存1/4
  初始内存：物理内存的1/64,最小8M,最大为1G
  年轻代：老年代   1：2    年轻代默认为堆空间1/3  老年代为2/3
-XX:MetaspaceSize      分配元空间大小       默认20多兆
-XX:MaxMetaspaceSize   分配最大元空间大小   默认最大值
   一般元空间和元空间最大值设置统一,因为元空间大小改变会FULL GC












