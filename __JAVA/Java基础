来讲讲什么是注解？
   1.代码中的特殊标记,可以在编译,加载,运行时执行相应的处理    原生@Overried、@FunctionalInterface
   2.自定义注解自动继承 Annotation(元注解),
   3.元注解专门的一些注释
       1.@Target ：用来限定注解的位置,比如接口,属性,方法等  一般来说使用方法
       2.@Retention：用来表示注解的生命周期,包括 源文件阶段、编译到class阶段、运行阶段       默认CLASS
            源文件阶段：不会参与到编译和运行 一般就是注释作用
            编译到class阶段：编译期间可能会做一些处理,运行期读不到    Lombok就是这个编译阶段完成的get\set方法嵌入  继承一个类实现方法
            运行阶段：一般配合AOP 通过反射获取到注解然后执行相应的操作
       3.@Documented注解，是被用来指定自定义注解是否能随着被定义的java文件生成到JavaDoc文档当中。
       4.@Inherited注解，是指定某个自定义注解如果写在了父类的声明部分，那么子类的声明部分也能自动拥有该注解。@Inherited注解只对那些@Target被定义为ElementType.TYPE的自定义注解起作用。
你对泛型有多少了解？
   1.代码更加简洁,程序更加健壮(如果有类型转换异常编译会报错),平时在集合经常使用泛型.
   类型擦除：在字节码中实际存储和取出都是使用的Object,在取出时进行类型强转
   只支持封装类型,不能使用基本数据类型
SLF4J、JCL 和Log4j、LogBack区别？
   1.Log4j、LogBack属于日志系统,如果系统中出现多个日志系统需要分别维护(并且Log4j出现过漏洞 导致JNDI注入问题)
   2.SLF4J、JCL 属于日志框架,有利于维护,切换日志系统。与底层日志系统无关,有利于任意更换日志系统


JAVA特性
    封装:是面向对象(OOP)的一种思想,将具体功能封装成方法。 提高代码复用性,隐藏具体实现细节直接调用即可！
    继承:使子类集成父类的属性和方法,既可以直接使用也可以重写覆盖
    多态原理(invokeVirtual)  运行期间动态查找,所以效率是比静态方法执行要低
        1.通过栈帧中对象引用找到堆中类对象  2.分析对象头找到方法区的Class详细信息  3.每个类都有一个虚方法表(vTable)在链接阶段就生成好了  4.查找虚方法表得到方法具体地址  5.执行方法字节码
        运行时多态(编译时不确定调用的具体哪个方法,运行时才确定):重写：子类对父类非私有方法进行重写
        编译时多态(编译时就确定如果调用就是这个方法)：重载:无关返回值,访问修饰符,关心 方法名相同,参数列表不同(参数个数,参数类型,参数顺序)
    虚方法:Java种所有被重写的方法都是虚方法     VS 抽象方法  1.虚方法有实现抽象方法没有   2.关键词修饰abstract
    非虚方法:static、final、父类方法、private都是非虚方法
    invokeStatic执行静态方法  invokeSpecial执行init方法(静态属性静态代码块)  invokesVirtual执行虚方法   invokeInterface执行接口
数据类型：  整数型默认int  浮点型默认Double
    基本数据类型：整形默认0（byte 1字节 ，short 2字节，int 4字节，long 8字节） 浮点型默认0.0（float 4字节 double 8字节） 布尔型默认false boolean 1字节 字符型默认空 char 2字节   1字节=8位(bit)
    包装类型：Integer 有缓存数组-128<=value<=127 超过范围才会new         JAVA使用Unicode编码占16位 2字节 所以char可以存放    short a=1 && a+=1 都存在隐式自动类型转换 不会报错
    区别：1.基本数据类型有默认值而封装类是null 2.包装类是对象有方法使用需要new,基本类是直接使用的关键字
    自动类型转换：byte->short<->char—> int —> long—> float —> double    如果不按这个顺序编译报错(需要强制类型转换) char转换按照ASCII码转换
    为什么包装类型内部值都是用final修饰？ 因为final也采用读写屏障来保证多线程下安全,防止线程拿到未初始化的默认值
float:
    基本数据类型不可用==,包装类型不可用equals比较。因为浮点数采用尾数+阶码.所以比较会不通过
    解决： 1.在一个范围内就认为相同： float a = 1.0F - 0.9F;  float b = 0.9F - 0.8F; float diff = 1e-6F; Math.abs(a - b) < diff)
          2.采用BigDecimal进行运算比较操作
BigDecimal
    1.等值比较应使用 compareTo()方法，而不是 equals()方法。equals()方法会比较值和精度（1.0 与 1.00 返回结果为 false），而 compareTo()则会忽略精度。
    2.禁止使用构造方法 BigDecimal(double)的方式把 double 值转化为 BigDecimal 对象。
        现象：BigDecimal g = new BigDecimal(0.1F); 实际的存储值为：0.10000000149
        解决 1.应转化为String进行构造 2.BigDecimal.valueOf(0.1) 内部会对double进行截断
equals 和 hashCode 和 ==
    equals:引用类型默认调用Object的equals使用==比较地址。 String重写后会先比较地址,地址一致返回true不一致会遍历字符数组,全一模一样也会返回true否则返回false  Integer则是转成int进行==
    ==：基本数据类型比较值是否一致,引用数据类型则是地址
    hashCode引入背景：集合中判断重复如果全用equals 效率很低,hashcode是一个优化,先通过hash计算位置然后找到使用equals判断,提高效率 也就是说hashCode和equals都相同就认为重复
    问题：如果hashCode不相同就会默认equals不相同  造成内存泄漏,key使用new Student("王昊杰")地址不一样hashcode肯定不同 所以可以一致set 造成内存溢出
    解决：就是重写hashCode让两个对象hash一致,还需要重写equals让他比较成立
接口和抽象类
    抽象类：单继承
        1.只有声明没有实现,子类必须重写,所以不可以使用private和default这种子类可能访问不到的修饰符(编译报错！！)
        2.子类继承抽象类必须实现父类抽象方法或者将自己设置为抽象类    抽象类不可实例化 编译报错！！
    接口： 多继承
        1.接口的作用是解决多重继承的,一个类可实现多个接口,接口种的常量默认都是public static final 不可修改,方法默认public abstract来修饰
        2.接口种所有变量都是静态常量 所有方法都是抽象方法不能有方法体(可以存在默认方法default和静态static方法,有方法体通过类名和方法名调用)
    相同点：都不可以实例化
    区别：抽象类种可以有非抽象方法,接口中全是抽象方法(不全面 也可能存在静态方法) 2.可以实现多个接口,属于一种规范要完成的动作。 但只能实现一个抽象类,属于一种模板
static和final关键字
    static：
        1.修饰(变量、方法、类、代码块)   静态代码块优化性能:比如加载文件可以写在静态代码块中,只加载一次  类变量存随类存放在方法区  访问无需创建对象  直接类名.方法名 调用
        2.静态优先于对象的加载,所以不能使用this和super等关键字
    final：
        1.修饰静态成员必须进行初始化(立即赋值或者静态代码块赋值.只能赋值一次)
        2.final多线程下作用:通过内存屏障 防止线程获取到未初始化的默认变量
&和&&
    1.都是与操作  &&会造成短路
JAVA体系结构
    1.java程序设计语言(语言 C/C++)    2.java class 文件格式     3.java应用编程接口(Java API)     4.JVM
    使用java语言调用Java API编写Java文件 编译成Class文件  提供JVM执行
访问修饰符
    public:   当前类、同包内(同包子类、同包其他类)、不同包子类  其他包 都可以访问
    protect： 当前类、同包内(同包子类、同包其他类)、不同包子类                              除了当前类和同包下和不同包子类 其他都不可以访问
    default： 当前类、同包内(同包子类、同包其他类)、                                      除了当前类和同包下都不可访问
    private： 当前类                                                                除了当前类都不可访问
String、StringBuilder、StringBuffer 区别  都是使用char数组,后两个区别就是有没有加锁
    String：包装类是一个类,内部使用 private static final char[] value;  适合 少量字符串操作 因为不可变字符串所以+会一直创建字符串  垃圾回收时才会把没有引用的回收掉  效率低
    StringBuilder:速度快但是线程不安全,适合单线程字符串频繁操作使用。 是在原有字符串上做更改
    StringBuffer:速度比builder慢但是线程安全,适合多线程字符串频繁操作使用  是在原有字符串上做更改
    他们扩容机制(区别是否有锁): 无参构造默认存放16个字符,有参String类型默认String长度+16个字符,有参int类型默认是设置的int值大小 。扩容大小为原始*2+2   之所以加2是因为拼接后末尾存在多于字符
    效率：  String + < String concat < StringBuffer  <StringBuilder         StringBuffer线程安全和String final修饰线程安全
Comparable 与 Comparator
    都是排序方法,用法:实体类实现 Comparable<T> 重写compareTo方法即可进行调用使用    String和Integer自己实现了Comparable可以直接使用  自定义类或者List集合可以使用Comparable进行排序
    不支持自排序的比如二维数组使用Comparator 匿名类的方式重写排序方法
super()和this()
    super()函数在子类构造函数中调用父类的构造函数时使用，而且必须要在构造函数的第一行。
    this() 用于调用重载的其他构造函数 只能用在构造函数中，并且也只能在第一行。所以在同一个构造函数中this()和super()不能同时出现。
序列化和反序列化： 对象和字节序列转换过程
    序列化：对象转成二进制流方便网络传输,持久化文件  序列化只保留对象属性,不保留方法,可通过transient不进行属性序列化
    serialVersionUID：手动指定版本号,自动只要类修改就会修改版本号,JVM就会任务类不是同一个,热部署方式就可不用需要用户更新软件
值传递和引用传递
    值传递：基本数据类型都是值传递  传递的是值的副本                  特殊：数组都是引用传递
    引用传递：引用数据类型传递的是地址 修改对应数据会导致原数据变动      特殊：String存放常量池种,副本改变不会影响原本的值
深拷贝和浅拷贝的区别
    浅拷贝：只拷贝对象引用,两个对象指向一个引用,修改一个会导致都变化    Persion p= new Persion(23,"whj")  Persion p1=p;  就是浅拷贝,修改新对象旧对象也会被修改
    深拷贝：深拷贝会创造一个一摸一样的对象,修改互不影响   1.clone方法默认浅拷贝但是可以重写实现深拷贝, 2. 序列化反序列化实现深拷贝  3.部分工具类提供了深拷贝方法 好像也是试用的序列化反序列化
    产生BUG：一个数据模板提供给多条数渲染,如果使用浅拷贝可能导致后续的渲染出现问题
常用函数：
    Math.floor()   表示向下取整，返回double类型   （floor---地板）
    Math.ceil()   表示向上取整，返回double类型    （ceil---天花板）
    Math.round()  四舍五入，返回int类型






5中IO模型和零拷贝









































































