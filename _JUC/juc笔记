线程常用的一些方法
    1.Join ： 如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才会继续执行
    2.wait,wait(long time):
    3.sleep
    4.notify,notifyAll:  随机唤醒一个被wait的线程  或者唤醒所有被wait的线程
    5.yield：暂停正在运行的线程,运行其他线程运行。问题：有可能还是他获得现场
    6.interrupt：中断线程  由运行状态到死亡状态   当前线程正在运行或阻塞，仅仅修改标示位，不在做其他的事，如果是join，sleep，yield，则会抛出Interrup异常，修改标示位为false
    7.setDaemon：设置当前线程为守护线程
    8.getPriority：设置优先级  也可以get获取优先级
    9.isAlive判断线程是否激活状态 (阻塞,运行)
-------------------
Thread.Start方法
    1.首先start方法会首先调用C的start0方法,C会去操作底层和本地现场做一次绑定,当本地线程准备就绪后就会调run方法
各种锁的理解：
    1.公平锁：非常公平 ，线程谁先来的谁限制性 不能插队
    2.非公平锁：不公平锁可以插队。比如一个任务三个小时。后来一个3s可以执行完。为了效率就让他插队。synchronized使用非公平锁
    3.可重入锁（递归锁）： 拿到了外面的锁就可以拿到(自动获得)里面的锁   所有的锁都是可重入锁。必须全部释放才行
       可重入锁 synchronized和lock区别： synchronized是一把锁  lock是两把锁。外面的锁解外面 里面的锁解里面
    4.自旋锁：cas底层就是自旋锁。如果条件成立交换 如果条件不成立就一直在循环里
    5.死锁：
    一个用户A 访问表A(锁住了表A),然后又访问表B；另一个用户B 访问表B(锁住了表B)，然后企图访问表A；这时用户A由于用户B已经锁住表B，
    它必须等待用户B释放表B才能继续，同样用户B要等用户A释放表A才能继续，这就死锁就产生了。
    6.闭锁(减法计数器)
    7.读写锁
乐观锁：原子引用的cas就类似乐观锁。在使用的时候判断一下版本是否被修改过
悲观锁：当要对数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。
行锁表锁 synchronized  lock都是悲观锁。在操作之前加锁其它线程等待  主要分为共享锁和排他锁：
