1.请说下你对 MySQL 架构的了解？   语言C++
    1.Server层
        1.连接器:和客户端建立连接(最大连接数16384个),获取权限
            长连接:连接成功后多次使用,减少客户端和服务器连接次数提高效率,默认8小时,不操作就会断开连接
                优点：效率高  缺点:执行过程中产生的临时空间占用内存,只能等到断开连接清理( 2.)
                缺点解决方案：
                    1.执行完占内存大的操作后断开连接避免内存堆积
                    2.5.7版本后可以执行初始化连接命令mysql_reset_connection(),但是会释放所有表锁,回滚所有事务并设置自动提交
            短连接:执行完毕后关闭连接
        2.查询缓存： MYSQL8已经去掉这个部分了,因为数据频繁修改缓存会一直清空缓存,效率低。
        3.分析器:SQL进行语法和语法分析,如果SQL错误这一层就会抛出SQL错误的异常
        3.优化器:对SQL进行优化,决定多个索引使用哪个索引,多个join连接顺序等
        4.执行器:通过存储引擎,将SQL执行结果返回客户端
    2.存储引擎层: 表中的数据是一行一行的,在物理上如何存取,都是存储引擎负责的,创建表的时候同 engine =INNODB指定
        1.INNODB(默认):
        2.MYISAM
2.数据库三范式,如可以提高效率可以适当降低范式.包保留适当冗余
    第一范式：原子性。字段不可再分
    第二范式：唯一性。记录要有唯一标识。一般是设计主键
    第三范式：去冗余。去重多表中重复字段
3.char 和 varchar 的区别？
    char长度不可变,不够会用空格填充,所以使用的时候需要trim去空格,varchar长度可变
    char的存取速度比varchar快,因为长度确定,属于以空间换时间的方式
    char存英文占用1字符存中文占用2字符   varchar存英文中文都占用2字符
4.varchar(10) 与 varchar(20) 的区别？
    varchar(10)最大占用空间为10字节,但是当他们存小于10字节的数据时,后者排序会更销毁内存,因为order by计算的是字段长度
5.union 和 union all 的区别？
    union all:对两个结果集直接进行并集操作,不会进行去重,不会进行排序。
    union:对两个结果集进行并集操作,会进行去重,按字段的默认规则排序。因为要去重所以会产生临时表
    因此，从效率上说，UNION ALL 要比 UNION 更快。
6.InnoDB 和 MyISAM 的区别？
    innodb支持事务,可以使用行锁表锁,主键是聚集索引,拥有适应hash升级
    myisam不支持事务,只有表锁,主键非聚集索引,一个变量记录行数所以使用count(*)效率高
    选择：如果增删改频繁使用innodb   如果全是查询操作推荐使用myisam,性能高
7.SQL关键字的执行顺序
    1.人写的 select distinct * from  表名  join 表  where 条件  group 分组 having分组后筛选  order 排序  limit 分页
    2.机读 from 连接条件 连接表 where条件 分组 分组后筛选 查询想要的字段  去重  排序  分页
---------------------------------------------------------------------------------------
1.为什么要用索引？对索引的理解？
    通常情况下,数据量小查询简单,所以不会出现性能问题,但是生产中可能存在一条SQL执行很长时间的情况,这个时候就需要进行优化,SQL本身优化或者使用索引查询
    索引是一种数据结构,可以提交查询和排序的效率,但是其实索引也维护了一张表,需要占用内存,并且会降低更新的效率。
2.索引分类：
    1.单值索引：一个索引只包含单个列,一张表可以建立多个单值索引。但是一般不会超过5个
    2.唯一索引：索引列的值必须唯一,但允许有空值 unique
    3.复合索引：一个索引包含多个列
        1.创建索引：create 【unique】 index  索引名  on   表(字段名)     2.查看所有：show  index  from  表名
    4.全文索引：主要是查找文本中的关键字,而不是直接与索引中的值相比较,更像一个搜索引擎.
    推荐：高并发下推荐使用复合索引
3.什么时候推荐使用索引？什么时候不推荐使用索引？
    推荐    1.频繁查询字段   2.进行分组或排序的字段    3.主键默认唯一索引
    不推荐  1.频繁更新的字段不推荐(因为索引会降低更新效率)   2.数据量小不推荐(300W)   3.数据大量重复的(例如性别)
4.索引失效的情况？
    1.最佳左前缀法则   2.自动类型转换也会导致索引失效  3.or、is null、is not null、!= 都不使用索引  4.复合索引使用大于小于会导致后面索引失效
    5.模糊查询左%不使用索引(覆盖索引解决)   6.not in 不使用索引。not exists可以部分使用索引 所以推荐使用not exists
    7.小表驱动达标。子查询小用in  主查询小用exists  in先走子查询。exists先走主查询
    常见问题：
        1.分组之前会排序,如果顺序错乱会产生using filesort和临时表
        2.order by按顺序可以使用索引。不按顺序会出现file sort
5.索引的数据结构分类？
    如果不加索引：
        查询数据需要每次访问磁盘一直到查询到想要的数据。  平均情况会访问次数=  总数/2
    1.哈希索引
        使用hash算法将字段值计算成hash,然后找到数组对应位置存放,使用链表法解决哈希冲突
        优点:很多时候效率比B+效率高  但是只能使用等于,不能进行范围查找
    2.红黑树索引(二叉平衡树)
        自动平衡二叉树解决二叉树单向成链表的问题,但是数据量大的时候深度也很大,同样会进行多次磁盘处理,效率随着数据量增加下降严重
    3.B树索引
        给一个节点开辟大点内存,让他可以存放多个元素,元素和元素之前可以进行分叉,整体从左到右递增
        优点：解决了红黑树深度问题    缺点:每次查询节点占用内存相比红黑树变大了
    4.B+索引
        1.将所有索引元素和磁盘文件地址都放到叶子结点(非叶子结点只需要key和下一个节点指针,因此一个节点中可以存放更多数据,降低树深度)
        2.使用叶子结点的双端来构建索引树,叶子节点增加双向指针提高范围查询的速度
    5.一个B+树节点多大合适？
        Innodb引擎中一个节点为一页,一页大小大概16K,非叶子节点key和指针大小大约10字节,16K可以存放一千多个数据,高度为3的B+树大约能存两千万数据
        对于叶子节点行数据1K基本几页肯定够,16K可以查询16行数据,一般分页都是10行,所以16K在千万数据量下IO次数也不超过三次,性能已经足够了
    6.什么是 Buffer Pool？
        1.做缓存,保存热点数据提高查询效率,内存操作本身快  2.更新数据更新到缓冲池中,内部通过线程维护到磁盘 提高性能
6.MySQL 中的索引叶子节点存放的是什么？
    MYISAM:主键索引和普通索引叶子节点存放的都是key和key对应数据行的地址,主键索引和普通索引没有区别
    INNODB:主键索引叶子节点存放的都是key和key对应数据行,普通索引存放的是key和key对应主键值(先通过索引获取主键值然后通过主键索引查询具体记录)
7.MYISAM和INNODB文件结构？
    MYISAM
        1.frm：数据库表结构文件
        2.MYD：数据库表数据文件
        3.MYI：数据库表索引文件
    INNODB
        1.frm：数据库表结构文件
        2.IDB：数据库表索引和数据文件
8.什么是聚簇索引（聚集索引）？为什么INNODB必须建主键？并且建议自增？为什么只生成一个聚簇索引？
    它是一种存储方式,将索引和数据行放到一块,找到了索引就找到了数据,不需要进行回表,所以效率高
    Innodb中一般主键索引是聚簇索引,没有主键则选择唯一索引,如果唯一索引也没有则会创建一个隐藏列当做聚簇索引,所以推荐有主键
    如果自增方便B+树维护,否则可能出现树分裂平衡的情况,效率降低。  因为数据只留一份所以只需要一个聚簇索引
9.什么是回表查询？
    INNODB中使用普通索引先从节点拿到主键值,然后根据主键值走主键索引找到数据行,属于回表
    MYISAM先通过索引查询索引文件,然后通过查询到的地址查询数据文件,也属于回表
10.走普通索引，一定会出现回表查询吗？
    不一定,查询列符合覆盖索引也不需要回表,因为索引树已经查出来数据了,无需回表查询额外数据
    覆盖索引:要查询的列如果为辅助索引的索引树所能查出的数据子集就符合覆盖索引
11.联合索引（复合索引）的底层实现？最佳左前缀原则？
    联合索引底层使用B+树,并且同样只有一棵树,叶子排序时会先按照第一个索引排序,相同时按照第二个索引排序,这也是左匹配的原因。
12.Innodb四大特性
    1.插入缓冲( Insert Buffer):
        将插入操作放到内存,多次IO降低成一次IO来提高效率
    2.二次写（double write）:
        写操作先统一放入共享表空间,然后分别放入对应表空间。在发生断电等异常情况的时候,恢复的时候从共享表空间获取数据。 尽量避免数据丢失
    3.自适应哈希索引(adaptive hash index）:
        哈希索引查找快但是不支持范围查询,Innodb会把频繁访问的数据创建一个hash索引提高查询效率
    4.预读（read ahead）:
        Mysql是以页为单位操作数据的,所以会将关联页提前加载到内存,提高效率
-----------------------------------------------------------------------------
MYSQL8.0---->MVCC源码解析
1.为什么使用MVCC？
    并发情况下并发问题如果采用加锁方式解决,性能会受到严重,MVCC中读会将记录拷贝到内存中(ReadView),之后该事务查询只跟ReadView打交道,不影响其他对该记录写操作
2.MVCC源码
    innodb向每行数据增加三个字段
        1.DB_ROW_ID行ID:没插入一行数据就会递增,所以有主键使用主键,不增加该字段。
        2.DB_TRX_ID事务ID:记录插入或更新改行的最后一个事务的事务标识
        3.DB_ROLL_PTR回滚指针:指向undo log记录,如果改行多次修改,undo log会形成单链形式
    增删改底层操作
        1.加锁：对要更新的行记录加排他锁
        2.写undo log日志：将更新前的数据写入undo log中,并通过回滚指针构成单链形式
        3.进行增删改数据,将新增的事务ID设置当前事务ID,回滚指针指向undo log 位置
        4.写redo log日志,将更新后的数据写入redo log中
        5.处理结束 释放锁
        删除的底层只是undo log中的一个字段标记的,然后开启了一个线程执行真正的删除。
    查询操作底层操作(隔离级别 可重复读)
        1.查询时生成当前时间点的事务快照ReadView
            1.m_ids：事务ID列表,当前时间点已开启的事务并且没有提交的事务ID集合,ID升序排列
            2.m_up_limit_id:低水位ID,就是事务ID列表中最小的ID也就是第一个ID
            3.m_low_limit_id：高水位ID,就是事务ID列表中最大的ID也就是最后一个ID
            4.m_creator_trx_id：创建当前ReadView的事务ID
        2.根据生成的ReadView进行可见性判断(聚簇索引情况下使用,普通索引采用ICP索引条件下推处理可见性)
            1.如果行数据事务ID与创建ReadView的事务ID相同,说明事务在访问自身修改过的记录,可以访问
            2.如果行数据事务ID小于低水位ID,说明这个事务在生成ReadView的时候已经被提交,可以访问
            3.如果行数据事务ID大于高水位ID,说明这个事务在生成ReadView后才开启,所以该版本不可以被当前事务访问
            4.如果行数据事务ID在高低水位之间,采用二分法查询事务ID是否存在到事务ID列表中,如果存在,说明ReadView生成时事务还未提交,不可访问,如果不存在说明事务已提交,则可以访问
            在进行判断时,先用最新的事务ID比较,如果该版本无法被当前事务看到,则通过undo log找到上一版本重复判断,直到找到一个版本能被当前事务访问
    当前读和快照读
        1.当前读(锁定读取)：读取数据最新版本  增删改都是当前读
        2.快照读：读取快照版本,也就是MVCC生成的Read View 用于普通的select
3.MVCC 解决了幻读了没有？
    如果是快照读,通过高低水位进行可见性判断,新事物插入数据是不可见的,所以解决幻读
    如果是当前读,MVCC无法解决,需要搭配间隙锁来解决,间隙锁会锁住整个范围,防止插入操作来解决幻读。间隙锁在innodb的可重复读隔离级别默认开启
4.undo log:撤销日志
    事务开始之前将mysql更新前的数据生产到undo log中,回滚或数据库崩溃时通过undo log进行回滚,提示提供mvcc进行多版本控制
5.redo log:重做日志
    事务完成后数据的存放到redo log中
6.ICP(Index Condition Pushdown) 索引条件下推
    5.6之后引入的一种优化,没有ICP时存储引擎定位到符合条件的行发给server层处理where条件,引入ICP后存储引擎去计算where条件,这就减少了返回给server层的数据
    减少mysql server层访问存储引擎的次数来提高效率
    举例子:一个复合索引(a,b,c) 查询条件a=1 and c=1?
        如果不采用ICP:通过a=1查询到所有主键,然后回表过滤掉所有c=1的数据
        采用ICP:直接将c=1下推到执行引擎,不符合的直接跳过,减少回表次数提高效率

