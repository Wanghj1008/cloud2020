1.哈希表(散列表)
    1.优点：存取快,插入和查询的时间复杂度都是O(1)   缺点:基于数组,数组创建后扩容成本比较高,所以哈希表满的时候性能下降严重
    2.哈希函数
        将一些key通过hash算法生成一个对应的正整数
    3.哈希冲突
        两个不同的key计算出hash一样就是哈希冲突
    4.解决哈希冲突：
        1.开放地址法：
            1.线性探测：
                存储：如果当前位置存在数据就向后找,一直找到没数据进行存放
                查询：计算hash位置进行查找,查不到一直向后找,到空位置还找不到就说明没有
                删除：到空位置就会停止查询,直接删除容易导致后面查不到. 因为hash全是正数所以这个地方放一个-1来代表删除
            2.平方探测：为了解决线性探测的问题,按次数平方进行后推存取(存储、查询、删除同理 只不过步长不一样而已)
            3.双哈希： 为了解决线性探测和二次探测步长固定问题,因此第二个哈希算法不能输出为0,而且经过实验有一个最佳公式
                步长计算：stepSize = constant-(key%constant);  constant为质数并且小于数组容量
                要求：哈希表的容量必须是一个质数,因为使用质数会查找到每一个元素
            4.缺点：1.一个位置大量冲突会导致存取性能下降    2.删除多了可能导致哈希表充满-1,效率下降
        2.链表法：
            1.每个数组位置都对应一条链表,发生哈希冲突都放入链表内
            2.有序链表和无序链表的区别？
                1.有序链表查找和删除快,插入慢  无序列表：插入快,查找和删除需要全部遍历完
        3.公共溢出法：创建一块空间存储冲突数据
        4.再散列法：准备多个哈希函数,冲突了使用其他函数计算
        3.链表法和开放地址法比较？
            1.数据小选择开放寻址法,数据量不确定或者数据多会导致装载因子变大,性能降低,所以推荐线性表结构
    5.哈希表的效率： 装载因子=哈希表已存的元素 / 哈希表的长度。
        如果不发生hash冲突,存储和取值都是O(1),如果发生哈希冲突,时间复杂度却决于装载因子,比较像使用率,使用率越高性能越低

https://www.bilibili.com/video/av22258871/?vd_source=280e50ba501c50853df124766107ad4d


数据结构：数学模型在计算机上的一种实现

时间复杂度(big O)：对算法的时间开销进行计算,保留最高阶
    O(1)<O(log2^N)<O(n)<O(nlog2^n)<O(N^2)<O(N^3)<O(2^n)<O(n!)<O(n^n)
空间复杂度(big O)：完成需要的额外空间,n的大小不影响空间则为O(1)

线性表(Linear List)：数据元素类型相同,有限,有序性。  例如数组
    顺序表(数组)：逻辑相邻的元素在物理位置上也相邻,所以通过索引查找很快,需要初始化的时候分配大小






