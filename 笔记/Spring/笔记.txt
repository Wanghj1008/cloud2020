
引入其他文件：<import resource="aaalication-dao.xml"/>
注解方式：
@ComponentScan:指定扫描包
@import:配置文件加载其他分支配置文件
@propertyResource：用于加载.properties的文件


整合junit：
@RunWith("SpringJunit4ClassRunner.class")
@ContextConfiguration("classpath:application.xml") 或者不用xml用核心配置类@ContextConfiguration("class={Config.class}")

SpringMvc:
缺点：servlet中每次都需要创建Spring容器加载application
改进：将创建加载的过程交给监听器。容器启动就加载配置文件。ContextLoaderListener存放WebApplicationContextUtil取
前端控制器：统一处理请求。在配置时候需要把SpringMvc配置文件读取进去
配置视图解析器：默认转发可以换成重定向。加前缀后缀
返回字符串：@ResponseBody 但是如果是实体类需要加<mvc:annotation-driven>      mvc注解驱动
请求：获取集合参数 1.使用VO包装接收 2.如果是ajax请求 可以直接用@RequestBody List<User>接收
开放静态资源:<mvc:resources mappingL="/js/**" location="/js/"/>   或者：<mvc: default-servlet-handler/>
@RequestParam(value="name",defaultValue="whj")



 Mybatis：是持久层框架,简化开发使开发者不用关注创建链接等操作,只需要关注SQL语句。
       使用ORM(对象映射关系)思想
           ORM：就是把数据库和实体类及实体类的属性对应起来，让我们可以操作实体类就实现操作数据库
注意事项：XML的mapper标签namespace值为接口全限定类名
         接口名为XML的id值
         接口的包路径和XML包路径保持一致




--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------------------
MQ(MessageQuene) 消息队列
       通过生产者和消费者模型,生产者不断向消息队列中发消息,消费者不断从消息队列中拿消息,因为消息的生产和消费都是异步进行的,而且
       只需要关心消息的发送和接收,实现系统解耦.  别名消息中间件,利用高效的消息传递机制进行平台无关的数据交流。

1.ActiveMQ
   Apache出品,是比较老牌的消息中间件,但是性能不太好。
2.kafka
   Apache出品,追求高吞吐量,但是对事务,消息重复，丢失，错误没有严格要求,所以在大数据领域追求速度用的比较广
3.RocketMQ
   阿里开源消息中间件.借鉴kafka高吞吐,高可用。他对消息的可靠传输及事务做了优化,但是对事务的优化版本需要收费
4.RabbtiMQ
   使用erlang语言开发的消息队列,基于AMQP协议实现。AMQP主要特征就是面向对象、队列、路由、可靠性、安全。AMQP协议更多在企业系统内对数据一致性
   可靠性和稳定性要求很高的场景,即使数据丢失了也可以恢复,对性能和高吞吐量要求还在其次。和Spring框架无缝整合
