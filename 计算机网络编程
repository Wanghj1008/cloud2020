计算机网络：
    将地理位置不同、具有独立功能的多台计算机,通过通讯线路连接起来。
    网络操作系统、网络管理软件及网络通讯协议的管理和协调下,实现资源共享和信息传递的计算机系统
网络编程：
    在网络通讯的协议下,实现网络互连下不同计算机运行的程序间可以进行数据交换
    三要素：
        1.IP：唯一标识计算机。计算机的标识号,用来区分计算机
            1.IPV4：按照TCP/Ip规定,每个IP为4字节的二进制形式地址,不好记所以一般写出十进制,192.168.1.1。点分十进制表示法
            2.IPV6: 由于互联网人数变大,IPV4不够用了,所以扩大地址采用16字节,采用16进制数。解决Ip资源数量不够问题
            3.ipconfig 查看本级IP地址
            4.ping IP：检查网络是否连通
            5.InetAddress类使用  该类表示internet协议IP地址    java.net包下
                1.getByteName(String Host)：获取与Host相对应的InetAddress对象 |参数可以是主机名也可以是IP地址
                2.getHostName：通过InetAddress对象获取的主机名
                3.getHostAddress：通过InetAddress对象获取IP地址
        2.端口号：唯一标识应用程序。每台计算机很多应用程序,使用端口号来区分应用程序
            1.取值范围0~65535.其中0~1023之间的端口用于一些知名的网络服务和应用
            2.普通应用需要使用1024以上的端口号,如果端口号被其他应用占用,会导致启动失败
        3.协议：通过计算机网络可以实现多台计算机连接。进行连接通讯的时候需要遵守一定的规则。对数据传输格式,传输速率,传输步骤做了统一规范
            1.UDP协议：用户数据报协议    无连接通讯协议
                1.发送端在发送时不会确定接收方是否存在就发送数据
                2.接收方收到数据,也不会反馈给发送方
            2.TCP协议： 传输控制协议      TCP协议是面向连接的通讯协议
                1.发送数据前需要发送端和接收端建立连接,然后在传输数据,保证可靠无差错的数据传输
                2.由客户端像服务器端发送请求连接,每次连接创建需要经过‘三次握手’
                    三次握手：TCP协议中,在发送数据的准备阶段,进行三次交互,保证可靠连接
                        1.第一次握手：客户端向服务器端发送连接请求：等待服务器端确定
                        2.第二次握手：服务器端向客户端发送一个响应,表示收到了请求
                        3.第三次握手：客户端再次向服务器端发送确定请求,确定连接
                3.断开连接
                       （1） TCP客户端发送一个FIN，用来关闭客户到服务器的数据传送。
                       （2） 服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。
                       （3） 服务器关闭客户端的连接，发送一个FIN给客户端。
                       （4） 客户端发回ACK报文确认，并将确认序号设置为收到序号加1。
            总结：
                1. UDP协议消耗资源小,通讯效率快,通常用于音频、视频、和普通数据传输   不能保证数据的完整性
                2. TCP协议保证数据传输安全      通常用于文件上传、下载文件、浏览网页等
五种IO模型：
    1.阻塞IO：传统IO,在读写数据的时候会发生阻塞
       1.用户发送IO请求后,数据没到达内核或者就没有发送数据,内核(kernel)阻塞进程等待数据。
       2.内核等到数据好了,将数据从内核拷贝到用户内存(拷贝过程阻塞进程),然后内核返回结果,解除阻塞状态
       典型的阻塞例子：socket.read()  如果数据没有就绪,就一直阻塞进程
    2.非阻塞IO
       1.用户发起read请求后,如果内核中数据没有准备好,并不是阻塞进程等待,而是直接返回错误
       2.用户看到错误就知道数据没准备好,然后继续发送read请求,当内核中数据就绪,就将数据拷贝到内存中,然后返回
       需要用户不断询问内核数据是否就绪。循环调用recv会提高CPU占用率,而且作用是检测是否完成,所有可以使用多路复用一次检测多个是否完成
       在非阻塞状态下,recv()接口被调用后立即返回。
         1.返回值大于0：数据接收完毕,返回值是接受到的字节数
         2.返回0：表示连接正常断开
         3.返回-1且error等于资源暂不可用：数据还没有接收完毕
         4.返回-1且error不等于资源咱不可用：表示在recv过程中遇到其他错误
    3.多路复用I/O :适用于连接比较多的情况
       1.用户调用select那么整个进程会被阻塞,同时内核监控所有select负责的socket。
       2.当任何一个socket的数据准备号,select就会返回给用户,用户调用read拷贝数据到用户内存
       会有一个线程轮询socket状态,使用一个线程管理多个socket,减少资源占用,d
       比较非阻塞IO：非阻塞是用户线程进行的,而多路复用是内核完成的。效率比用户线程高
       缺点：多路复用IO是通过轮询方式检测数据是否就绪,并且进行逐一操作,如果一个连接数据很大,会导致后面数据阻塞时间较长
    4.信号驱动I/O
    5.异步I/O