1.优化分析：
    1.sql写的不好,join连接表太多或者没有使用索引,或者索引失效
    2.参数设置(缓冲、线程数)不恰当
        1.可以适当调大sort_buffer_size内存的大小
        2.可以适当调大max_length_for_sort_date。
        3.适当提高最大连接数 show variables like '%max_connections%'; 高占用内存也大所以适当

2.如果查找执行慢的SQL？
    1.慢查询日志,不推荐默认开启,消耗性能
        1.mysql8默认开启,可以通过My.ini配置文件设置输出到文件或者(slow_log)表中,默认时间阈值为10s
    2.show profiles query ID： 默认关闭,一般在测试环境使用,保存最近15条SQL执行时消耗资源情况,
        1.通过status出现的情况,分析SQL是否需要优化
            1.create tmp table  创建临时表
            2.locked 锁
            3.copy on tmp table on disk 把内存的临时表复制到磁盘
            4.converting heap to MyISAM  查询结果大,内存不够放 放进磁盘
    3.全局查询日志：
        mysql 配置文件中配置
            1.开启 general_log=1
            2.输出格式 log_output=file
        sql语句实现
            1.set global general_log = 1
            2.set global log_output=table    此后所有的sql语句都会存到 general — —log 表中
    4.sql_trace：
        1.一般是默认开启。
        2.我们可以设置跟踪开启,停止,可以查看跟踪信息.默认生成5个跟踪文件,重启或达到最大值(文件都满了)会重新生成.删除最早的文件
    5.SHOW PROCESSLIST查看所有运行的线程,找到存在问题的线程进行优化,也可以查看连接数判断是否需要进行限流

3.Explain： explain + SQL语句
    1.使用explain关键字可以模拟优化器执行SQL语句。分析语句是否存在问题
    2.使用explain 的查询结果字段分析
        1.id:select 查询的序列号,包含一组数字,表示查询中执行select子句或者操作表的顺序
            1.id相同：执行顺序由上至下
            2.id不同：如果是子查询,id的序号会递增,id值越大优先级越高,越先被执行
            3.id相同不同都有：id大的先执行。id一样的顺序执行
        2.select_type  查询的类型,主要用来区别  普通查询、联合查询、子查询等复杂查询
            1.SIMPLE：简单的查询,不包含子查询和union联合查询
            2.Primary：查询中如果包含子查询，最外层的查询被标记为 Primary
            3.subQuery：在select或者where列表中 被包含的子查询
            4.derived：from中包含的子查询被标记为衍生表,会把查询结果放在一个临时表
            5.union：第二个select出现在union之后.被标记为联合。若union包含在from子句的子查询中,外层的select将被标记为4.衍生表
            6.union result：使用union产生的结果集
        3.table：显示这一行数据是来自那个表
        4.type：访问类型排列   最好到最差   system》const》eq_ref》ref》range》index》all  查询最少到range级别  最好到ref
            1.system：表只有一行记录(等于系统表)。是const特例  平时不会出现  可以忽略
            2.const：通过索引一次就找到了,const用于比较主键索引和唯一索引。
                     因为只匹配一行,所以很快将主键至于where条件中,Mysql能将该查询转换为一个常量
            3.eq_ref：唯一性索引扫描,对于每个索引键,表中只有一条记录匹配。常见于主键或者唯一索引扫描
            4.ref：非唯一的索引扫描,返回匹配单独值的所有行
            5.range：只检索指定范围的行,使用一个索引来选择行,key列显示使用了那个索引    一般就是>、<  、between and 、in
            6.index：全索引扫描。只遍历索引树
            7.all：遍历全表查询数据
        5.possible_keys：显示可能应用在这张表中的索引,一个或者多个，但是不一定被实际使用到
        6.key：实际使用的索引  如果为null则没有使用
            1.覆盖索引：我使用1,2两个字段创建索引,而查的也是12字段。不需要通过索引去查找其他信息就是覆盖索引
        7.key_len：表示索引中使用的字节数,    相同结果下 key_len越小越好
        8.ref：就是你的条件后面的值。没有=null  有的话分常量const  和  对于值的库 表 字段名
        9.rows：读取行数
        10.extra额外：包含不适合再其他列显示 但是十分重要的额外信息
            1.using fileSort：无法利用索引完成排序操作,而是使用了一个外部排序。叫文件排序  常见：group by与组合索引个数 顺序不吻合
            2.using temporary：mysql对结果排序使用了临时表。常见于 order by、group by。
            3.using index：如果同时出现了using where 说明索引被用来执行查找。没有出现using where 说明索引用来读取数据 而不是查找数据
            4.using where 表示使用了where条件
            5.user joinbuffer：使用了连接缓存
            6.impossible where：where条件不可能成立   name=王昊杰 and  name=王洁
4.Explain 的作用
    1.通过查询的结果id可以判断表的加载顺序
    2.通过select_type可以判断查询语句有哪些操作类型   union、子查询 等
    3.判断哪些索引可以使用
    4.判断哪些索引被实际使用了
    5.通过ref可以判断表之间的引用
    6.通过rows每张表有多少行被查询出来

5.Order by优化：
    1.order by 子句使用最左前列。或者搭配where 满足最左前列都可以使用using index 否则会产生文件外排序
    2.如果使用using fileSort有两种算法
        实现原理：将数据拿到内存排序区进行排序。如果内存装不下会进行数据分块,再对各数据块进行排序.最后将各个数据块合并成一个结果集
        1.双路算法：首先从磁盘读取主键和排序字段,在内存进行排序,在通过排序好的ID读取磁盘,返回数据
        2.单路算法：从磁盘读取所有需要的列,在内存进行排序,然后将结果返回.避免二次操作磁盘。
        问题：当内存不够放所有数据,单路和双路都可能变成多路 。  单路算法更容易超过内存
        解决方案：
            1.使用order by 最好不要使用select *
            2.可以适当调大sort_buffer_size内存的大小。要根据系统能力适当增大,因为是针对每个线程的
            3.可以适当调大max_length_for_sort_date。提高这个参数会增加用单路概率,但是设置太高会提高超过内存最大值.进行多路算法
        使用了多路算法的明显症状是：高磁盘I/O活动和低的CPU使用率
    开启了binlog日志,mysql默认不允许创建函数。 将默认开启
    show variables like 'log_bin_trust_function_creators'
    SET GLOBAL log_bin_trust_function_creators = 1;
6.MySQL 数据库 CPU 飙升到 500% 的话他怎么处理?
    1.通过top命令查看是什么进程导致的CPU飙升
    2.如果是mysql导致的下查看线程数是线程过多适当进行限流
    3.如果是SQL执行问题,通过Explain分析SQL具体情况进行修改(无索引或没有命中、数据库参数不合理等)
7.说说 MySQL 的主从复制?主从复制中涉及到哪三个线程？
    1.从节点IO线程:连接主节点,请求从指定位置读取binlog日志
    2.主节点log dump线程：接收到IO线程的请求后读取指定位置之后的binlog日志信息和位置信息
    3.从节点IO线程：获取到binlog日志信息放入relayLog和masterInfo中,masterInfo用于告诉告诉主节点下次读取binlog日志位置
    3.从节点SQL线程：检测到relayLog变化后会进行binlog日志解析,并且在当前数据库执行
8.异步复制存在数据丢失？
    1.主节点不会主动下发,等待从节点发请求,当主节点宕机,如果数据没有下发从节点并且存在故障转移,那么数据将会永久丢失。  MYSQL8默认复制策略、性能快。
    2.同步复制：主节点写入到binlog中后需要同步到所有从节点,并且都执行成功后。主节点才处理新的请求, 保证数据安全但是性能低
    3.半同步复制：主节点写入binlog后数据未提交前发送给所有从节点,只要有一个从节点将数据存入relayLog中且返回ACK(确认字符)。主节点就接收新请求。  保证数据不丢失,性能也比同步复制高
9.主从复制延迟的原因？解决方案？
    1.采用异步复制    2.网络延迟    3.主节点并发高,从节点只有一个SQL线程跟不上
    解决方案：1.网络优化  2.从库使用固态提高IO性能   3.并行复制：开启多个SQL线程执行relayLog,通过事务ID判断是否在同一个事务组,在一个组可以进行并行处理提高效率
10.为什么要进行读写分离？谈谈你对数据库读写分离的理解？
    1.通过部署多台数据库,主机进行写操作,从机进行读操作来提高主机写入性能
-------------------------------------------------------------------------------------------
MYSQL锁
    1.从数据操作类型分
        1.读锁：共享锁
            1.当A给一个表加读锁.A可以读这个表不能修改这个表也不能读其他表。而B可以读这个表但是修改这个表会被堵塞。一直到A解锁
        2.写锁：排它锁
            1.A加写锁。A可以读这个表也可以修改这个表。但是不能查询或操作其他表。B不能查询或操作被锁的表。但可以操作其他
        3.乐观锁
            更新的时候携带版本号,通过cas更新
        4.悲观锁
            使用读写锁进行加锁处理
    2.从s数据操作粒度来分
        1.行锁：只对一行加锁,不影响其他行。开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高。  Innodb采用索引使用行锁,索引失效会导致行锁变成表锁
        2.表锁：对整个表加锁,开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突概率高，并发度最低。
        3.页锁：对一页数据加锁,开销和加锁时间介于行表锁之间。会出现死锁。并发度一般
    3.行锁是怎么实现的？ //todo
        innodb通过索引字段加锁。通过页上位图处理 0表示无锁1有锁,而Oracle通过给数据行加锁实现
        所以当不使用索引时innodb行锁会变成表锁,如果两个普通索引都给同一个主键索引加锁会产生锁冲突,位图方式比数据行处理节约内存。
    4.间隙锁(GAP)
        当用范围查询数据时,范围内数据都会加锁,可以解决幻读问题。但是会造成性能下降
    5.InnoDB 锁的算法有哪几种？
        1.记录锁：只锁定索引,而不是记录
        2.间隙锁：索引记录间隙加锁
        3.Next-key lock: 记录锁和间隙锁结合,既锁住了索引,也锁住了间隙
    4.SQL命令：
        1.查看所有表加没加锁 。 show open tables；看 IN——use这个如果0没有锁
        2.加锁  lock table 表名 【read||write】
        3.解锁  unlock tables   所有表解锁
        4.show status like 'table%'   通过这个分析系统上的表锁定。
            1.tables_locks_immediate:产生表级锁定的次数。表示可以立即获取锁的查询次数。每次增加1
            2.table_locks_waited：出现表级锁定争用而发生的等待次数。这个值高说明存在严重的表锁争抢情况
        6.如何锁定一行：  begin；  select * from user where id = 8 for update ； 取消锁定commit；
        7.如何分析行锁定： show status like ‘innodb_row_lock%’
            1.innodb_row_lock_current_waits:当前正在等待锁定的数量
            2.innodb_row_lock_time:从系统启动到现在锁定总时间长度
            3.当等待次数很高并且等待总时长也不小的时候。就需要分析看看什么问题