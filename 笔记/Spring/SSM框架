SpringMVC：
    拦截用户请求,DispatcherServlet承担中介职责将用户请求通过HandlerMapping去匹配controller,然后controller执行具体操作
Mybatis：
    是对jdbc的封装,通过配置文件关联到实体类Mapper文件,mapper中配置 sql的映射。每次交互中通过sqlSessionFactory拿到一个sqlSession，再执行sql命令

架构分层：
    1.视图层：视图层和控制层结合紧密,视图层主要是页面的展示
    2.控制层：控制要调用的业务层代码
    3.业务层：业务代码的逻辑处理，可能会涉及到持久层接口的调用
    4.持久层：负责与数据库交互,进行CRUD的操作
SSM原理流程：
    1.客户端发送请求到DispatcherServlet
    2.DispatcherServlet控制器查询HandlerMapping,找到对应Controller
    3.Controller调用Service进行业务处理,处理中可能涉及到去DAO进行数据库操作。最终将响应返回给客户端
低耦合高内聚： https://blog.csdn.net/ws9029/article/details/116454153
    低耦合：模块和模块之间交互不可避免,交互性低也就是耦合低才能让模块直接增加独立性。实现多模块可拆卸
    高内聚：功能内聚,一个模块只需要做自己负责的事情,不过分关心其他事情。 保证模块拆卸过程中对功能控制的精准性
    总结：低耦合高内聚的思想其实就是将系统分成多个模块分而治之的思想。对系统来说将会有更高的可靠性.系统升级微服务也轻松一些
Spring： 开源的轻量级框架,简化应用程序开发,降低耦合度。
    1.IOC(控制反转):让Spring帮助创建对象以及管理对象之间的依赖关系,降低对象间耦合度
        容器初始化过程：
            1.XML方式
                1.创建 ClassPathXmlApplicationContext 调用构造方法时,
                    一、先是调用顶层父构造方法对部分属性初始化
                    二、调用父类setConfigLocations设置传入属性值,Spring配置文件路径
                    三、调用父类refresh方法对xml中bean进行载入封装
                        1.判断是否存在Spring容器,存在销毁然后创建,保证refresh创建的时新的容器
                        2.通过路径将XML解析成文档对象,然后封装程key-value存入一个Map中,这个过程加锁保证线程安全. key为String value为BeanDefinition（内部封装 单例、多例、参数）
            2.注解方式
                1.配置自动扫描路径,启动时会根据路径对所有类进行扫描
                2.直接将含注解的bean注册到容器中
        Bean实例化参数配置： //todo 了解动态代理和CGlib代码 搭配作用域scope使用
            1.scope(默认单例)  注解方式：@Scope(value = WebApplicationContext.SCOPE_SESSION,  proxyMode =ScopedProxyMode.INTERFACES)
                1.singleton：单例 ：每一个bean只有一个实例。Spring创建就会被加载,生命周期和Spring一致。
                2.prototype：多例 (懒加载,用的时候才走初始化用完就会销毁)：每次对bean的请求都会创建一个实例
                3.request：请求,每次HTTP请求都会生成一个bean,表示在一次HTTP内有效
                4.session：在同一个session内,使用一个bean
                5.global session：在一个全局session内 使用一个bean
            2.id、class：id自定义一般为类开头字母小写、class为全路径名
            3.init-method 初始化方法
            4.destroy-method 销毁方法
        Bean实例化方式
            1.无参构造：<bean id="bean1" class="demo3.Bean1">
            2.工厂静态方法： <bean id="bean2" class="demo3.Bean2Factory" factory-method="getBean2">
            3.工厂实例方法： <bean id="bean3Factory" class="demo3.Bean3Factory"> <bean id="bean3" factory-bean="bean3Factory" factory-method="getBean3">
        依赖注入： 优点:将对象的依赖关系交给容器自动化完成,解耦合    缺点：实例bean源码复杂,不易学习。 通过反射创建对象有损耗,但是从便利性和实用性这点损耗可以忽略
            1.构造方法：优点：自动寻找bean进行注入 缺点：可能存在多个构造方法,不方便维护。 但是IDEA仍然推荐这种方法进行代码书写(优点：保证依赖不为空避免空指针)  如果一个依赖有多种实现推荐使用set注入
            2.setter方法：优点：可以继承、设置默认值、用的时候进行注入  缺点：无法在对象构造完成后立刻使用 需要调用set方法  可以搭配Required注解强制要求使用者注入该属性
            3.接口注入：使用较少,因为强制被注入对象实现接口
            4.P指针注入(本质就是set)：配置文件使用较多 优点：代码整洁  缺点：可维护性不高,如果属性多会导致配置过长
        依赖注入注解：
            1.Autowired:按类型自动装配
            2.Qualifier:不能单独使用,配合 Autowired按名称自动装配,需要Autowired后面增加装配名称
            3.Resource：默认按名称装配,找不到按照类型装配！  Spring提供注解 但是实现需要引入第三方工具 javax.annotation.jar
            4.Value：⽤于注⼊基本类型,可以标注在成员变量上,set方法上。不能标注构造方法上！！
            5.Bean：作用在方法上,将方法返回的类注入到容器中
            6.PathVariable：用来接收路径参数的注解
            6.Configuration：等同于Bean.xml,通过annotationConfigApplicationContext加载,
            7.Component:等同于application.xml,通过ClassPathXmlApplicationContext加载
            8.Repository|Service|Controller:DAO、业务层、控制层特殊的注解,作用和Component相同
            9.Configuration和Component区别：
                官方解释：1.加载方式不同   //todo 2.Configuration会进行cglib代理(简化就是获取bean 一种获取到的是代理对象  一种获取到的原始对象)
    2.AOP(切面编程): 代码重复部分抽出来,通过动态代理技术在不改变源码基础上进行代码增强  常用于：权限控制、日志处理、事务等
        1.相关注解
            1.Aspect(切面)： 会包含一些切点以及相应的增强
                1.Before前置通知：目标方法调用前调用通知方法
                2.After后置通知：目标方法调用后调用通知方法
                3.After-returning最终通知：目标方法成功执行之后调用通知方法  (异常不执行)
                4.After-throwing异常通知：目标方法抛出异常后调用通知方法
                5.Around环绕通知：目标方法调用前和调用后都调用通知方法
                区别：
                正常执行顺序： 环绕前置-》前置通知-》执行代码-》环绕之后-》后置通知-》最终通知
                异常执行顺序： 环绕前置-》前置通知-》执行代码-》环绕之后-》后置通知-》异常通知
                注意：只有当环绕后置未对异常处理继续抛出时候才会出现异常 否则就会进行最终通知
            2.JoinPoint(连接点)：程序中某一行为,例如执行过程中所有字段、方法都是连接点。 Spring只支持方法类型连接点
            3.Pointcut(切点)：我们自定义要拦截的连接点组合就可以称为切点！！
            4.Weaving(织入):把切面增强内容应用到目标对象并创建代理对象的过程
        2.代理对象生成时机？
            1.初始化的时候会找到所有实现 BeanPostProcessor 的子类进行遍历执行初始化后置方法,其中一个就是实现AOP动态代理,内部会判断是否有增强
            如果有增强方法就会通过class判断使用CGLIB还是JDK生成代理对象
        3.为什么三级缓存解决AOP循环依赖问题？
            由上述可知,初始化结束才能获取到代理对象,如果AB都需要对方代理对象,如果没有三级缓存,就会造成一方获取到的是原始对象,导致一个保存的原始对象和一级缓存的代理对象产生误差
            而三级缓存内部其实提前调用了,初始化之后的方法获取代理对象.
        多个AOP执行先后顺序？
            1.xml通过order属性配置   2.注解使用order注解  3.实现类ordered重写getOrder方法实现多个AOP按序执行,order越小越先执行
            执行过程中切面顺序和多个过滤器一致,最先开始的切面最后结束！！！！
    3.事务控制
    4.方便集成测试
    5.降低API使用难度,对很多API进行封装提供Template调用
单例多例模式下线程安全问题：
   单例：方法局部变量、ThreadLocal是线程安全的,但是全局变量、静态变量存在线程不安全情况
   多例：每次创建一个新对象,不存在多线程共享一个Bean。所以ThreadLocal、局部变量、全局变量都是线程安全的、静态变量存在线程不安全情况
   为什么Spring中controller、service、dao却线程安全？
       答：因为通常情况下我们都是调用他们内部的方法,对于JVM虚拟机栈来说是线程私有的,不涉及线程安全问题。
代理模式：
   作用： 1.可以对方法进行增强,例如AOP实现增强方法   2.控制是否可进行目标方法的调用
   静态代理： 需求变了改代码实现功能    优点：容易理解,使用方便 2.如果改动较大,大部分类都要修改
   动态代理： 增强方法写在代理类中,只需要将业务代码生成一个代理对象即可   优点：耦合度低,灵活度高便于维护
       JDK Proxy: 实现 InvocationHandler接口 重写invoke方法进行增强。 基础是反射机制,因为执行方法调用method.invoke。创建实例调用proxy.newProxyInstance
       CGLib Proxy：实现 MethodInterceptor接口 重写intercept方法进行拦截增强。 原理是创建目标类子类,setSuperClass实现,覆盖其中方法进行增加。所以final方法不可用
       差异性：
           1.JDK代理是JAVA原生提供的,JDK8性能提高很多而且写起来方便,但是只能对接口进行增强   CGLib都可以进行增强,Spring提供的还需要引入ASM.jar,基于ASM(字节码操控框架)实现
           2.JDK代理直接编译生成字节码加载到JVM而CGLIB使用ASM效率较低,但是执行方法JDK使用反射而CGLIB使用FastClass为代理类和被代理类各一个类,通过index确定调用方法  整体：CGLIB速度快
           3.JDK代理对接口处理,所以不支持私有、保护。接口支持static但是没有实现方法不能代理    CGLIB创建子类方式：所以私有、保护、final、static等方法也不可代理
本来可以new对象,为什么要使用Spring IOC呢？
   1.主要好处就是bean的集中管理,降低耦合度  其次Spring提供了一整套Bean的生命周期管理,对于方法增强也有AOP处理
Spring Bean： 生命周期
    1.Spring启动时会扫描注解/XML/JavaConfig把需要管理的bean封装成BeanDefinition对象,然后统一放到beanDefinitionMap中,key就是beanName值就是BeanDefinition
    2.BeanFactoryPostProcessor 工厂后置处理器可以对Bean元数据进行修改,XML占位符就是他的子类注入进去的,一般用的比较少。 敏感数据比如密码之类的可以在这一层进行解密使用  Configuration注解类的加载成beanDefinitionMap
    3.InstantiationAwareBeanPostProcessor 感知Bean实例化处理器 父类是BeanPostProcessor。 通过AbstractAutowireCapableBeanFactory#createBean触发执行
        触发机制：Bean实例化之前会检查是否存在该接口,并触发下述1接口,1接口任何一个返回非null都会导致当前Bean生命周期缩短
        1.postProcessBeforeInstantiation: 在Bean实例化方法之前执行.  如果返回null就会执行doCreateBean进行实例化(内部有一个方法判断如果不存在构造或者多个构造的匹配方案)
            1.返回值决定后续实例化是否执行，如果返回空继续执行后续实例化等方法,如果返回AOP代理对象,生命周期会缩短,只执行postProcessAfterInitialization完成Bean加载,也不继续执行销毁方法
            2.作用就是替换普通实例化Bean,主要应用与框架层面,使用代理类替换普通类。 如果是我们日常业务中想要替换Bean,Spring提供了一个适配器类InstantiationAwareBeanPostProcessorAdapter
        2.postProcessAfterInstantiation：在bean实例化之后,初始化之前执行. 当前该Bean可能部分属性还没有设置值
            1.当前Bean结果返回true或false会直接影响当前Bean后续3是否执行,各Bean之间互不影响
        3.postProcessProperties：上述第二步结果为true,并且有一个check方法为true 的时候才会执行。是两个条件,可以给Bean属性赋值,也可以对xml的注入参数做修改
        4.postProcessPropertyValues: 已经被标注@Deprecated，Spring5.1被postProcessProperties取代。
    4.上述3如果没有缩短生命周期,接下来就执行Set依赖注入
    5.依赖注入之后,初始化之前可以在目标Bean上实现一些感知方法   具体回调方式如下两种
        1.invokeAwareMethods中通过判断类型直接进行回调的方法 例如:BeanNameAware、BeanFactoryAware、BeanClassLoaderAware
        2.通过BeanPostProcessor#postProcessBeforeInitialization方法实现的 例如：ApplicationContextAware
        问题：为什么之前在方法内,后面采用BeanPostProcessor方式实现回调？
             这个我也不太清楚,可能是Spring升级 采用修改关闭,扩展开放原则所以采用扩展方式添加！！！   加载顺序：第一种先执行回调.
    6.BeanPostProcessor：初始化阶段,实际初始化阶段和5(感知回调)都在初始化Bean中完成,执行顺序  invokeAwareMethods->下1->上2->下2
        1.postProcessBeforeInitialization：调用初始化方法之前执行,Spring一些感知方法的回调就是通过这个执行的！
        2.postProcessAfterInitialization:调用初始化方法之后执行,
    7.生命周期接口
        1.InitializingBean:自定义初始化执行的时候都会进行感知方法回调,所以可以对前面获取的对象放心使用。 还可以通过注解,XML配置实现完成配置！执行顺序不重要,都是初始化一般不会写多个！！
        2.DisposableBean:自定义销毁方法执行！容器关闭,调用close就可以触发
1.理解JAVA对象和Spring对象的区别
    1.java对象创建对象是使用堆中的类对象(只描述了类基本信息)作为模板创建
    2.Spring创建的BeanDefinition(包含了作用域,构造传入值和set传入值,初始化方法名、销毁方法名,如果是工厂类型实例还会有工厂名和工厂方法名)
BeanPostProcessor 注册时机与执行顺序?那么Spring是如何保证BeanPostProcessor在我们的业务Bean之前初始化完成呢？
    1.源码中对他提供的和我们自己写的Bean做了划分,加载的时候也是先注册 BeanPostProcessor(Bean后置处理器) 然后才会对单例非懒加载的Bean进行注册
    2.每种类型中执行顺序又可以通过实现类进行加载排序   1.PriorityOrdered   2.Ordered   3.什么都不加    执行顺序按照123执行。 内部优先级越小越早执行
三级缓存： doCreateBean中采用三级缓存解决循环依赖问题
    一级缓存(singletonObjects)：存放的是所有创建好的单例Bean
    二级缓存(earlySingletonObjects)：完成实例化，但是还未进行属性注入及初始化的对象 由三级缓存放入
    三级缓存(singletonFactories)：提前暴露的一个单例工厂.拿到的是一个工厂对象,通过它实例对象每次可能都不一样！！！Bean就不是单例了
        解决:二级缓存中存储的就是从这个工厂中获取到的对象实例。 当使用三级缓存getObject获取就会移除三级缓存放入二级缓存
    流程:
        当A完成构造方法调用,将Bean放入三级缓存,进行属性注入时候发现B没有被加载,所以进行B的创建,B创建时候发现要注入A,尝试一级缓存获取\二级获取,最后从三级缓存拿到一个没有初始化完全的Bean
        然后B完成依赖注入和初始化操作后将B放入一级缓存,继续返回A中注入B完成依赖注入和初始化,最后将A放入一级缓存。 因为B拿到A是一个引用,所以最终B中的A也是一个初始化完全的Bean
    循环依赖不支持情况？   1.放入三级缓存的前提是执行了构造方法,所以构造器的循环问题不能解决   2.
Spring循环依赖如何解决？
    1.首先区分Spring中出现循环依赖是什么情况
        1.AOP代理对象产生循环依赖
            1.使用@Lazy注解，延迟加载    2.使用@DependsOn注解，指定加载先后关系     3.修改文件名称，改变循环依赖类的加载顺序
        2.DependsOn产生循环依赖
            只能取消注解让它不出现循环依赖
        3.多例循环依赖
            因为多例情况下不走缓存,所以只能变成单例解决
        4.单例构造器循环依赖
            1..使用@Lazy注解，延迟加载   2.先加载的构造器改为Set注入
BeanFactory和ApplicationContext有什么区别？
    1.ApplicationContext是BeanFactory的一个子接口,所以ApplicationContext可以理解为是BeanFactory基础上的一个增强
        1.ApplicationContext:采用一次性加载  优点：1.如果配置错误启动就会报错 2.运行过程中速度快,因为不涉及太多加载 缺点：一次性加载太多比较吃内存,首次加载很慢
            加载：ClassPathXmlApplicationContext
            增强1.MessageSource 国际化  2.ResourceLoader资源访问(绝对路径相对路径处理)  3.AOP增强
        2.BeanFactory：懒加载  优点：首次运行速度快 缺点:配置错误只有访问时候才能发现,而且过程中可能涉及加载影响速度
            加载：XmlBeanFactory
        3.FactoryBean:工厂Bean,使用工厂模式,提供工厂方法来实例化Bean！







































