发展历程
90年代：使用单机数据库 +静态html页面。  访问量不大  单个数据库足够使用
        1.数据量总大小 一个机器放不下 ----》300w必须创建索引
        2.数据的索引（B+ Tree）一个机器的内存放不下时
        3.访问量多(读写混合)--》一个服务器受不了
        16G内 存能放下大概 2000W 行数据的索引，  简单的读和写混合访问量3000/s左右没有问题，
Memcached（缓存）+MySQL + 垂直拆分
        1.网站80%都在查询。每次操作数据库十分麻烦,为减轻数据库压力。可以使用缓存
        2.但是数据量大了还是会出现最初内存不够  访问量大无法承受的问题
读写分离：主库承担写的压力，分库承担读的压力
        1.对于读多写的少  适用
        2.写入量大  会造成主库无法承受
水平拆分：数据量变成1/n,,可以提高并发量和稳定性
        1.分片式事务不好解决
        2.跨库join性能降低。而且维护难度提高。
云数据库：
缓存适用于数据变动不大。但是像用户日志。数据量大变动又快的东西 关系型数据库就不适用了

NOSQL四大分类
  1.键值对key value存储：Redis（C编写） 、Tair 、memcache
     优点：查找速度快
     缺点：数据没有结构,通常只被当作字符串和二进制数据
     应用场景：数据缓存，日志
  2.文档型数据库： 基于分布式文件存储的数据库 MongoDB(C++编写) 主要用来处理大量的文档 介于关系和非关系之间是最像关系型数据库的
     优点：数据结构要求不严格
     缺点：查询速度低
  3.列存储数据库： Hbase 、 分布式文件系统
     优点：查找速度快,可拓展性强
     缺点：功能相对局限性。因为是以列存储的
     应用场景：分布式文件系统
  4.图形关系数据库： 比如朋友圈,社交网络,广告推荐  Neo4j
     优点：利用图结构算法,查找最短路径
     缺点：很多时候需要所有数据才能得出结论,不好做分布式集群
     应用场景：社交网络,朋友圈,广告推荐
----------------------------------------------------------------------------------------------------
RDBMS（关系型数据库）
  优点1.通用sql,表形式便于理解,降低数据冗余和不一致概率
  缺点1.高并发下读写效率低 2.数据库很难横向扩展  3.复杂sql,多表连接
NOSQL区别：
  优点 1.方便扩展(数据直接无关系,很好扩展)
      2.大数据量高性能(1s读11万。写8w,nosql缓存是一种细粒度的缓存,性能比较高)
      3.不需要事先设计数据库。数据类型多样型
---------------------------------------------------------------------------------------------------
Redis：全称 远程字典服务
  是一个开源的使用c编写的、支持网络、可基于内存可持久化的日志型、key-value类型的数据库,提供多种API。也被称为结构化数据库
  优点：
    1.支持持久化,效率高(高速缓存),支持事务,数据类型丰富,支持主从复制,哨兵,集群
    2.用于发布订阅、地图信息分析、set实现的共同好友推荐等、string实现的计数器、zset排行榜
  缺点：
    1.基于内存的,受物理内存限制,不能做海量数据筛选。不具备容灾恢复。主机宕机前没有同步给从机的数据会丢失
----------------------------------------------------------------------------
一、Redis高可用概述
我们知道，在web服务器中，高可用是指服务器可以正常访问的时间，衡量的标准是在多长时间内可以提供正常服务（99.9%、99.99%、99.999% 等等）。但是在Redis语境中，高可用的含义似乎要宽泛一些，除了保证提供正常服务(如主从分离、快速容灾技术)，还需要考虑数据容量的扩展、数据安全不会丢失等。
1、持久化：持久化是最简单的高可用方法(有时甚至不被归为高可用的手段)，主要作用是数据备份，即将数据存储在硬盘，保证数据不会因进程退出而丢失。
2、复制：复制是高可用Redis的基础，哨兵和集群都是在复制基础上实现高可用的。复制主要实现了数据的多机备份，以及对于读操作的负载均衡和简单的故障恢复。缺陷：故障恢复无法自动化；写操作无法负载均衡；存储能力受到单机的限制。
3、哨兵：在复制的基础上，哨兵实现了自动化的故障恢复。缺陷：写操作无法负载均衡；存储能力受到单机的限制。
4、集群：通过集群，Redis解决了写操作无法负载均衡，以及存储能力受到单机限制的问题，实现了较为完善的高可用方案。
----------------------------------------------------------------------------
官方自带的压力测试工具redis-benchmark
11集
Redis默认有16个数据库。索引0~15  默认是0数据库。
  select 3 ：切换数据库。
  keys *   ：查看当前库中所有的Key
  DBSize   ：查看当前库的大小
  flushAll ：清空全表
  flushdb  ：清空当前数据库
  move name 1 ：将name移动到1数据库
  expire name 10：10s过期时间
  ttl name：（time to live）查看name的剩余过期时间
  type     ：查看key 的基本类型         Exists key    ：判断是否存在

Redis是单线程的

Redis：是一款开源的,内存中的数据结构存储系统,可以用做数据库,缓存和消息中间件.支持多种数据结构。String、Hash、List、set、Zset
与范围查找,bitmaps,hyperloglogs和地理空间geospatial索引半径查询,Redis内置了复制(replication)、事务和不同级别的磁盘持久化
并通过Redis哨兵和自动分区提供高可用性
--------------------------------------------------------------------------------------------------------
底层数据结构：
简单动态字符串SDS ：redis没有直接使用c的字符串而是自己构建简单动态字符串(引文缩写sds)
  Redis中所有的键都是字符串类型,底层是SDS：SDS包含free、len、buf
    buf：char类型的数组buf,每个位置存储字符,最后一个位置存储空字符‘\0’   c中\0会被看成结束
    free:代表未使用的空间大小        C语言修改长度可能溢出,而SDS会判断,如果不满足将进行扩容
    len:目前字符串的长度            C语言不会记录长度,需要遍历得到,而简单动态字符串SDS记录了长度
链表：  C中没有内置链表,Redis实现了自己的链表结构。List底层就是链表
  每个链表节点都有指向前节点和后节点的指针,是一个双向链表,内置表头表尾长度等信息.表头表尾前置后置是null是一个无环链表
字典：  C中没有。  (Redis的底层数据库、Hash)的底层就是字典
  字典用来保存键值对类型,任何一个键值对无论什么类型都可以存放在字典中。
跳跃表： 一个是实现有序集合键，另一个是在集群节点中用作内部数据结构
  是一种有序的数据结构,通过每个节点维持的多个指针从而快速访问节点
整形：   整形是set的底层结构
  包含了length属性,并且不会出现重复
压缩列表：  压缩列表是list和hash的键的底层实现
  当每个键值对的键和值要么小整形要么比较短的字符串,就会用压缩列表。节约内存
String类型               ：点赞。浏览量
  append key value：将这个key的值拼接value,如果key不存在就相当于set
  StrLen key ：获取字符串的长度
  incr key  :相当于i++  可以做浏览量   decr key ：相当于i--   配合incr可以做点赞
  incrBy key 5：相当于i+5    decrBy key 5 ：相当于i-5
  increase  increment     decrement  decrease
  getRange 0 3 :截取字符串下标0-3。[0,3]包含0 1 2 3。  如果想要获取全部 getRange 0 -1
  setRange key 1 XX  :将key的索引1位置字符替换成XX存入
  setex name 30 “whj”：相当于set name “whj”+expire name 30
  setnx(SET if Not eXists)：如果不存在进行set存在返回失败0.而set是覆盖
  mset:批量设置多个值 mset k1 v1 k2 v2 k3 v3       mget:批量获取多个key:mget k1 k2 k3
  msetnx:如果存在设置多个值。一个重复则全部失败。
  getset：先get值然后又set
List类型(列表)     Redis中List类型可以用来当成栈、(消息队列)队列、双端队列、阻塞队列   头尾操作效率高。中间效率低
  lpush list1 1 2 3 4 5:将1-5从左边压入   rpush list2 1 2 3 4 5:将1-5从右边压入
  lrange list1 0 -1： 5 4 3 2 1         lrange list0 0 -1：1 2 3 4 5
  lpop：将左边第一位取出来移除              rpop：将右边第一位取出来移除
  lindex key 3：从左面取索引为3的实际是第四个元素    llen：获取list长度
  lrem key 2 1；从左面删除第一个和第二个1    Ltrim key 0 2：从左边截取list的key索引为0-2然后赋值给key
  rpopLpush key key1：从右边取key的值并移除然后从左边将这个值压入key1
  lset key index value：将key左边索引为index的值更新成value
  linsert key before/after 值1 值2：找到key的值1位置在前面或者后面插入值2
Set类型：    共同关注,共同爱好,推荐好友,（六度分割理论）
  sadd key 值：给set集合插入值,值不可重复   smembers key：获取所有的值  scard获取集合里元素数量
  sismembers key value：查看集合是否存在这个value 返回0/1    srem key value：移除key中的value元素
  无序不重复集合：srandmember key 1:随机获取key集合的1个元素  spop key：随机删除key中的一个元素
  smove key1 key2 value：将key1的value移动到key2集合中 不指定value则是随机移动一个
  sdiff key1 key2：key1集合中key2没有的元素     sinter key1 key2：key1,key2都存在的元素
  sunion key1 key2；将key1和key2元素合并去重
Hash类型：也是键值对,值是map集合 key-map   存一个变更的数据。用户数据 适合存储对象session信息
  hset people name whj： 插入值      hget people name：获取值    hgetall people：获取people中所有键值对
  hmset people name whj age 20：插入多个值  hmget people name age：获取多个值  hdel people name：删除name键值
  hlen people ：获取people中的键值对个数   hexists 键名 值键名：判断是否存在返回0/1
  hkeys key：获取key中的所有key   hvals key：获取key中的所有值
Zset类型：  存储班级成绩 工资表  带权重执行  排行榜
  zadd k1 score v1：
  zrangeByscore salary -inf +inf：查询指定范围的元素 zrangebyscore salary (2500 5000 ====>(2500,5000]
  zrangeByscore salary -inf +inf withscore:查询最小到最大并携带成绩
  zrange salary 0 -1：查看所有元素     zrem salary xiaohong：移除小红
  zcard salary：查看元素数量   Zrevrange 0 1 ：成绩从高到低排列 (参数代表排序的索引。0到1取出来)
三种特殊的：geospatial(地理位置)：附近的人 朋友定位  打车距离计算    底层其实就是zset有序集合.可以使用zset命令查看全部和删除
  geoadd key 纬度 经度 name：添加经纬度和名称。 两级无法直接添加。一般会下载城市数据,在java中一次性导入
  geopos key name name1：查询key中name的经纬度。可以有多个name
  geodist key name name1：查询key中name和name1的距离(m\km\mi(英里)\ft(英尺))
  georadius key 经度 维度 500半径范围 单价km：以给定经纬度为中心,找出某一半径内的元素  附近的人
  georadius key 经度 维度 500半径范围  单价km  withdist(距离)或者withcoord(经纬度)  count 数量
  georadiusBymember key name 500 km：查找指定name的附近500km的地方
  geohash key name name1：将key中的name和name1转换成11位的hash字符串 二维经纬度变成一维字符串,越相似越近
hyperloglog：基数统计  一个key中不重复的值。数据量大可以接受误差
  优点：占用内存小 一个人访问多次网页算一个。这种如果要用set实现占用内存大
  PFadd key values：给key添加多个值      pfcount key:统计key的不重复数据个数。可以有多个key则为并集
  pfmerge 新key key1 key2：将key1和key2的值合并生成key3
bitmap：位图 数据结构。都是操作二进制来进行记录。 位存储   统计用户活跃不活跃 10101  登录未登录  打卡
  setbit sign 0 1：设置周一到周日的打卡,第一个是周一到周日,第二个是位0 1。 setbit sign 1 0  setbit sign 2 1
  getbit sign 3：获取周四打没打卡。     bitcount sign start end：默认查看所有为打卡1的个数
-----------------------------------------------------------------------------------------------
Redis事务操作：
  一组命令集合,所有命令都会被序列化,会按照顺序执行。 单条语句具有原子性,多条没有原子性。
  错误类型：编译错误   运行错误   本条运行错误不影响其他运行。但是语法在编译报错则整体报错。 没有隔离性
  开启事务 multi    语句。。。。。    exec执行事务。   discard 取消事务
Watch 监控事务：
  watch命令可以决定事务会回滚还是提交。在事务multi开启之前开启watch监控一些键值对。exec提交的时候检查。键值对没有被其他线程修改
  则提交事务,如果值被修改,则回滚事务。 乐观锁的思想,类似于判断版本。和多线程中CAS的原子引用的乐观锁类似。
  开启：  watch key    取消1.事务exec执行完毕。无论成功失败监控都取消 2.客户端推出 3.手动unwatch 取消
Jedis：使用Java来操作redis,官方推荐java连接redis工具。相当于连接redis的中间件
  new Jedis()参数：ip 端口号 可选：ssl 超时时间       jedis.close()//关闭连接
整合Spring boot：
  Jedis：采用直连,多个线程操作是不安全的,避免不安全,加入jedis pool连接池，更像BIO模式
  netty:采用netty,实例可以在多个线程间共享,不存在线程不安全,可以减少线程数，更像NIO模式
  redisTemplate.opsForValue();//操作String类型  opsForList//操作list   opsForset//操作set
  redisTemplate.getConnectionFactory.getConnertion()//获取连接对象。结果可以进行 flushdb 和 flushall
---------------------------------------------------------------------------------------------
序列化： 任何存储,传输都需要进行序列化,只不过数据库内部已经解决了.在插入的时候进行序列化.在取出来的时候进行解析,而redis内部并没有
解决,redis的value是byte array字节数组。所以需要将数据结构转成字节数组。而字符串几乎就是字节数组,所以不需要转换
  序列化：把对象转化为可传输的字节序列(字节数组)过程称为序列化。
  反序列化：把字节序列(字节数组)还原为对象的过程称为反序列化。
  方式：JDK（不支持跨语言）、JSON、XML    技术选型关键点 1.序列化速度 2.序列化字节数组大小
  JAVA序列化中常见的问题: 问题一：static 属性不能被序列化
  原因：序列化保存的是对象的状态，静态变量属于类的状态，因此 序列化并不保存静态变量。
  问题二：Transient 属性不会被序列化   短暂的属性
  问题三：序列化版本号serialVersionUID  当对象有改动但是版本号一样。不会影响序列化和反序列化。只不过最新的改动会失效
  每个对象必须有版本号，如果没定义会自动生成,自动生成的版本号只要对象有改动就会变更,变更用户就需要更新版本。因此建议手动设置

-----------------------------------------------------------------------------------------------
Redis Config配置文件
注意单位:当需要内存大小时，可以指定   它的通常形式为1k 5GB 4M等:
# 1k => 1000 bytes
# 1kb => 1024 bytes
# 1m => 1000000 bytes
# 1mb => 1024*1024 bytes
# 1g => 1000000000 bytes
# 1gb => 1024*1024*1024 bytes
# 单位不区分大小写，所以1GB 1GB 1GB都是一样的。
为了读取配置文件，Redis必须 以文件路径作为第一个参数开始:
# ./redis-server /path/to/redis.conf
################################## INCLUDES  包含###################################
#  类似下面 include /path/to/other.conf 可以把其他的配置文件配置进来
# include /path/to/other.conf
################################## MODULES #####################################
#  下载第三方的Redis modules模块，make编译
# loadmodule /path/to/other_module.so
################################## NETWORK  网络 #####################################
# bind 127.0.0.1   绑定IP 外网访问注掉这个  并且将下面保护关闭
protected-mode no  # 保护关闭  不然外网访问报错
port 6380   端口号
################################# GENERAL 通用配置#####################################
daemonize yes  #守护线程开启 默认no 需要手动开启 不然退出 进程就结束
supervised no    #管理守护线程的  默认no
pidfile /var/run/redis_6379.pid   #如果守护线程开启 则是后台运行 就需要指定一个pid进程文件
# debug (a lot of information, useful for development/testing)大量的信息，一般用于开发/测试阶段
# verbose (many rarely useful info, but not a mess like the debug level)许多很少有用的信息，但不像调试级别那样混乱
# notice (moderately verbose, what you want in production probably)通知 适合生产 默认是这个
# warning (only very important / critical messages are logged) 警告  只记录非常重要的信息
loglevel notice  #日志级别
logfile ""   #日志文件输出名 为空
databases 16   #默认数据库数量
always-show-logo yes   #是否显示log  默认开启 启动的图案
################################ SNAPSHOTTING  快照  持久化RDB配置################################
#持久化规则  默认携带下面三种  可以自己定义
save 900 1    #900代表时间  如果900s内 有一个key进行了修改  就进行持久化操作
save 300 10    #如果300s内 有10个key进行了修改  就进行持久化操作
save 60 10000  #如果60s内 有10，000个key进行了修改  就进行持久化操作
stop-writes-on-bgsave-error yes   #持久化错误之后是否继续工作  默认开启 避免大量数据丢失.启用监控时考虑设置no
rdbcompression yes           #是否压缩 rdb文件  默认(LZF算法)开启  压缩会消耗CPU资源 但是可以减小RDB文件的大小
rdbchecksum yes             #保存 rdb文件的时候进行错误的校验  在写入文件和读取文件时都校验,关闭后文件损坏不容易发现
dir ./                   # RDB文件和AOF文件所在目录
dbfilename dump.rdb        #RDB文件名
################################# REPLICATION 主从复制#################################
role:master       #角色  主机
connected_slaves:0     #连接的从机   0个
master_replid:876901386875fa3a8c448c5ae59beb5c8e500d77
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:0
second_repl_offset:-1
repl_backlog_active:0
repl_backlog_size:1048576
repl_backlog_first_byte_offset:0
repl_backlog_histlen:0
################################## SECURITY  安全 设置密码###################################
# requirepass foobared   可以将此行放开  后面foobared 换成密码
  config get requirepass 获取  set 插入密码   auth "密码" 验证
################################### CLIENTS 客户端####################################
# maxclients 10000   #连接redis的最大的客户端数
############################## MEMORY MANAGEMENT 内存配置################################
# maxmemory <bytes>   #Redis最大内存设置
//todo 百度拒绝策略# maxmemory-policy noeviction    #内存上限的处理策略(移除过期的key   2.报错)
############################## APPEND ONLY MODE AOF配置###############################
appendonly no    # 打开aof设置，同时将快照功能置于低优先级的位置
appendfilename "appendonly.aof"     #持久化文件名字
# appendfsync always      #每次修改都会同步   速度比较慢 消耗性能
appendfsync everysec    #每秒执行一次  sync同步 可能丢失这一秒数据
# appendfsync no        #不执行sync同步  操作系统自己同步数据  速度最快 一般不用
--------------------------------------------------------------------------------------------
Redis持久化：redis是内存数据库 如果没有持久化 那么数据断电就消失了
RDB(redis database)方式：  Mysql的Dump方式、Redis的RDB方式。
  在一定的时间间隔内,将内存中的数据库快照snapshot写入磁盘文件中,重启时通过读取RDB文件来还原数据库
  触发条件：
    手动触发：1.save：会阻塞Redis主进程,直到RDB文件创建完毕为止，在Redis服务器阻塞期间，服务器不能处理客户端命令请求
            2.bgsave: fork一个子进程去调用rdbSave方法,RDB文件生成后向主进程发送完成信号,服务器可以处理客户端命令请求
    自动触发：1.配置文件中的save m秒内发生n次变化时，会触发bgsave
             2.在主从复制场景下，如果从节点执行全量复制操作，则主节点会执行bgsave命令，并将rdb文件发送给从节点
             3.shutdown命令时，自动执行rdb持久化。但是使用kill杀掉进程会丢失部分数据
    配置中save的实现原理： 每100毫秒执行一次,判断当前时间戳-上一次成功的时间戳,计数器的次数是否满足sava的配置
                       周期函数：每100毫秒z执行一次,检查配置是否满足,满足就执行bgsave
                       计数器：记录服务器进行了多少次修改。类似binlog一条记录就是一次修改
                       时间戳：记录上一次sava/bgsave成功保存的时间戳
    执行流程：
      1.父进程首先判断是否有sava/bgsave/bgrewriteaof的子进程在执行,如果执行直接返回。不能同时执行,同时大量磁盘写影响性能
      2.父进程fork子进程会阻塞父进程,不能执行客户端指令, 子进程创建RDB文件,完成对原有RDB文件的覆盖
      3.通知父进程完成,父进程更新统计信息。---》更新计数器和时间戳
    保存路径：
      1.配置文件快照中  dir配置RDB目录  dbfilename 指定文件名 默认-》dump.rdb
      2.动态设定：磁盘损坏或空间不足时可以通过指令 config set dir {newdir}和config set dbfilename {newFileName}
    启动载入：
      AOF优先级高,当AOF开启,redis会优先加载AOF文件来恢复数据,AOF不开启会检测RDB文件,自动加载并且处于阻塞状态,文件损坏启动失败并在日志中打印错误
  原理：rdbsave:用于生成 RDB 文件到磁盘
       radload:用于将 RDB 文件中的数据重新载入到内存中
  优点：性能比较小,fork子线程去做持久化,而且恢复的时候比AOF速度快
  缺点：当redis宕机可能会丢失大量数据。而AOF丢失较少
       RDB在生成数据快照的时候,如果文件很大,会阻塞客户端较长时间
AOF(append only file 追加文件)方式：  Mysql的Binlog、Redis的AOF、Hbase的HLog。
  将每次执行的增删改命令保存在磁盘,恢复的时候将所有命令执行一遍。类似于mysql中的binlog 实时性好,丢失数据少,主流
    执行流程：
      1.所有的增删改命令会追加到 AOF 缓冲中。
      2.AOF 缓冲区根据对应的策略向硬盘进行同步操作。
      3.AOF保存条件满足,fsync/fdatafync函数被调用,将写入的内容真正保存在磁盘文件中
    AOF保存模式：
      1.appendfsync always 每次修改都会同步：写入和保存都由主进程执行,会阻塞主进程。  速度比较慢 消耗性能
      2.appendfsync everysec每秒执行：写入主进程执行,会阻塞,保存子线程调用的,不会阻塞,但是保存快慢影响写的阻塞时长
        1.save不在执行,距离上次保存成功超过1s,执行写入和保存
        2.save不在执行,距离上次保存成功没超过1s,执行写入但不保存
        3.save在执行,距离上次保存成功超过2s,执行写入但不保存
        4.save在执行,距离上次保存成功没超过1s,直接返回不保存也不写
        总结：官方说之丢失1s不准确,实际丢失可以超过2s的
      3.appendfsync no不保存：每次都会写入AOF文件末端,但是不保存。 写入和保存都由主进程执行，都会阻塞主进程。
        1.redis关闭2.AOF功能关闭3.系统的写缓存被刷新（可能是缓存已经被写满，或者定期保存操作被执行）
      4.第1种安全性最高效率最差 第二种通常情况下丢失不超过2s,安全性和效率兼顾
    AOF重写：   AOF随着时间推移会越来越大,创建一个新的AOF替代原有文件,保存的数据库状态一样,但是体积小
      1.重写并没有读取原有AOF而是将内存中数据库用命令重写一份。类似RDB模式
      2.AOF后台重写 通过配置的大小和增长率。超过配置大小并且体积是上次重写体积的一倍会自动重写AOF   手动调用重写 bgrewriteaof
      3.触发机制  Redis会记录上次重写时的AOF大小，默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发。生产一般3g
      4.重写的时候除了缓冲区还会创建一个重写缓冲区,AOF创建完毕将重写缓存区保存的数据同步到AOF中,保证和服务器数据一致然后替换原本AOF文件,完成重写
    AOF文件修复：会将错误的指令删除
      redis-check-aof --fix appendonly.aof
    RDB文件修复：会将错误的指令删除
    AOF数据恢复：1.创建不带网络客户端2.取出写命令3.客户端执行写命令
    优点：

    缺点：
-----------------------------------------------------------------------------------------------------------------
List作消息队列：不能用lpop或rpop因为如果没有消息生产还会一直创建连接。
使用阻塞blpop和brpop：时间为0表示一直阻塞。会按照key的顺序进行弹出。弹出信息携带key可以作消息优先级

Redis消息订阅  发布（Publish）与订阅（Subscribe）：    发布者和订阅者都是客户端,订阅的频道(channel)是服务器端.
  每个Redis服务器进程都维持一个 redisServer.pubsub_channels 字典保存,建为被订阅的频道,值为订阅频道的所有客户端,当有消息的时候就遍历所有
  客户端发送消息
    subscribe channel channel1 ：订阅者订阅 channel 和 channel
    psubscribe a? d?* c*: 支持通配符通配符中?表示1个占位符，*表示任意个占位符(包括0)，?*表示1个以上占位符。 注意如果两个通配符包含了同一个频道。会收到两遍消息
    punsubscribe：命令可以退订指定的规则，用法是: punsubscribe [pattern [pattern ...]],如果没有参数则会退订所有规则。
    punsubscribe和unsubscribe只会退订相对应的类型。不能混着用。而且通配符退订必须规则一样。不支持通配符展开
    publish channel message：发布者指定发布给channel 的message  消息不会被持久化,新订阅的不会收到之前的

Redis发布订阅与ActiveMQ的比较
（1）ActiveMQ支持多种消息协议，包括AMQP，MQTT，Stomp等，并且支持JMS规范，但Redis没有提供对这些协议的支持；
（2）ActiveMQ提供持久化功能，但Redis无法对消息持久化存储，一旦消息被发送，如果没有订阅者接收，那么消息就会丢失；
（3）ActiveMQ提供了消息传输保障，当客户端连接超时或事务回滚等情况发生时，消息会被重新发送给客户端，Redis没有提供消息传输保障。
总之，ActiveMQ所提供的功能远比Redis发布订阅要复杂，毕竟Redis不是专门做发布订阅的，
但是如果系统中已经有了Redis，并且需要基本的发布订阅功能，就没有必要再安装ActiveMQ了，
因为可能ActiveMQ提供的功能大部分都用不到，而Redis的发布订阅机制就能满足需求。
------------------------------------------------------------------------------------------
主从复制：  默认情况每台Redis服务器都是主节点,一个主节点可以有多个从节点。从节点只能有一个主节点
  概念：                      读写分离,主机写,从机读。80%都是读操作,减缓服务器压力。
    将一台redis服务器的数据复制到其他redis服务器.主机为主节点。数据复制是主到从。Master 以写为主。slave 以读为主
  主要包括：
    1.数据冗余：主从复制实现了数据的热备份,是持久化之外的一种数据冗余方式。
    2.故障恢复：当主节点出现问题,可以由从节点提供服务。实现快速故障恢复。实际上是服务的冗余
    3.负载均衡：配合读写分离,分担从机读数据的负载。提高并发量
    4.高可用基石：主从复制是哨兵和集群的基础，因此说主从复制是Redis高可用的基础。
  为什么要弄主从复制或集群：
    1.一个redis会发生单点故障,并且处理所有请求压力大。而且单个redis内存有限
  开启主从配置方式：只配置从库,不用配置主库
    1.slaveof host ip：设置自己的主机。将自己变为从机  可以使用 info replication #查看当前库的信息  Redis关闭失效
       1.先保存主节点信息2.创建连接
       3.发送ping指令
          1.socket正常连接,复制过程继续
          2.超时：说明socket连接不可用,断开连接并重连
          3.返回pong以外的结果,说明主节点无法处理。则断开重连。  无法处理原因：可能在处理超时连接的脚本
       4.权限认证5.同步数据集
       6.持续复制(命令传播)
          1.延迟与不一致 ：命令传播是异步的,数据不一致的程度跟网络状态,主节点写的频率和主节点中配置有关。
             repl-disable-tcp-nodelay：设置no,立即发送同步数据,没有延迟。 一致性高
             设置yes,会合并小TCP包从而节省宽带,但会增加延迟,造成主从数据不一致    一直关注性能  一直关注一致性
             多数设置NO,当数据一致性要求低,并且网络不好时设置yes
          2.心跳机制：   redis如何保证主从服务器一致处于连接状态以及命令丢失？
             命令传播阶段,从服务器会利用心跳机制定时向主服务器发送消息 。
             作用：1.检查主从服务器的网络连接状态2.辅助实现min-slaves选项 3.检测命令丢失
    2.配置文件修改replication中的 主机ip和端口号。 redis关闭重启也会自动选择主机
       复制配置文件。1.修改端口号 2.后台自启动开启 3.pidFile改对应端口  4.日志文件名改对应端口  5.RDB文件名+端口
    3.启动命令加入slaveof host ip配置主从复制
  链路主从复制：  主机-》从机1-》从机2-》从机3   虽然从机2的主机是从机1  但是1仍然是从机
    1.当主机1断开连接, 主机2手动输入 slaveof no one成为主机  其他节点会自动更新到这个主节点（哨兵没出来就是手动设置）。注意：主节点重新连接当从机.继续当主机数据会丢失
  Redis的CAP理论：
    redis是高可用性。不是强一致性。当网络端口,主从数据可能会产生很多不一致,但是当网络连接时,从节点会全量复制数据,然后增量复制数据。保证一致性
    全量复制：初次复制或无法部分复制会全量复制。
    增量复制：用于网络中断的情况后的复制,比全量复制效率高,但是当网络中断时间太长,主服务器没有完整保存中断的数据则会进行全量复制
---------------------------------------------------------------------------------------------------
哨兵模式(sentinel)：
  主从切换是主机宕机后手动设置一个从机当新主机,需要手动完成还会有一段时间无法使用.哨兵模式是主机宕机自动投票将一个从库切换成主库
哨兵模式是一个独立的进程。哨兵通过发送命令,等待Redis服务器响应,从而监控运行的多个Redis实例
  作用：1.通过发送命令返回其主从机的运行状态
       2.检测到主机宕机,会自动切换slave为master.通过发布订阅模式通知其他从机修改配置文件。让他们切换主机
  缺点：一个哨兵来监控可能会出现问题。所以需要哨兵集群,各个哨兵直接还能互相监控.形成多哨兵模式
  故障切换过程：假设主机宕机,哨兵1检测到了并不会立马进行failover(故障切换),仅仅是他认为故障了,称为主观下线,当后面的哨兵也检测到了问题,
  数量达到一定值,由一个哨兵发起投票,进行failover,成功后通过发布订阅,让其他哨兵的切换主机,这个称为客观下线
  sentinel monitor mymaster 192.168.11.128 6379 2  监控host和ip的主机,当》=2个哨兵检测出不可用,进行failover
--------------------------------------------------------------------------------------------
缓存穿透和雪崩：
缓存穿透：（查不到）
  用户查一个数据发现redis没有(缓存未命中),然后取数据库查,也没有,如果大量这个请求就会给数据库带来很大负载.就是缓存穿透
  解决方案：
    1.用户查完之后在缓存中放一个空值,同时设置过期时间,再次查询直接返回redis的空值。缺点：空对象太多会影响性能,可能出现数据不一致。
    2.布隆过滤器：是一种数据结构,查询结果以hash存储,会在控制层先校验,不符合就会丢弃.避免底层存储系统压力
缓存击穿：（能查到+缓存过期）
  当一个热点数据在不抗高并发时,如果key过期(访问数据库查询最新数据,并回写缓存),高并发请求数据库导致数据库宕机
  解决方案：
    1.热点数据不过期：
    2.加互斥锁（分布式锁）：保证每个key只有一个线程查询后端服务,其他线程等待,将高并发压力转到分布式锁,因此对它考验很大
缓存雪崩：
  在某一时间段,缓存集中过期.Redis集群全部宕机。
  解决方案：
    1.redis高可用：多设置几台redis。一台挂掉其他还能用（异地多活）
    2.限流降级：  可以停到一些服务保证主要服务运行
    3.数据预热：在正式部署之前,将可能的被大量访问数据先访问一遍,提前加载进缓存.手动设置过期时间,让缓存失效的时间点尽量均匀

单线程多线程  事务特性    百度Redis乐观锁高并发秒杀    setex分布式锁
ssh  ifconfig-》ens33->inet   scp redis-6.2.1.tar.gz root@192.168.47.128     home/whj/桌面




