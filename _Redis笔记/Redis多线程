1. Redis6.0之前的版本真的是单线程吗？
  Redis持久化,集群都是多线程的
2. Redis6.0之前为什么一直不使用多线程？
  因为Redis受限于网络和内存,cpu其实并不是瓶颈,而且操作很快,几乎不占用cpu。而多线程肯定会提高复杂度
  而单线程多路复用IO技术性能也很高。所以没必要
3.Redis6.0为什么要引入多线程呢？
  因为内存不够可以加内存,优化内部数据结构,但是网络IO的读写在redis执行期间占用了大部分CPU时间,如果把网络做成多线程处理,性能会有很大提升
4.Redis6.0默认是否开启了多线程？
  默认不开启。可以在redis配置文件配置,还可以设置线程数.官方推荐线程数小于机器核数。并且超过8个线程就没有什么意义了。
  io-threads-do-reads: yes      io-threads: 4
5.Redis6.0采用多线程后，性能的提升效果如何？
  看过一篇帖子,在4线程IO时相比单线程几乎是翻倍。开启多线程至少要四核的机器
6.Redis6.0多线程的实现机制？
  单线程：多个客户端请求-》多路复用IO-》放到等待队列解析请求-》数据库操作-》等待队列响应请求-》返回客户端   都是主线程操作
  多线程：多个客户端请求-》多路复用IO-》请求分发多线程解析-》数据库操作-》响应交给多线程回写-》返回客户端   解析和回写交给多线程处理
7.开启多线程后，是否会存在线程并发安全问题？
  从实现机制看的话,Redis的多线程部分只是用来处理网络数据的读写和协议解析,执行命令仍然是单线程顺序执行,所以不需要考虑
8.Redis线程中经常提到IO多路复用，如何理解？
  异步阻塞IO,多路指的时多个socket连接,复用指的是一个线程,采用多路复用可以让单个线程高效的处理多个socket连接(尽量减少网络IO的时间消耗)
  而且redis在内存中的操作速度很快,内存内的操作不是瓶颈.  内存操作和多路复用IO实现redis的高效率
9.Redis6.0与Memcached多线程模型对比：
  相同点：都采用了 master线程-worker 线程的模型
  不同点：Memcached 执行主逻辑也是在 worker 线程里，模型更加简单，实现了真正的线程隔离，符合我们对线程隔离的常规理解。
         而 Redis 把处理逻辑交还给 master 线程，虽然一定程度上增加了模型复杂度，但也解决了线程并发安全等问题。


























