索引数据结构
    1.如果不加索引：
        查询数据需要每次访问磁盘一直到查询到想要的数据。  平均情况会访问次数=  总数/2
    2.二叉树：   存放key就是索引字段。value是磁盘所在行的地址
        查询：
            查询数据从根节点开始,比根节点大去右边查直到查询到数据     效率比之间存磁盘高
        插入：
            插入数据会从根节点排序。然后一直排序到最后节点存放
        问题：
            当插入的是顺序结构的话会一直往右下角插。左边没有数据。    导致查询效率低
    3.红黑树(二叉平衡树)
        查询
            查询数据从根节点开始,比根节点大去右边查直到查询到数据
        插入：
            插入数据时按二叉树方式插入。但是会自动将节点平衡。不会导致只有一变有数据
        问题：
            当数据量大的时候。树的高度也很大。查询叶子节点依然会操作很多次磁盘交互
    4.B树     给一个节点开辟大内存。让他可以存放多个元素。索引和索引之间还可以分叉,分叉还可以存储很多元素。
              节点中数据整体从左向右递增  。  横向存放越多,树的高度就能降低。 减少与磁盘的IO操作
        查询
            一次读取一个节点到内存.然后根据查询结果再找下一个节点.每次查询一个大节点.
    5.B+树
        1.将所有的索引元素和磁盘文件地址都放到叶子节点。  叶子节点用指针连接,提高区间访问性能
        2.使用叶子节点的双端来构建树的索引
        3.双向指针作用就是提高范围查找速度
        每一个节点叫做一个磁盘页(磁盘页大小16kb)   索引旁边指针大概6字节  高度为3的b+树可以放2千多万数据
        mysql将索引直接存到内存,基本上只找叶子节点才进行一次IO操作    叶子节点的数据会放到 buffer pool的缓冲池里
    6.HASH(数组+链表)
        1.内部hash算法将字段计算成hash值。然后将字段插入到 数组中对应值所在位置的链表中.列表中存放值和索引磁盘文件地址
        2.很多时候hash索引B+索引高效。  仅能用 = 和in  不能使用范围    hash冲突就是计算的值一样。继续放到链表后面
        问题：hash冲突   不支持范围
存储引擎    是设置mysql表的  不同表可能有不同存储引擎
    MYISAM 中索引文件和数据文件是分离的(非聚集(叶子节点包含MYD磁盘文件地址))  索引文件存储在date目录下对应库的对应表
        1.frm：数据库表结构文件
        2.MYD：数据库表数据文件
        3.MYI：数据库表索引文件
        查询语句先判断是否用到索引.如果用到就去MYI文件中去查询索引,然后找到地址去MYD文件中获取数据
    INNODB
        主键索引 聚集索引,聚簇索引(叶节点包含完整的数据记录)
            1.frm：数据库表结构文件
            2.IDB：数据库表索引和数据文件
        查询语句先判断是否用到索引,如果用到去就去IBD文件中查。IBD文件也是B+树。但是叶子节点存放不是地址而是索引所在行的其他列数据
        非主键索引：也是B+树。叶子节点放的是主键
    综上所述：
        1.聚集索引查询速度块。因为索引到叶子节点所有数据都查到了。而非聚集还需要根据地址去MYD文件查数据。回表
        2.每创建一个单值索引都会产生一个索引树去维护,所以不建议太多单值索引
    面试题：
        1.为什么INNODB必须建主键，并且建议为整形自增的？  自增方便B+树自动维护,否则放到中间树满了会分裂平衡
        因为如果有主键他会自动根据主键索引来组织整张表的数据。如果没有他就会找一个所有值不重复的列来组织整张表数据。
        如果没有自己加一个隐藏列维护B+树结构来组织所有数据。使用整形自增数据在查询时候对比块。而UUID一张串比对复杂。并且占用空间小
        2.B+树和b树区别
        1.b+树支持双向指针  提高范围查找效率
        2.b+树有冗余索引《把所有数据都放到叶子节点   b树没有冗余索引,
        想要查找效率高 树的高度越小越好,将数据携带进索引结构里面的话存储的数据减少导致树的高度变高,而B+树只把冗余索引拿出来
        组织所有数据,然后会直接放到内存里,查询到之后去叶子节点获取数据.相当于一次IO操作。提高性能
