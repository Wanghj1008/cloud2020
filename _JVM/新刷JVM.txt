sun公司的 hotspot 虚拟机     还知道IBM的J9虚拟机。apache的 harmony

定义：
   Java virtual Machine- java程序的运行环境(java 二进制字节码的运行环境)
好处
   1.一次编写,到处运行 (JVM屏蔽了字节码跟底层操作系统的差异,对外提供了一致的运行环境)
   2.自动内存管理,垃圾回收机制(C|C++没有)
   3.数组下标越界异常检查(防止数据覆盖)
   4.虚方法表 实现多态
JVM-》JRE(JVM+基础类库)-》JDK(JRE+编译工具)-》开发JavaSE程序(IDEA+JDK)->开发JavaEE程序(IDE+JDK+应用服务器)
JRE是Java运行时环境：比JVM多出来一些java类库(java.io java.lang java.util)
JDK是Java开发工具包  集成了javac编译器  jar打包工具  javadoc文档生成器

Java编译到执⾏的过程？
   1.编译：首先编译成class文件,语法语义分析,注解处理(lombok)
   2.类加载：类加载器加载  链接 初始化  并不是一次性把所有类都加载 而是通过加载器加载部分类,防止重复使用双亲委派,在堆中创建Class类对象,方法区存储类的相关信息
   3.解释：当执行一个类,会找到类对应的字节码,解释器将字节码解释成系统识别的指令码,非热点代码直接解释运行,通过方法调用计数器发现是热点代码会触发即时编译器进行缓存,下次无需解释直接拿缓存
   4.执行：解释出来的机器码调用硬件执行
你了解JVM的JIT优化技术嘛？
   1.方法内联：就是把调用的方法复制到里面,不进行调用不产生栈帧,减少性能消耗
   2.逃逸分析：判断这个作用域是否逃出代码块,如果没有逃出代码块可以进行栈上分配和标量替换的方式进行优化
----------------------------------------------------------------------------------------------------------
JVM整体结构：
  上层
    1.类装载子系统(类加载器)字节码文件通过类加载器生成大的Class对象
  中层  JVM内存结构（运行时数据区 Runtime date Area）   其中方法区和堆是多个线程共享的,而Java栈,本地方法栈和pc寄存器是线程私有的
    1.方法区(method Area)元数据区:        有可能造成OOM                      有GC
    2.堆（heap）:                       有可能造成OOM                      有GC
    3.Java栈(虚拟机栈):                  有可能造成OOM(内存溢出、栈溢出)       没有GC
    4.本地方法栈：:                      有可能造成OOM(内存溢出、栈溢出)       没有GC
    5.程序计数器(PC寄存器)：                没有OOM                         没有GC      执行速度最快的内存区域
  下层
    1.执行引擎(计算机只执行机器指令,而字节码文件不等同于机器指令,执行引擎将字节码文件翻译成机器语言)
      1.解释器
      2.编译器(JIT编译器)
      3.垃圾回收器
    2.本地方法接口
    3.本地方法库
----------------------------------------------------------------------------------------------------------
类加载器

指令
a++ 和++a区别：
   ++操作是直接在局部变量表的slot槽位上运算的   a++是先把load到操作数栈然后再原来槽位上+1  而++a是先槽位+1然后加载到操作数栈
if判断
   因为操作数栈是4字节,所以小于四个字节的如byte、short、char都会进行填充  比较都是以int类型比较    goto会跳转字节码行号
x=i=0; while (i<10) {x= x++; i++}
   结果为0,先将0load到操作数栈然后槽位+1 最后又将0 store进当前槽位  所以x永远为0
Cinit方法
   会将类中所有静态组合在一起从上到下执行
init方法
  会将类中属性和代码块组合在一起从上到下执行
多态原理(invokeVirtual)  运行期间动态查找,所以效率是比静态方法执行要低
  1.通过栈帧中对象引用找到对象  2.分析对象头找到实际Class   3.class中有虚方法表(vTable) 再链接阶段就生成好了  4.查找虚方法表得到方法具体地址  5.执行方法字节码
try catch原理  （实际就是下面多维护了一张异常表,发生异常后进行匹配然后跳转）
  1.finally的代码实际在字节码中被复制了3份,一份try后面,一份catch后面,一份catch没有匹配到异常分支后面
  2.finally执行完代码后会找到自己捕获的异常然后继续抛出给调用者
  3.如果只有try finally.当finally中写了return 那么就算try抛出异常也会被吞掉
synchronized原理   出现异常正确解锁   只是代码块加锁可以查看字节码,方法级加锁不会体现,因为会表现在对方头里
  1.字节码中加锁(monitorEnter)解锁(monitorExit),为了保证正常解锁。当发生异常时会进入异常表进行解锁
语法糖：   编译器在编译期间自动生成和转换的一些代码.减轻程序员负担
  1.默认构造器     2.自动拆箱装箱   Integer x=1; int y =x;   -》-》  Integer x=Integer.valueOf(1); int y=x.intValue();
  3.泛型擦除：List<Integer> 只有编译期检测类型是否匹配,它的add和get方法在字节码中实际使用的是Object,get后强制转化为定义类型
  4.泛型反射：擦除的是字节码上的泛型信息,方法参数和返回值的信息保存在局部变量类型表。。。 参数和返回值的泛型信息可以通过反射获取到
  5.foreach：数组循环其实和for循环一致       集合循环转实际换成迭代器进行判断(条件：集合必须实现迭代器)  Collection接口实现Iterable接口
  6.switch-string：会生成两个switch 第一次利用String的hashCode和equals转化为字节  第二次利用字节进行直接比较
      问：为什么不直接使用equals而要先利用hashCode？   全用equals效率低,哈希码为了提高效率,为了防止hash冲突所以还需要进行equals
  7.枚举类：转换成字节码后 继承Enum父类,类上final不可继承     构造方法参数：类变量和 ordinal
  8.匿名内部类：new Runnable  实际生成一个无参构造的类  如果final传入参数 内部产生的是一个有参构造的类
      问：为什么必须是final？  因为有参构造器相当于给匿名内部类的属性赋值,如果可变的话内部类的属性就不会同步  所以只能final 不可变参数

类加载顺序
插件jclasslib  java编译成class字节码文件。可以通过这个插件查看
    1.init  是类的字节码文件
    2.clinit 如果有静态代码块或者静态变量赋值就会自动生成
父类静态字段-》父类静态代码块-》子类静态字段-》子类静态代码块-》父类成员变量(非静态字段)-》父类非静态代码块-》父类构造器-》子类成员变量-》子类非静态代码块-》子类构造器

类加载阶段
1.加载阶段(loading)
   1.将字节码文件转换成流加载到内存中,然后又加载到方法区,最后在堆中生成一个类对象
   2.如果这个类父类没有加载会触发父类的加载 。
   3.加载和链接可能是交替执行的
   创建实例首先从类型指针找到堆中类对象,然后类对象找到方法去的class字节码 去调用具体方法
 2.链接阶段（linking）  将 Java 类的二进制代码合并到 JVM 的运行状态之中的过程。 在链接之前，这个类必须被成功加载
   1.验证(Verify):
       1.验证二进制字节码格式是否正确(文件格式验证、元数据验证、字节码验证、符号引用验证),错误会报错
   2.准备(prepare):
       1.为静态变量分配空间,然后初始化默认值,真正的赋值是在初始化完成   (注：静态变量存储位置是和堆中类对象放在一起的)
       2.如果静态变量被final修饰的基本数据类型在编译确定了值,所以准备阶段就完成赋值,不需要等到初始化才进行赋值
       2.如果静态变量被final修饰的引用类型  如 赋值的是new 创建的对象则需要等到初始化阶段才能赋值
   3.解析(resolve)
       1.将常量池中的符号引用解析成直接引用
 3.初始化阶段(initial)
   1.主要执行CInit方法 加载静态代码块、初始化静态变量。
   2.准备过程就是将静态变量分配空间赋默认值。而这个阶段会按照代码的顺序执行静态代码块和初始化静态变量。

类加载器(类加载子系统)
    这四种加载器是包含关系。不是父子类继承的关系    ClassLoader是一个抽象类
 1.Bootstrap ClassLoader引导类加载器(启动类加载器)。
    1.获取引导类加载器  ClassLoader BootStrapClassLoader = extClassLoader.getParent();  结果为null  因为是C++编写嵌套在JVM内部,java不能直接访问 所以为空
    2.加载 核心类库,只加载包名为java,javax,sun开头的类
    3.扩展类加载器和应用类加载器是由启动类加载器加载的
 2.Extension ClassLoader扩展类加载器。Java编写 ExtClassLoader
    1.获取扩展类加载器 ClassLoader extClassLoader = systemClassLoader.getParent();
    2.继承于ClassLoader。也属于自定义加载器。  父类加载器是启动类加载器
    3.加载的是java扩展库，jre/lib/ext目录下的文件
 3.System ClassLoader系统类加载器(应用类加载器)。 Java编写    AppClassLoader
    1.获取系统类加载器  ClassLoader systemClassLoader = new getSystemClassLoader();
    2.用户自定义的类默认是由系统类加载器加载
    3.继承于ClassLoader。也属于自定义加载器。  父类加载器是扩展类加载器
 4.自定义类加载器
    1.什么场景下需要自定义加载器（为什么要自定义类加载器）？
        1.隔离加载类：避免重名类冲突   例如Tomcat 可以加载一个类的多个版本
        2.想要加载自定义路径下的文件
    2.如何创建自定义加载器？
        1.创建一个类继承ClassLoader类
        2.遵从双亲委派机制就重写findClass()方法
        3.不遵从双亲委派机制就重写loadClass()方法
        4.两个方法参数都是String  其实就是文件名,然后通过文件名找到Class对象返回就好

双亲委派机制 ： Java虚拟机需要Java类的时候才加载成Class对象。加载方式是双亲委派机制。既把请求交给父类处理。任务委派模式
    1.如果一个类加载器收到加载类请求,并不会直接加载。而是向上委托给父类依次递归到启动类加载器
    2.如果父类加载器可以完成加载任务，就成功返回。如果如类加载器无法完成,交给子类尝试。依次递归
    优势：避免类的重读加载。   2.保护程序安全,防止API被篡改
破坏双亲委派：
    1.自身缺陷：各个厂商都有不同的JDBC实现,是没有办法放在核心包里的,所以只能用应用程序加载器。 引入一个上下文加载器.是一种父类加载器请求子类加载器完成加载的一个改造
    2.程序员的一种动态追求：热部署破坏： Java类只能被加载一次,并且无法卸载,所以考虑当java类改变时 首先销毁原来的加载器  然后更新class文件  最后创建一个加载器去加载
----------------------------------------------------------------------------------------------------------
运行时数据区
1.程序计数器(物理上是通过寄存器实现的  所以也叫PC寄存器)
  用来存储当前指令的地址,通过改变计数器的值来获取下一条指令,由执行引擎读取下一条指令。解释器解析成机器码交给CPU执行
优点
  1.占用空间最小,执行速度最快，没有内存泄露，线程私有
  2.保存当前线程指令地址,如果是本地方法  计数器为undefined
使用PC寄存器存储字节码指令有什么用（为什么使用PC寄存器记录当前线程的执行地址）？
  并发执行多个线程。CPU需要不停切换各个线程,切换回来需要知道从哪开始。并且JVM解释器需要改变PC寄存器的值来确定下一条指令
PC寄存器为什么被设置为线程私有的？
  因为多个线程的话如果共用一个PC寄存器存储。A如果执行了3行,CPU切换到B则会直接从3开始,会产生问题。所以需要每个线程独有一份
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
2.虚拟机栈  堆是存储的单位
   先进后出,以栈帧为单位,线程私有的,生命周期与线程相同,虚拟机操作指令只针对栈顶的方法,执行引擎运行当前字节码指令是针对当前栈帧操作的

栈：每个线程运行所需要的内存
栈帧：每个方法运行时需要的内存(参数、局部变量、返回地址 都需要占用内存)

栈帧内部结构： 1.局部变量表(local variables)本地变量表：
                  1.存放了编译期的基本数据类型和引用类型
                  2.存储单位用slot(槽)表示,32位占用一个槽。像long double这种64位占用两个槽
                  3.在进入方法的时候  一个栈帧中的局部变量表所分配的槽就是固定的,运行期间不会改变
               2.操作数栈(operand stack)表达式栈：
                  在操作数栈里写入数据或提取数据
               3.动态链接(Dynamic linking):
                  指向运行时常量池的方法引用
               4.方法返回地址(return Address)：
                  一个栈帧的返回结果指令地址  传给下一个栈帧
               5.一些附加信息
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
3.本地方法栈  本地方法运行所需要的内存就是本地方法栈
   本地方法栈和虚拟机栈类似  只不过虚拟机栈执行的是JAVA方法  本地方法栈执行的是本地方法
   本地方法：
      java有一些限制,不能直接跟操作系统底层打交道,所以需要用C或C++编写的本地方法来真正于底层操作系统打交道
   本地方法有哪些
     wait  notify  hasCode
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
4.堆：通过new关键字创建的对象都使用堆的内存     堆是虚拟机管理的最大的一块内存
     特点：
       1.线程共享的,堆中对象都需要考虑线程安全的问题
       2.有垃圾回收机制  (不再使用的内存就会垃圾回收)

堆内存诊断           排查堆内存溢出尽量将最大堆内存设置小一些,可以尽早发现堆内存溢出问题
  1.jps工具
     查看当前系统中有哪些Java进程    直接在IDEA的Terminal命令窗口中 输入jps 可以返回进程号
  2.jmap工具（只能检测某一时刻的堆内存占用情况  ）
     查看堆内存占用情况     jmap -heap 进程号  查看堆内存
  3.jconsole工具
     图形界面的,多功能检测的工具,可以连续检测.  可以检测线程数量,CPU占用率,堆内存和加载类的数量   Terminal命令窗口jconsole
  4.jvisualvm  可视化虚拟机   和jconsole类似,但是有一个堆抓取工具可以将占用对的对象进行排序查看,以此来排查优化堆内存

几乎所有对象实例都存放堆中,但是随着JAVA的发展,栈上分配,标量替换的方式
  栈上分配：如果一个变量只在当前方法有效,那么可以考虑将它直接在栈中分配内存做处理
  标量替换：一个对象就是一个聚合量,如果可以确定这个对象不会被其他线程使用,那么我就可以把这个对象拆成多个标量在栈上进行分配和读写,后续还可以对 对象的创建进行优化
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
5.方法区
  1.6内存结构 ：
    方法区占用JVM的堆内存,使用的 PermGen(永久代)的实现。
      1.class(类的信息)
      2.classLoader(类加载器信息)
      3.运行时常量池 ：其中最重要的就是字符串常量池StringTable(字符串常量池)
  1.8内存结构
    方法区占用本地内存,使用 Metaspace(元空间)的实现
      1.class(类的信息)
      2.classLoader(类加载器信息)
      3.运行时常量池 其中StringTable被移到堆中    JDK6存放永久代只有FULL GC才会进行垃圾回收,效率低,而且容易造成永久代内存溢出。而放入堆中 vener GC就会进行清理,
StringTable(字符串常量池)特性   hastable结构,不能扩容
  1.字符串懒加载,用到先查询串池,没有则创建
  2.字符串变量拼接 字节码中使用的StringBuilder  字符串常量拼接是在编译器就会优化
  3.可以使用 intern
     1.8尝试将字符串放入串池,如果有不放入,没有就放入并且返回串池中的对象
     1.6尝试将字符串放入串池,如果有不放入,没有就复制一份放入并且返回串池中的对象
  4.当堆内存紧张时,不用的字符串常量也会被垃圾回收
例子：
  String s1=“a"; String s2="b";  String s3="ab";  都是存放在字符串常量池中的
  String s4=s1 + s2;
    相当于new StringBuilder().append(s1).append(s2).toString();  new String("ab");堆中
  String s5="a"+"b"; javac在编译期间的优化,编译期间结果就是ab了,去常量池中寻找,没有就创建。而s1和s2可能被修改   s1,s2是变量可能被修改,所以在运行期间用Stringbuilder拼接
StringTable调优  (底层是hasTable)
  1.当系统中字符串常量非常多,可以适当调大字符串常量池中桶的数量,减少hash冲突  默认6w个   -XX:StringTableSize
  2.当系统中需要大量的字符串,并且存在重复的话可以考虑将字符串入池来节约空间
二进制字节码文件(类基本信息,常量池,类方法定义(包含虚拟机指令))  javap -v  *.class 反编译
   java文件编译Class文件,常量池载入运行时常量池,操作指令载入方法区,main方法运行分配操作数栈和局部变量表,执行引擎JIT编译器编译成机器指令交给CPU运行
  静态常量池：
     存放在class文件中,类似于一张表,虚拟机指令根据这张表找到要执行的类名,方法名,参数类型,参数值等信息
  运行时常量池
     将常量池中的类被加载时,他的常量池信息就会放到运行时常量池中,把里面的符号变成真实的内存地址
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
6.直接内存    可以通过任务管理器查看内存,Java的工具监视不到
  1.常见于NIO(非阻塞IO)操作,在数据读写时用作缓冲区
  2.分配回收成本高,但是读写性能非常高
  3.不受GC管理(底层unsafe对象完成创建和释放,内部使用cleaner虚引用监听bytebuffer,如果发现被释放就调用unsafe的释放方法 释放直接内存)
Java只能访问java分配的内存,不能直接访问系统内存。
   1.传统读写： 先将文件存入系统缓存,然后读到Java缓存,代码获取java缓存中的文件
   2.直接内存： byteBuffer提供了一个创建直接内存的方法(allocateDirect 里面new了一个directByteBuffer),直接内存既是操作系统内存但是JAVA代码也可以直接访问。这样就减少一次文件拷贝
问题： 系统动态扩容时使用-Xmx设置堆最大空间  可能导致JVM堆加上直接内存超过物理内存 从而报内存溢出
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
7.对象的创建过程(虚拟机角度)
  1.new 一个对象 首先检查这个指令参数能否在常量池中定位到一个类的符号引用
  2.检查这个类是否被加载,解析,初始化过。如果没有就交给类加载器去加载(加载后可确定内存大小)
  3.类加载通过后 为新对象分配内存
  4.内存分配完后,将分配的内存(不包括对象头)初始化为零值,作用是程序能访问到数据类型的默认值     如果采用缓冲区分配内存方式,可以将初始化为零的操作也提前到缓冲区
  5.最后设置对象头,对象头中包含(类的实例,对象的哈希码(实际上哈希码会延后到真正调用hashCode时才计算),GC分代年龄等信息)
java角度
  1.init方法还没有执行,所有字段都是默认零值。  所以还需要执行init方法

内存分配两种方式：
  1.指针碰撞(Serial和ParNew收集器)
     假设Java堆内存整齐,使用过的放一边,未使用过的放一边。中间指针作为分界点,指针向空闲区移动分配出空间。这种方式是指针碰撞
  2.空闲列表(Sweep收集器)
     如果JAVA堆内存不整齐,使用和未使用交叉起来,就没法使用指针碰撞的方式分配.这个时候虚拟机需要维护一个列表,找到足够分配的内存进行分配然后更新列表
  JAVA堆是否整齐是由垃圾回收器是由具有压缩整理的能力决定的

分配内存冲突,怎么保证线程安全
  1.采用CAS分配重试的方式来保证更新的原子性
  2.每个线程在堆中预先分配一小块内存,要分配内存的线程先在缓冲区中分配,只有缓冲区用完了,需要同步新的缓冲区才会同步锁定(可以通过参数设置)

对象的内存布局
  1.对象头
     自身运行时数据
        1.哈希码   2.GC分代年龄  3.锁状态标志  4.线程持有的锁  等 它是动态的结构，随着对象状态变化。
     类型指针
        即对象指向它类型的指针。如果对象是JAVA数组,那还应该有一块用于记录数组长度的数据
  2.实例数据
     对象真正存储的有效信息(各种类型的字段内容,无论父类继承还是自己定义的)
  3.对齐填充
     只是占位符作用,因为内存管理必须是8字节整数倍,对象头已经被设置为8字节的倍数,所以当实例数据不是8字节倍数时进行对齐填充

对象的访问定位
  1.句柄： 栈上reference指向句柄地址,句柄中存放 对象实例地址和对象类型地址     优点：对象移动只需要改变句柄中的地址
  2.直接指针： 栈上reference指向对象实例地址,对象实例对象实例中存放对象类型地址    优点：少做一次读取   对象访问在JAVA中非常频繁,所以效果很可观

内存泄露原因
  1.ThreadLocal使用不当,没有remove清理
  2.hash值变化,无法找到存入对象,也会造成内存泄露. 这也是为什么String设置为不可变类型
  3.变量不合理的作用域
  4.socket连接 不用不及时关闭
  5.静态集合和JVM生命周期一致  无法释放
----------------------------------------------------------------------------------------------------------
垃圾回收
如何判断对象可以被回收
  1.引用计数法
     当对象被其他变量引用就计数加一,不再引用减一。归零就可以回收
     弊端：循环引用  A引用b  B引用A  没人引用他们两个 但是各自引用都不能归零导致内存泄漏
  2.可达性分析法
    确定根对象(GC root)：肯定不能被回收的对象,垃圾回收之前对堆中所有对象扫描,看是否被根对象引用,如果没有被引用就可以回收
    哪些对象可以作为根对象：
       1.虚拟机栈中引用的对象：正在运行的方法所使用参数、局部变量等
       2.本地方法栈中JNI引用的对象,
       3.静态属性引用的对象,
       4.常量池引用的对象常量池中的引用
       5.虚拟机内部的引用： 基本数据类型Class对象\空指针对象\类加载器等

Java中4中引用
强引用：等于直接赋值就是强引用  赋值null取消强引用  不会被垃圾回收。当引用全部断开时垃圾回收
软引用(SoftReference)：发生内存溢出前会去回收软引用关联的对象,如果回收完内存还不够 才会报OOM     如果没有关联对象可以放入引用队列,通过引用队列找到软引用   进行回收
  场景：使用软引用加载图片,内存不足前面加载过的就会释放, 防止OOM,要打开再次加载就可以
弱引用(WeakReference)：只要发生垃圾回收,不管内存是否充足都会回收弱引用关联的对象                如果没有关联对象可以放入引用队列,通过引用队列找到弱引用  进行回收
虚引用(Phantom Reference)：目的就是关联对象被回收时收到一个系统通知   必须配合引用队列,直接内存使用的就是虚引用,当bytebuffer被回收后   通过引用队列找对虚引用 从而释放直接内存

finalize方法： 可达性分析到不可达对象会对它进行一次标记,看你是否重写了finalize,如果重写了此方法并且和对象进行管理(比如this赋值给类变量) 他就不会被回收  如果没有任何关联就会被回收

垃圾回收算法：  实际使用中不是只使用一种,是多种混合使用的
   1.标记清除：将没有被GCRoot引用的对象做标记,清除标记地址并不是清除内存,而是将内存地址起始地址存放到空闲列表中提供使用
     优点：速度快  只需要将起始地址做记录就完成清除  缺点 容易产生内存碎片
   2.标记整理：将没有被GCRoot引用的对象做标记,将保留的对象整理成一块连续的内存,剩余一块连续内存
     优点：没有内存碎片   缺点：整理会移动对象,涉及东西多，效率低
   3.复制算法：将内存区划分成大小相等的两个区,其中一个空闲,将GCroot标记的对象复制到空闲区域,清空第一个区然后交换两个区位置
     优点 没有内存碎片   缺点  一部分空间没有使用，存在空间的浪费
   4.分代垃圾回收机制  (新生代(伊甸园、幸存区From、幸存区To   8:1:1)   老年代)
     1.老年代：有的对象需要长时间使用,放入老年代
     2.新生代：用完可以丢弃的对象放入新生代
     优点：因此可以设计不同的垃圾回收算法,老年代很久一次新生代垃圾回收频繁
对象创建存放在新生代的伊甸园中,当伊甸园空间不足时,触发MinorGc使用可达性分析算法进行标记,被标记的对象放入新生代幸存区To,将寿命+1
交换新生代From和To的内存区域,将伊甸园没有被标记的释放,第二次伊甸园空间不够继续MinorGC,区别就是可达性分析算法还要多加一个From内存
然后标记的放到To,交换位置寿命+1,当寿命到达一个限制就将这个对象放入老年代.
使用复制算法,并且在发送MinorGC时暂停所有用户线程,垃圾回收结束恢复运行  寿命最大15    4bit( 1111 )
当老年代空间不足,会执行FUllGC,其他线程暂停时间更长,清理速度较慢。如果fullGC结束还不够就OOM

Minor GC/Young GC、Major GC/Old GC、Mixed GC、Full GC都是什么意思？
   1.Minor GC/Young GC：指目标只是新生代的垃圾收集。
   2.Major GC/Old GC： 指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为。
   3.混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有G1收集器会有这种行为。
   4.整堆收集（Full GC）：收集整个Java堆和方法区的垃圾收集。

什么时候会触发FULL GC：
   1.Young GC之前检查老年代：进行Young GC时,检查老年代可用连续空间 < 所有升入老年代的平均大小 说明本次可能会造成空间不足,那就会触发 Full GC。
   2.Young GC后老年代空间不足
   3.老年代内存使用率达到一定比例
   4.JDK8之前永久代内存不足会出发FUll GC
   5.System.gc()等命令触发

新生代晋升老年代方式                创建的线程发送OOM不会影响主线程继续执行
   1.长期存活,对象头中存放GC分代年龄,超过15直接放入老年代   因为15是最大值
   2.GC后幸存区放不下,只能放入老年代
   3.动态年龄判断,当幸存区内存超过一半,找到年龄最大的加一作为阈值,如果下次minorGC还存活就放入老年代
   4.特别大的对象,伊甸园清空也放不下,就会直接放入老年代

垃圾回收器
  1.串行(-XX:UserSerialGC=Serial + SerialOld)
     单线程,适用于堆内存较小,CPU个数少  适合个人电脑
  2.吞吐量优先(-XX:UserParallelGc  还可以指定线程数) 1.8默认开启         吞吐量=线程运行时间/线程运行时间+垃圾回收时间   比值越大垃圾回收占用越小
     多线程,使用堆内存较大,多核CPU,单位时间内STW时间最短            0.2 0.2  =0.4  单位时间内STW时间短
  3.响应时间优先
     多线程,使用堆内存较大,多核CPU,尽可能让STW(其他线程暂停时间)时间最短   0.1 0.1 0.1 0.1 0.1=0.5

Serial： 新生代   采用复制算法
Serial Old：老年代  采用标记整理算法     在发送垃圾回收的所有用户线程进入安全点阻塞，一个线程执行GC  执行完毕所有线程继续运行

Parallel: 新生代   采用复制算法         存在一些参数配置吞吐量的大小,还有自适应策略 (调优比较困难时，使用自适应 我们只需要配置最大堆,目标吞吐量和停顿时间. 虚拟机自行完成调优工作)
parallel Old ：老年代 使用标记+整理算法   在发生垃圾回收时所有用户线程进入安全点阻塞  多个线程执行GC  执行完毕所有线程继续运行

ParNew GC：新生代   采用复制算法
CMS： 老年代   采用标记清理算法   注重响应时间
    1.初始标记： 初始标记只会标记一些根 对象    会进行STW但是时间非常短
    2.并发标记： 跟踪根对象,标记一些新的垃圾    不会STW   但是用户现场可能会使一些标记的对象产生变动  通过写屏障会维护到队列中
    3.重新标记： 把并发标记维护的队列进行检查然后重新标记, 防止并发标记错误清理  这个阶段会STW 但是经过前两次标记 本次不会占用太多时间   最费时的时并发标记
    4.并发清楚： 也是并发进行清理        这个时候产生的垃圾也无法清理(浮动垃圾)。 所以有一个参数 设置老年代阈值,到达这个值就会进行垃圾清理  防止浮动垃圾导致内存不足
    缺点
    会产生内存碎片,当内存碎片较多 会造成并发失败  就会降成serial Old垃圾回收器.垃圾回收停顿时间会增加  变成单线程垃圾回收
    优点
    并发标记和并发清除都是并发执行的  一定程度上降低了线程等待时间

G1： JDK9默认回收器      使用场景： 同时具备吞吐量和响应时间(可以设置参数配置暂停时间)   适合超大堆空间(会进行 Region 分区)  整体使用标记+整理 两个区之间适用复制
   1.young GC ：初始标记(STW)  标记GCRoot对象
   2.Young GC+ concurrent Mark ： 并发标记 当老年代堆空间到达阈值会进行并发标记
   3.Mixed GC： 最终标记+拷贝存活(都会STW)    优先收集垃圾最多的区来达到暂停时间短的目标
   跨代引用： young GC的时候 老年代可能会引用新生代对象,是不可被回收的，所以就需要遍历老年代的对象。但是这样做很浪费时间。
            hotspot采用卡表的思想。如果引用了就变成脏卡,扫描的只搜索脏卡 减少了扫描时间   脏卡不是立即更新,采用写屏障然后把指令放入队列中,一个线程执行来进行更新
   自身优化   1.字符串去重

区别：1.Serial     ParNew GC  除了多线程进行垃圾回收外 没有其他区别
     2.Parallel   ParNew GC  Parallel和Parallel Old 更加注重吞吐量,主要适合后台大量计算而不是大量交互的任务  适合在服务器使用 也是JDK8的默认收集器

OOP MAP：hotspot中会生成一个映射表,记录那些位置是引用    1.循环末尾    2.可能抛异常位置  3.方法返回前    这些位置也被称为安全点


-XSS                   分配虚拟机栈内存 linux默认:1024KB
-Xmx(-XX:MaxHeapSize)  分配最大堆空间
-Xms                   分配初始堆空间
  最大内存：当物理内存小于200兆,默认最大堆空间是物理内存1/2,否则是物理内存1/4
  初始内存：物理内存的1/64,最小8M,最大为1G
  年轻代：老年代   1：2    年轻代默认为堆空间1/3  老年代为2/3
-XX:MetaspaceSize      分配元空间大小       默认20多兆
-XX:MaxMetaspaceSize   分配最大元空间大小   默认最大值
   一般元空间和元空间最大值设置统一,因为元空间大小改变会FULL GC












