微服务: Spring Boot
    将一个应用拆分成多个微服务,每个服务可以独立部署,服务之间通过http(Rest API、RPC)交互
    优点
    1.多个服务可采用不通技术栈  2.负载高时关闭非热点服务  3.部署快,修改bug只需要重启对应服务
    缺点
    1.微服务搭配分布式整体架构复杂,运维难度增加  2.工具类等不能共享,代码冗余增加
分布式: Spring Cloud(基于HTTP协议 todo)
    一个微服务部署在多台机器上,多台计算机组合部署一个应用,提高性能和可用性
    难点
    1.服务接口开放产生安全性问题  2.网络传输信息丢失  3.分布式产生的难点(服务发现、服务限流、负载均衡、链路跟踪等)
云原生: Docker
    将分布式应用部署在云平台
    难点
    1.根据服务流量弹性伸缩(流量大自动多部署几台,流量小减少)
    2.服务自愈(服务器崩溃自动在其他计算机部署)
    3.自动化部署
    4.灰度发布(服务升级少部分替换,没问题全部服务替换)
--------------------------------------------------------------------------------------------------------
版本选型：
SpringBoot：
    截至2023年3月,最新版本(3.0.4)
SpringCloud：
    截至2023年3月,最新版本(2022.0.1)版本,之前版本是字母开头命名,现在用年份开头命名
注意：
    选用Cloud后需要去官网查看和SpringBoot的依赖关系,目前 (2022.0.X) 支持 SpringBoot(3.0.X)
官网：
    Maven坐标：https://mvnrepository.com/
    SpringCloud下层依赖版本：https://start.spring.io/actuator/info
技术选型 //todo
SpringCloud 和 Dubbo 区别？
    Dubbo采用Zookeeper做注册中心、采用RPC方式远程调用、Dubbo-monitor做服务监控、服务熔断降级不完善
    Cloud可以采用Eureka|Consul|Nacos|ZK做注册中心、采用Rest API远程调用、增加服务熔断降级限流、服务网关、链路跟踪、消息总线等

RestTemplate 和 RPC 区别？
    1.RestTemplate采用HTTP协议,基于TCP协议,消息封装比较臃肿,发送速度慢.
    2.RPC基于Socket,速度快效率高,典型代表Dubbo、WebSocket、ES集群间调用
常用RPC远程调用框架有哪些？
    1.httpclient   2.GRPC   3.dubbo   4.openFeign

Eureka 2.X版本已经停止维护,用什么替换？
    1.ZK
    2.Consul 优点：1.基于Raft协议,比较简洁  2.同时支持HTTP和DNS协议,支持跨数据中心WAN集群  3.跨平台,支持 windows、Linux、Mac
    3.Nacos
Ribbon 用什么替换？
    Spring cloud目前自己还在用,后续会通过 SpringCloud LoadBalance 替代
Feign 进入维护
Hystrix,进入维护 用什么替换？
    SpringCloud
--------------------------------------------------------------------------------------------------------
当前笔记依赖版本：SpringCloud H版 SpringBoot2.2.2

怎么保证微服务架构的健壮性
    1.服务注册与发现  2.服务调用  3.服务熔断  4.负载均衡   5.服务降级  6.服务消息队列   7.配置中心管理  8.服务网关
    9.服务监控  10全链路跟踪   11.自动化构建部署   12服务定时任务调度

Eureka 是什么？
    Eureka 是分布式服务注册中心,提供了服务治理和服务发现等功能
Eureka 服务治理是什么？
    服务注册中心：提供注册和发现功能
    服务提供者：提供服务的应用会将自身注册到注册中心
    服务消费者：根据注册中心进行服务发现,进行远程调用
什么是服务续约？
    服务提供者通过配置指定心跳时间(默认30s),心跳来维持注册中心保存服务,防止被注册中心删除
什么是服务下线？
    当服务关闭的时候,会发送Rest请求给注册中心,注册中心收到后删除服务,并广播给所有消费者
什么是失效剔除？
    当服务发生异常时(如网络延迟),注册中心如果超过最大配置时间(默认90s)没收到心跳会将服务设置为失效服务,失效服务会被定时清理线程(默认60s)删除
Eureka 自我保护机制
    防止网络阻塞导致服务被删除,如果30s没收到客户端心跳,Eureka并不会立刻清理客户端,依旧对该服务进行保留,如果丢失三次心跳则进行删除

ZK //todo
Zookeeper 做注册中心,生成临时节点还是持久节点？ 临时

Consul 是什么？
    Consul 是分布式服务发现和配置管理系统,基于GO语言开发,提供了 服务治理、服务发现、配置中心、消息总线等功能
Consul 命令？
    启动命令：consul agent -dev
    页面访问：http://localhost:8500

CAP理论：
    一致性(Consistency):所有节点访问的数据一致
    高可用性(Availability)：每次请求都可以得到响应,不管成功还是失败
    分区容错性(Partition tolerance)：降低一致性要求,允许一定容错
    注：在分布式系统中,CAP不可同时满足,多节点联通情况下,肯定会出现断开连接的情况,断开时一致性和高可用性就不能同时满足
        CA：单机操作,满足一致性和高可用性系统,但是违背了分布式多节点的初衷
        CP：满足一致性和分区容错性,如金融行业的支付流程
        AP：满足高可用性和分区容错性,如电商,互联网业务处理
四个注册中心的区别：
    Eureka:Java语言编写,实现高可用性和分区容错性,提供WEB界面管理
    zookeeper:Java语言编写,实现一致性和分区容错性
    Consul：Go语言编写,实现一致性和分区容错性,提供WEB界面管理
    Nacos: AP和CP可以切换,底层融合Ribbon实现负载均衡


Ribbon 是什么？
    主要提供客户端 负载均衡(Load Balance) +  远程调用(RestTemplate) 并提供了超时、重试等配置项
负载均衡有哪些方式？
    Nginx服务器负载均衡:客户端将请求发送给Nginx,Nginx实现请求转发,从而实现负载均衡
    Ribbon客户端负载均衡：在调用微服务接口时,通过注册中心获取对应服务节点,通过负载均衡算法实现负载均衡
        1.先选择 注册中心集群中负载少的进行节点查询   2.找到所有节点根据负载均衡算法选择要使用的具体节点进行远程调用
负载均衡算法有哪些？
    1.轮询算法(RoundRobinRule):默认算法,通过记录请求次数计算服务节点
    2.随机算法(RandomRuleO)
    3.重试算法(RetryRule):先按照轮询,服务调用失败选择可用服务重试
    4.响应权重(WeightedResponseTimeRule)：对响应时间加权重,响应速度越快,权重越大,越容易被选择
    5.过滤选择(BestAvailableRule):先过滤掉熔断的服务,然后选择一个负载低的调用
负载均衡算法如何替换？
    官方提示,修改负载算法的配置类不能放到 @ComponentScan 所扫描的包及子包下,否则所有Ribbon客户端算法都会替换,达不到特殊替换目的
    1.在非扫描子包下创建配置类,修改使用算法
    2.在主启动类上 @RibbonClient(name = payment-service,configuration = 配置类) 指明哪个服务需要使用此算法,其他服务如果没配默认使用轮询


Feign 是什么？
    Feign是SpringCloud组件中一个轻量级RestFul的HTTP客户端,内置了Ribbon做负载均衡,使用注解就可以调用注册中心里的服务
OpenFeign 是什么？
    在Feign基础上支持了SpringMVC注解,OpenFeign的@FeignClient可以解析@RequestMapping注解下的接口,并通过动态代理产生实现类,实现负载均衡调用
OpenFeign 超时时间问题？
    默认1s超时,如果服务端没处理完毕会报错,可通过配置指定 连接超时时间 和 业务执行超时时间
        1.连接超时时间：ConnectTimeout
        2.执行超时时间：ReadTimeout
OpenFeign 日志打印功能？
    通过日志了解 OpenFeign 中HTTP请求的细节,对接口调用进行监控和输出
    日志级别：
        1.默认(NONE):不显示任何日志
        2.BASIC:仅记录方法URL、响应状态码、执行时间
        3.HEADERS：在上述基础上增加记录请求头和响应头
        4.FULL：在上述基础上增加请求和响应的Body信息


Hystrix 的作用？
    主要通过服务降级、服务熔断、服务限流方式防止雪崩
什么是服务雪崩？
    当多个服务链路调用时,如果一个服务不可用或响应时间过长,会导致调用方超时重试一直调用,请求一直堆积导致Down机,连锁效应使所有服务Down机导致雪崩
    服务雪崩的原因？
        1.访问量突然变大,服务器负载不过来导致连锁崩溃
        2.程序BUG导致服务不可用,或者运行缓慢造成流量堆积
        3.缓存击穿,导致所有流量打到服务上导致连锁Down机
什么是服务降级 Fallback？
    当服务运行报错,超时等情况发生时,返回友好提示,防止客户端一直重试造成请求堆积导致雪崩
    什么时候会执行降级方法？
        1.客户端指定超时时间,服务器没有响应,执行降级方法
        2.服务发送异常,执行降级方法
        3.服务被熔断,执行降级方法
如何指定一个调用的超时时间？
    在方法上增加@HystrixCommand注解,里面增加HystrixProperty设置超时时间. 如果需要全局配置可以在配置文件设置Hystrix.Command中的超时参数
什么是服务熔断 Break？
    当服务出现异常或响应时间太长时进行降级,降级次数超过一定阈值,熔断该服务调用,当检测到该节点正常时恢复链路调用
如何配置服务熔断？默认10s内20次请求,当失败率超过一半时熔断
    在配置中指定请求次数和失败率,当失败率达到阈值熔断服务,根据指定时间恢复成半熔断状态,当发现服务正常时关闭熔断,恢复服务调用
Hystrix 工作流程
    1.先查看服务响应是否存在缓存,如果存在缓存直接返回
    2.如果没有缓存,判断该服务是否被熔断,如果被熔断直接调用降级方法
    3.如果没有被熔断查看线程池是否被占满,如果沾满调用降级方法
    4.调用服务看是否报错或响应时间过长,调用降级方法
    5.如果都没问题响应正常结果,如果调用降级方法后续判断是否到达熔断阈值执行熔断操作
    6.熔断后到达指定周期判断服务是否正常可用,如果正常关闭熔断
Hystrix Dashboard了解吗？
    1

什么是服务限流 FlawLimit？
    秒杀高并发等操作,严禁一窝蜂过来拥挤,大家排队，一秒N个有序进行
JMeTer压力测试


Zuul服务网关
    对API进行过滤,转发到对应的微服务节点上
为什么选择 gateway而不选择Zuul
    1.Zuul已经进入维护阶段并且采用阻塞IO,性能不如gateway高
    2.gateway内部集成了Hystrix(限流、熔断、降低)和服务发现等的功能
    3.可以对路由指定
Gateway 核心功能？
    1.路由route
        基于异步非阻塞模型开发的底层使用Netty,对API请求通过断言匹配,转发到对应节点,并在转发前后增加过滤器,实现权限控制、熔断、限流、日志等功能
    2.断言predicate
        After：在什么时间之后生效
        Before：在什么时间之前生效
        Between：在什么时间之中生效
        Cookie：cookie必须携带某个key、value
        Header：头中携带什么参数名，必须符合什么正则表达式
        Method：get  post
        Query：必须携带的参数名称, 正则表达式规定参数的值
    3.过滤器filter：在请求前后进行过滤
        自定义过滤器：实现import GlobalFilter,Order


分布式配置中心(SpringCloud Config)
    随着服务节点的增加,重复的配置文件越来越多,引入config来提供一套集中的配置来解决配置重复的问题
Config如何解决配置重复？
    1.configServer：一般在Git或SVN上创建一份公共配置
    2.configClient：在运行阶段拉取Git或SVN服务器上的配置,加载到本地
        通过bootstrap.xml获取 configServer加载好的配置文件  bootstrap.xml是系统级配置文件。优先级高
        application是用户级的
分布式配置中心的优势？
    1.集中管理配置文件,发生变化时无需重启服务即可感知到变化并拉取最新配置
    2.不同环境不同配置,通过configClient指定拉取对应环境的配置
    3.将配置以接口形式暴露
分布式配置中心存在问题？
    1.github服务器修改配置文件,configServer可以立马读取到,但是configClient需要重启才能读取到
    解决方案：当发生变更时发送Post请求刷新配置,避免重启
    缺点：虽然可以脚本批量修改,但是还是比较麻烦

消息总线(BUS)：
    通过整合消息中间件实现配置自动刷新,简化运维操作。 目前只支持：RabbitMQ和kafka
设计思想：
    1.通知一个客户端刷新,从而刷新所有客户端,打破服务的单一性和平等性,一般不使用
    2.通知一个服务器刷新,从而刷新所有客户端,推荐使用
        当github配置文件修改时,只需要发送一个Post请求到服务器即可实现客户端自动刷新,也可以通过参数控制部分客户端更新


消息驱动：Stream
     如果系统中存在两种消息中间件,屏蔽底层消息中间件的差异,降低切换成本,统一消息的编程模型

分布式链路跟踪：
     当微服务系统越来越多,各模块调用链路越来越长,就需要引入链路跟踪,对服务进行监控,方便快速定位响应时间长或出现异常的服务
常用的分布式链路跟踪？
    1.SpringCloud Sleuth + Zipkin
    2.阿里的鹰眼(EagleEye)
    3.SkyWalking
    4.Pinpoint
    上述技术核心思路？
        第一个收到请求的服务会生成一个全局【traceId】和【spanId】,并随着链路传递到下游系统,后续服务对【spanId】进行维护,方便堆栈排序
        当发生异常时,收集所有服务日志查询【traceId】链路,根据【spanId】进行调用堆栈排序
    可以解决什么问题？
        1.通过链路恢复可以快速定位故障,发现服务调用时间长可以及时进行优化
        2.通过标签信息可以分析 服务不同节点的流量,实现流量预估,对节点进行精准扩容
    分布式链路跟踪系统如何选择？
        Pinpoint界面UI好,但是性能和扩展性比较差
        采用SkyWalking比较多,采用字节码增强,不需要修改业务代码。并且探针支持语言比较全,并且性能高
什么是探针？
    作用就是收集数据,根据不同语言有不同实现,像JAVA一般通过字节码植入或拦截,通过HTTP或PRC方式发送到平台后端
什么是平台后端？
    用于数据聚合,数据分析,将服务发来的日志数据聚合,提供后续分析


服务配置：  微服务模块越来越多,很多配置文件会出现很多重复性操作
nocas做服务配置：
${prefix}-${spring.profile-active}.${file-extension}
prefix:默认spring.application.name   也可以通过spring.cloud.nacos.cofig.prefix
spring.profile-active:是当前环境profile 当spring.profile.active为空,就省略中间部分
file-extension：文件格式 目前只支持properties和yml文件
不需要在配置一个服务器端模块,nacos支持自动刷新.改完配置客户端就会自动拉取最新配置
nocas新增功能  分类管理：namespace（默认公共的为public） + group（默认Default_group） + dataID
  1.namespace：用于区分部署环境。
  2.groupID+dataID：逻辑上区分两个目标对象  默认集群(cluster)也是default
  3.根据启动环境读取相应环境的配置(dev,com.example.common.model.test)
nacos集群和持久化配置：
    1.自身携带嵌入式数据库 derby：
        问题：所以启动多个默认配置下的nacos节点(集群),数据存在一致性问题
        修改：采用集中式存储的方式来支持集群的部署,目前只支持mysql的存储
nacos：linux集群配置
   1.安装 切换mysql （修改config文件下的application.properties）
   2.修改config文件下的cluster文件。  使用hostname命令获取实际linux中ens33的ip  后面写多个集群的各自端口号
   3.修改启动startup.sh启动脚本。 1.加一个port参数2.最下面加- Dserver.port=${port}
   4.启动命令后面拼接 -p 端口号
   5.nginx配置


