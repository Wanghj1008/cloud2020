设计模式的六大原则
    1.开闭原则：扩展开放修改关闭,对程序进行扩展的时候不能修改原有代码
    2.依赖倒置：子类尽量继承抽象类或接口,高层定义规范,子类实现具体细节,提高扩展性
    3.里氏替换：继承子类可以重写父类方法实现功能
    4.接口隔离：将不同功能定义到不同接口中,具体功能实现具体的接口,降低冗余
    5.迪米特(知道最少)：每个模块尽量减少对其他模块的调用,降低耦合度
    6.单一职责：一个类只负责一项职责,降低代码复杂度
设计模式的分类
    1.创建型模式：在创建对象时隐藏创建逻辑,不使用new直接实例化对象,程序在判断需要创建哪些对象时更灵活
    2.结构型模式：通过类和接口间的继承和引用实现复杂结构的对象
    3.行为型模式：通过类之间不同通讯方式实现不同行为
1.创建型模式(5种)
    1.单例模式(Singleton): 优点：内存中只存在一个对象,节约资源
        1.饿汉单例：         缺点：如果程序中未使用,则一直占用内存
        2.懒汉单例：         缺点：多线程下单例会被破坏
        3.线程安全,懒汉单例(加锁)：   缺点：性能低
        4.双重检查懒汉
        5.静态内部类单例
        6.枚举实现单例模式
        场景：创建对象耗时,但又经常使用,例如工具类、频繁访问数据库或文件的对象(数据源,session工厂等)
        一、通过反射还能保证单例吗？
            懒汉无法保证, 饿汉和静态内部类通过构造方法内判断,如果不为NULL还调用抛异常  ENUM无法通过反射调用
        二、反序列化如何实现单例？
            需要增加一个readResolve()方法调用getInstance()方法,Enum提供了一个ReadEnum的方法
    2.简单工厂模式|静态工厂模式(Factory):
        只需要传入工厂参数,把对象的创建功能交给工厂,达到解耦目的    例如Spring中BeanFactory mybatis中SqlSessionFactory
        缺点：1.如果要增加传入参数的种类,可能要修改逻辑,违反开闭原则   2.如果参数种类比较多工厂类比较复杂
    3.抽象工厂模式(Abstract Factory):用于创建一系列相关的对象， 而无需指定其具体类
    4.建造者|生成器模式(Builder)  例如：mybatis中XMLScriptBuilder、XMLStatementBuilder、XMLConfigBuilder、XMLMapperBuilder
    5.原型模式(prototype)
2.结构型模式(7种)
    1.代理模式(Proxy)
    2.适配器模式(Adapter)
    3.桥接模式(bridge)
    4.组合模式(composite)
    5.外观模式/门面模式(Facade)
    6.装饰模式(Decorator/Wapper)
    7.享元模式(Flyweight)
3.行为型模式(11种)
    1.责任链模式(Chain of Responsibility)
    2.命令模式(Command)
    3.迭代器模式(Iterator)
    迭代器设计模式：
        将遍历的操作抽象出一个迭代器类来负责,和集合类分离,既不暴露集合的内部结构,又为多种集合对象提供了统一的迭代器类来实现多种遍历方式
        优点：  1.不暴露集合的内部结构  2.不通方式遍历一个集合 只需要用不同迭代器类替换原有迭代器类即可  3.简化了原类让便利的操作
        缺点：  在一定程度上抽出迭代器类增加了类的个数,增加了系统复杂性
    4.中介模式(Mediator)
    5.备忘录模式(Memento)
    6.观察者模式/发布订阅模式(Observer/Listener)
    7.状态模式(State)
    8.策略模式(Strategy)
    9.模版模式(template) 例如：mybatis中SimpleExecutor、ReuseExecutor、BatchExecutor
    10.访问者模式(Visitor)
    11.解释器模式(Interpreter)



















