国际网络标准模型一共7层
1.TCP/IP 网络模型共四层
    应用层(用户态)：我们手机电脑的软件都是在应用层实现的,提供应用功能：HTTP、FTP、Telnet、DNS、SMTP等
    传输层(内核态)：通过TCP/UDP协议进行传输,指定端口识别应用,在数据包基础上封装TCP头/UDP头
    网络层(内核态)：使用IPV4/IPV6找到对应的设备,在上述包基础上封装IP头
    网络接口层(内核态)：通过ARP协议获取对应设备的MAC地址,在上述包基础上封装MAC地址
    物理层：传输介质(网线)和传输设备(路由器、交换机)
    注：
    四层封装完毕将数据包发送到网卡,网卡将数据包发送出去,当数据包超过最大传输单元(MTU),在网络层会进行分包,分包越多吞吐越差.
    ARP协议了解：内部通过广播IP,对应IP的设备会将MAC地址响应回来

2.Linux 网络协议栈就是通过TCP/IP网络模型实现的
    Linux 接收网络包的流程
        1.当网卡收到数据包后,通过DMA写入到系统内存,完成后中断CPU处理数据包
        2.通过网络层和网络接口层拆掉MAC和IP封装,传递给传输层
        3.传输层根据协议将数据放到Socket缓冲区中,进入应用层
        4.应用层调用socket接口将缓冲区数据拷贝到用户内存,然后切换用户态
    Linux 发送网络包的流程
        1.调用发送后切换内核态,调用socket接口将用户内存数据拷贝到Socket缓冲区
        2.通过传输层封装TCP/UDP头,通过网络层封装IP头,通过网络接口层封装MAC,完成数据包封装
        3.封装完毕后,通过DMA发送给网卡
    数据包写入系统内存后,中断CPU处理,会出现问题吗？
        高并发下数据包非常多,如果采用中断CPU可能导致CPU一直处理数据包,导致线程一直等待CPU会降低响应速度
        解决：采用中断轮询方式：数据包写入系统内存后注册到中断表,内核开启一个专门线程进行逐层拆包,避免CPU中断

3.网页输入网址到页面显示,期间发生了什么？
    1.通过输入网址生成请求数据包,查询DNS服务器 获取
    2.发送之前通过DNS服务器查询 WEB服务器域名 对应的IP
    3.客户端 和 WEB服务器进行TCP三次握手建立连接,发送数据,接收响应(发送和接收过程涉及拆包和封包)
    4.解析响应展示渲染页面
    5.TCP四次挥手断开连接
    域名的作用？
        IP为数字形式不好记忆,改成域名(www.baidu.com)方便记忆   DNS劫持：修改域名对应IP获取用户信息
    域名解析流程,采用多个缓存,减少主DNS服务器负荷
        1.查询浏览器缓存解析DNS-->查询系统缓存解析DNS-->本地域名服务器解析DNS-->根域名服务器解析DNS-->下级域名服务器解析DNS
    DNS为什么采用UDP？
        当客户端向DNS服务器解析域名时,采用UDP提高响应速度
        当主DNS服务器向下级发送变化的域名时,采用TCP保证数据安全性
------------------------------------------------------------------------------------------------------------------------
应用层
HTTP(超文本传输协议)
    HTTP是计算机在【两点】之间传输【文字、图片、音频、视频】等超文本数据的【约定和规范】

1.HTTP 常见的状态码有哪些？
    1XX：属于提示信息,实际用到较少
    2XX：
        200：成功且存在body    204：成功并且不存在body    206：常用于分块下载或断点续传,表示body中的数据只是一部分,而不是全部数据
    3XX：
        301：表示永久重定向,服务器响应头中携带location指明跳转URL,浏览器会自动重定向到新的URL,客户端后续通过新的URL访问    场景：域名切换跳转到新域名
        302：表示临时重定向,服务器在响应头中携带location指明跳转URL,浏览器会自动重定向到新的URL                        场景：无权限跳转登录页面
            302可能导致网址劫持：发生重定向浏览器依旧展示旧页面但却使用了新URL的响应展示
    4XX：
        400：表示客户端请求存在错误
        403：表示服务器资源无权访问
        404：表示资源未找到
    5XX：
        500：服务器内部错误
        503：表示服务器繁忙,暂时无法响应,稍后重试

2.HTTP 方法有哪些？
    1.GET： 一般获取资源,页面回显数据
    2.POST：主要用来传输实体数据,保存在body中
    3.PUT： 主要用来传输文件,自身没有安全校验,一般不使用
    4.HEAD：用来获取报文头信息
    5.DELETE： 一般用于删除接口使用
    6.OPTIONS：客户端查看服务器支持的方法
    7.GET和POST区别？
        GET请求URL长度有限制,数据不安全,但是请求速度快,且保证幂等性(一般自动缓存),中文是iso编码
        POST对参数没有限制,数据可以进行加密,不保证幂等性所以不缓存(多次请求可能导致数据不一致)

3.HTTP 1.0、1.1、2.0、3.0区别
    HTTP1.0： 默认使用短连接,每次请求都需要重新建立TCP连接。
    HTTP1.1： 1.采用长连接改善短连接频繁创建和销毁的性能开销   2.支持管道通讯,减少IO次数
        缺点： 1.每次请求head信息冗余,并且不支持压缩    2.服务器按请求顺序响应,大量大请求可能造成阻塞  3.服务器只能被动响应
    HTTP2.0： 1.头部压缩并且多个请求会去冗余  2.一个连接中并发传输数据,传输数据采用二进制减少系统转换消耗时间  3.服务器可以主动推送数据
        缺点： 1.可能导致阻塞,TCP发送数据需要等待内核就绪,造成阻塞
    HTTP3.0： 将下层TCP改为UDP,UDP的QUIC 协议 可以已类似TCP可靠性传输

4.HTTP(80) 与 HTTPS(443) 有哪些区别？
    HTTP明文传输,存在风险  2.经过三次握手即可传输数据
    HTTPS 密文传输,保证数据安全  2.三次握手基础上增加了SSL握手保证安全   3.响应速度延迟50%,并且也不能保证绝对安全

6.HTTPS 的SSL/TLS是怎么处理的？
    1.混合加密(对称加密和非对称加密混合)
        在建立通讯之前采用非对称加密交换【密钥】,提供后续对称加密使用
        在通讯过程中,采用对称加密对数据进行加密
    2.摘要(hash)算法+数字签名
        为了保证内容不被修改,会将内容计算hash值,然后hash值通过私钥加密生产数字签名,将内容和数字前面一起发送
        对端收到数据对内容加密计算hash,然后通过公钥对数字前面解密,判断hash是否一致,如果不一致则数据被篡改
    3.数字证书(个人信息+公钥+数字签名)
        为了防止公钥被修改,服务器会将公钥注册到CA,CA用自己的私钥颁发数字证书,客户端通过CA的公钥判断数字证书有效性
    4.非对称加密有什么好处？
        私钥加密公钥解密：保证消息不被冒充,只有公钥可以解密说明肯定时私钥持有者发送的数据
        公钥加密私钥解密：保证数据安全性,只有持有私钥的人可以对数据解密
    5.不使用数字签名,只用摘要算法有问题吗？
        如果对称加解密被破解,则可以对数据进行修改然后计算hash伪造数据发送,增加数字证书,虽然可以通过公钥解密查看hash但是不能修改hash,保证数据安全

7.HTTPS如何建立连接？SSL/TSL连接过程？
    1.客户端和服务器端建立连接,发送HTTPS请求
    2.服务器收到请求后生成公钥,并发送给CA(证书颁发机构)生成数字证书,然后将数字证书发送给客户端
    3.客户端验证证书合法性,证书验证通过后取出公钥进行签名验证,将【会话密钥】通过证书中公钥加密发送给服务器
    4.服务器收到请求后用私钥解密获取【会话密钥】,后续通讯采用会话密钥对称加密
    *请求和响应中加入随机数做数据,如果攻击者重复发送请求,一端收到数据判断随机数如果都相同可以断开连接

8.HTTP长连接和短连接区别,应用场景？
    短连接：每次客户端请求都创建TCP连接,
    长连接：客户端创建连接后不会立马关闭,到达一定时间无响应才会关闭连接,通过head添加 connection：：time=5 使用长连接设置超时时间
        客户端长连接：keep-alive开启,close关闭  服务器长连接：通过alive-time设置超时时间,或者设置请求次数,超过次数断开
    场景：
        长连接适合连接数不大,但是交互比较频繁的时候,减少TCP连接提高性能,比如数据库长连接
        短连接适合WEB网站,用户体量大如果采用长连接会占用服务器大量资源

9.如何理解HTTP协议是无状态的？
    浏览器发请求,服务器响应,多次请求服务器并不知道是同一个浏览器。 为了让使用HTTP的应用也能有状态所以增加cookie和session机制

10.Cookie 工作原理？
    1.浏览器首次访问服务器
    2.服务器创建cookie,将用户信息存入cookie,然后将cookie发送给浏览器
    3.浏览器再次访问服务器端携带服务器生成cookie
    4.服务器根据cookie判断用户

11.Session 工作原理？
    1.浏览器第一次访问服务器,服务器生成cookie和session信息
    2.浏览器 携带cookie 信息 再次发起请求时,服务器根据cookie的用户信息去查询session信息,从而区分用户

12.Cookie 和 Session 有什么区别？
    1.Cookie 可以存储在浏览器或者本地,Session 只能存在服务器
    2.cookie 只能存储String类型对象,session 可以存储任意类型对象
    3.session占用服务器内存,如果session过多,服务器内存压力增加
    3.cookie存在安全隐患,丢失可能导致被攻击,并且单个cookie不能超过4K,很多浏览器限制cookie(20)个数
------------------------------------------------------------------------------------------------------------------------
传输层
1.TCP三次握手(TCP连接)
    1.客户端发送 SYN(synchronize)=1 和 Seq=x(随机数) 数据包给服务器,表示要创建连接
    2.服务器收到创建请求后,回传 SYN =1 & ack=x+1 & Seq=y(随机数) 返回给客户端
    3.客户端收到数据包,回传 SYN=1 & ack=y+1 & Seq = x+1 给服务器建立连接
    相关问题：
        1.如果三次握手每次信息对方都没收到会怎样？
            1.客户端发起创建连接如果服务器没有响应,客户端会等待一段时间重新发送,重试超过五次返回连接失败。 重新发送间隔时间 1s、2s、4s、8s、16s
            2.如果服务器返回确认ACK而客户端没有响应,服务器会阻塞在 accept 等待客户端响应。 等待一段时间重新发送,超过五次返回连接失败
            3.第三次握手服务器没收到响应,超时重试后会断开连接,但是客户端是连接状态
                1.当客户端发送消息,因为服务器TCP已关闭所以发送不成功,默认配置重试15次
                2.当客户端不发送消息,TCP保活机制如果两个小时无消息发送,会启动探测线程判断连接状态,如果有异常关闭连接
        2.为什么要进行三次握手？两次握手可以吗？
            第三次握手可以通知服务器端可以正常收发消息,如果只有两次握手服务器第一次收到请求就创建连接,需要等保活检测才断开,可能被SYN攻击导致堵塞
        2.三次的握手过程中可以携带数据么？
            第一次和第二次不可以携带,因为如果恶意攻击(SYN),每次传入大量信息,会造成服务器的长时间读取。
            第三次可携带,因为客户端已经是创建连接状态,所以可以携带数据
        3.SYN攻击是什么？
            client短时间伪造大量不同的创建连接请求,Server端不断做出响应但是收不到客户端确认,Server会一直重试到超时,长时间会导致队列被占满,
            服务器无法处理正常请求,引发网络拥堵甚至系统瘫痪

2.TCP四次挥手(TCP断开)
    1.客户端发送 FIN=1 和 Seq=x 数据包给服务器,表示要断开连接
    2.服务器收到断开请求后,回传 FIN =1 & ack=x+1 & Seq=y(随机数) 返回给客户端
    3.服务器确认传输到客户端数据全部完毕后,回传 FIN=1，ACK=x+1，seq=z(随机数) 给客户端,进入关闭等待状态,等客户端响应后进行closed
    4.客户端收到断开请求后,回传 FIN=1，ACK=z+1，seq=x+1 给服务器,断开连接
    相关问题：
        1.可以三次挥手吗？
            如果三次挥手则需要将server响应合并为一个,处理完请求才响应,如果处理时间长可能导致client一直重试发送直到超时自动关闭,就会存在问题

3.标志位作用：
    1.Seq：客户端或服务器随机生产序列号,标识自身
    2.ACK: 通过ACK和Seq判断是否是给自己的数据包
    3.SYN：同步标志,值为1代表创建连接
    4.FIN：同步标志,值为1代表创建连接

4.TCP与UDP有哪些区别？各自应用场景？
    TCP是点对点进行流式传输,需要创建连接,拥有拥塞控制和流量控制机制,保证数据传输安全性。  常用于HTTP、Telnet、FTP文件传输、POP3、SMTP
    UDP不需要连接,可以一对一、一对多发送,可能造成数据包丢失                          常用于：DNS、SNMP、TFTP、视频、音频、广播等数据传输

5.TCP 协议保证数据传输可靠性的方式主要有
    1.序列号Seq：每次连接创建一个序列号,交互时进行增加,通过序列号保证数据顺序,去重
    2.确认标志ACK：每次响应都会携带ack确认响应的是哪个请求的序列号,如果对方没有ack响应会重试发送请求等待响应
    3.连接管理：创建连接过程需要三次握手,关闭需要四次挥手
    4.流量控制：当接收方来不及处理发送方数据时,能提示对方降低发送频率,防止数据包丢失,会将数据包加入控制队列,按序执行
    5.拥堵阻塞：控制网络负荷,防止拥堵
        1.慢开始：当发送数据时不一次性全部发送,由小到大提高数据量防止拥堵
        2.拥塞避免：当发送拥堵时,将拥堵缓慢增大,降低拥堵时间
        3.快重传与快恢复：把数据包分割成数据段,发送时如果没有响应发送成功就会认为数据丢失，触发重传进行数据恢复

6.为什么需要 TIME_WAIT 状态？
    如果服务器没有收到第四次挥手,会重试直到超过重试次数才进行关闭,保证了服务器超时关闭后客户端才进行关闭
    保活计时器作用？
        1.当建立连接后,如果客户端出现故障就可能导致连接一直占用,保活计时器每两个小时检测连接是否正常,如果检测有问题重试9次就会关闭连接

7.用了TCP一定不会丢包吗？
    1.请求队列满了,继续发送会丢包
    2.当数据量大,流量控制队列不够也会发生丢包
    3.网卡丢包,网线接触不良,网卡性能不足都可能导致丢包
    解决方案：
        当发生丢包,一端无法收到ack确认,这是会进行重试,如果超过最大重试次数则失败

8.什么是粘包?怎么产生的?如何解决？
    如何产生？
        1.TCP协议可能会对数据分包,接收方将分包数据组合到一起,这个过程中可能导致粘包
        2.缓冲区存放多个数据包时,因为读取是按照预估长度读取,所以可能产生粘包,服务器拆包时就会拿到两个数据包的内容
    如何解决？
        1.封装数据包的时候在数据包头增加数据长度,防止预估大小出现包含其他包情况
        2.封装数据包的时候增加起止位置标识,解决粘包 (推荐)
        3.使用更高级的传输协议,例如：HTTP、RPC、WebSocket都解决了粘包问题

9.WebSocket、socket、WebService、Http、RPC区别?
    一、TCP/IP 协议和 HTTP 协议的区别
        TCP时传输层协议,主要解决数据网络传输,无法识别数据内容。而HTTP时应用层协议,主要是对TCP收到的数据进行响应解析处理
    二、HTTP 和 WebSocket 区别？
        都是基于TCP,WebSocket主要解决双向通讯问题,常用于聊天系统
        HTTP是一请求一响应方式,如果想要实现双向通讯 需要保证长连接或者轮询 比较消耗资源
    三、RPC 和 HTTP 区别？
        RPC一般内容调用方式,基于Socket,采用流传输所以性能比HTTP高。 场景：Dubbo、WebSocket、ES集群间,都是采用RPC调用
        HTTP一般对外调用,数据封包比较大,性能不如RPC,但是HTTP2.0引入长连接,并且对数据头进行压缩,底层也采用流传输,性能和RPC差不多
    四、Socket(套接字)：是应用层和协议层的中间层,隐藏TCP内部复杂操作给应用层提供一组接口进行使用的一种方式
------------------------------------------------------------------------------------------------------------------------
网络层
1.IP：计算机的标识号,用来区分计算机
    1.IPV4(Internet Protocol version 4)网际协议版本4：  IP： 192(11000000).168(10101000).10(00001010).1(00000001)
        由32位 2进制 组成,通过采用点分十进制查看！          掩码:255(11111111).255(11111111).255(11111111).0(00000000)
    2.IPV6(网际协议版本4):
        由于人数群体多,2011年IPV4能使用的42亿地址全部消耗,所以扩大地址采用(16字节)128位16进制组成. 用来解决IP资源数量不足的问题
    5.IP地址组成
        1.网络部分(网段): 点分十进制前三个组成俗称网段
        2.主机部分(IP):  点分十进制最后一个是主机部分
        3.路由器:可以连接不同网段,负责不同网段之间的数据交换
        4.交换机：连接相同网段的计算机,通过配置网段+IP保证交换机连接的所有计算机IP的唯一性！
    6.特殊IP
        1.0.0.0.0：任意网段任意IP  无法使用
        2.255.255.255.255：广播地址
        3.127.0.0.1~127.255.255.255:属于回环网段

2.端口号：每台计算机很多应用程序,使用端口号来区分应用程序
    1.取值范围0~65535.其中0~1023之间的端口用于一些知名的网络服务和应用
    2.普通应用需要使用1024以上的端口号,如果端口号被其他应用占用,会导致启动失败

3.为什么有了IP地址还需要MAC地址？
    最早其实只有MAC地址,但是只能局域网使用,后续引入IP可以通过路由器或交换机进行流量转发 实现 局域网互联

4.ICMP协议？ping指令就是用ICMP实现的
    ICMP用于在主机或路由器之间传递控制信息(网络通不通、路由器是否可用等),主要作用就是检测与响应,如果发生异常会通过ICMP响应网络异常情况。
------------------------------------------------------------------------------------------------------------------------
1.什么是SQL注入？
    SQL注入是一种安全漏洞,在用户输入时拼接SQL实现攻击,例如：1.拼接或true恒成立  2.查询拼接修改表或删除表攻击
    如何解决？
        1.增加XSS验证,进行无效请求截取
        2.尽量避免动态SQL进行SqlNode拼接,使用静态SQL包含预编译,防止SQL注入
    什么是预编译？
        将语句模板化,参数用？号代替,执行的时候将参数加双引号填充,一次编译多次运行,省去解析优化过程,提高性能,并且加双引号可以避免SQL注入
    #{}和${}区别？
        #{}包含预编译,字段用？代替,执行时将参数加双引号替换,可以避免SQL注入,并且预编译后加入缓存,可以多次使用 提高性能
        ${}属于动态标签,在执行时会将输入文本替换,常用于 表名、分组、排序时使用,如果必须使用需要业务层进行严格判断,防止发送SQL注入

2.什么是 XSS 攻击？
    跨站脚本攻击,攻击者在网站上注入恶意代码,控制用户浏览器完成具体操作
        1.Cookie劫持：恶意脚本获取cookie,无须登录就可以进入账户实现攻击。 有些网站会将cookie和IP进行绑定,防止被窃取
        2.通过脚本构建GET、Post请求服务器,获取服务器数据。              可以通过验证码解决,获取修改密码需要旧密码可以避免
        3.画上画骗取用户名密码,劫持验证码图片后传入验证码,都可以实现攻击
    如何防护？
        1.在后端增加过滤器,对请求匹配XSS攻击相应字符,如果存在禁止访问
        2.cookie信息客户端IP绑定,防止 cookie泄露导致攻击
        3.浏览器增加转义,就算被注入攻击脚本也不会显示到浏览器,避免被攻击

3.什么是DoS、DDoS、DRDoS攻击？
    1：拒绝服务攻击(DoS):使目标电脑的系统资源耗尽,无法处理正常请求
    2.分布式拒绝服务(DDos攻击):攻击者控制多台电脑对目标电脑攻击,使其资源耗尽,无法处理正常请求
    3.分布式反射拒绝服务(DRDoS):攻击者冒充一个IP进行大量请求,使服务器对此IP做出大量响应,从而耗尽系统资源,无法处理正常请求

4.URI和URL的区别
    统一资源标志符(URI):主要作用是唯一标识一个资源。       例如： /login/info
    统一资源定位符(URL):主要作用是提供资源, 协议+IP+资源  例如：http://127.1.1.1/login/info

5.forward 和 redirect 的区别？
    1.间接转发(redirect)： 常用于未登录重定向登录页
        1.客户端浏览器也会发生变化  2.重定向资源不可共享  3.服务器响应后浏览器重新发送请求,两次请求,两个request对象所以数据不能共享
    2.直接转发(forward):   常用于服务器内部请求控制
        1.服务器内部转发,客户端浏览器不会变化  2.只有一次请求,共享一个request所以可以共享资源  3.一次请求效率搞


