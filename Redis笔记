发展历程
90年代：使用单机数据库 +静态html页面。  访问量不大  单个数据库足够使用
        1.数据量总大小 一个机器放不下 ----》300w必须创建索引
        2.数据的索引（B+ Tree）一个机器的内存放不下时
        3.访问量多(读写混合)--》一个服务器受不了
        16G内 存能放下大概 2000W 行数据的索引，  简单的读和写混合访问量3000/s左右没有问题，
Memcached（缓存）+MySQL + 垂直拆分
        1.网站80%都在查询。每次操作数据库十分麻烦,为减轻数据库压力。可以使用缓存
        2.但是数据量大了还是会出现最初内存不够  访问量大无法承受的问题
读写分离：主库承担写的压力，分库承担读的压力
        1.对于读多写的少  适用
        2.写入量大  会造成主库无法承受
水平拆分：数据量变成1/n,,可以提高并发量和稳定性
        1.分片式事务不好解决
        2.跨库join性能降低。而且维护难度提高。
云数据库：
缓存适用于数据变动不大。但是像用户日志。数据量大变动又快的东西 关系型数据库就不适用了

RDBMS（关系型数据库）
  优点1.通用sql,表形式便于理解,降低数据冗余和不一致概率
  缺点1.高并发下读写效率低 2.数据库很难横向扩展  3.复杂sql,多表连接
NOSQL区别：
  优点 1.方便扩展(数据直接无关系,很好扩展)
      2.大数据量高性能(1s读11万。写8w,nosql缓存是一种细粒度的缓存,性能比较高)
      3.不需要事先设计数据库。数据类型多样型（String、）
NOSQL四大分类
  1.键值对key value存储：Redis（C编写） 、Tair 、memcache
     优点：查找速度快
     缺点：数据没有结构,通常只被当作字符串和二进制数据
     应用场景：数据缓存，日志
  2.文档型数据库： 基于分布式文件存储的数据库 MongoDB(C++编写) 主要用来处理大量的文档 介于关系和非关系之间是最像关系型数据库的
     优点：数据结构要求不严格
     缺点：查询速度低
  3.列存储数据库： Hbase 、 分布式文件系统
     优点：查找速度快,可拓展性强
     缺点：功能相对局限性。因为是以列存储的
     应用场景：分布式文件系统
  4.图形关系数据库： 比如朋友圈,社交网络,广告推荐  Neo4j
     优点：利用图结构算法,查找最短路径
     缺点：很多时候需要所有数据才能得出结论,不好做分布式集群
     应用场景：社交网络,朋友圈,广告推荐

Redis：远程字典服务
  是一个开源的使用c编写的、支持网络、可基于内存可持久化的日志型、key-value类型的数据库,提供多种API。也被称为结构化数据库
  作用：
    1.内存存储,持久化,内存是断电即失的,所以持久化很重要（RDB/AOF）
    2.效率高,可以用于高速缓存
    3.用于发布订阅
    4.地图信息分析
    5.计时器、计数器(浏览数)
官方自带的压力测试工具redis-benchmark
11集
Redis默认有16个数据库。索引0~15  默认是0数据库。
  select 3 ：切换数据库。
  keys *   ：查看当前库中所有的Key
  DBSize   ：查看当前库的大小
  flushAll ：清空全表
  flushdb  ：清空当前数据库
  move name 1 ：将name移动到1数据库
  expire name 10：10s过期时间
  ttl name：（time to live）查看name的剩余过期时间
  type     ：查看key 的基本类型         Exists key    ：判断是否存在

Redis是单线程的

Redis：是一款开源的,内存中的数据结构存储系统,可以用做数据库,缓存和消息中间件.支持多种数据结构。String、Hash、List、set、Zset
与范围查找,bitmaps,hyperloglogs和地理空间geospatial索引半径查询,Redis内置了复制(replication)、事务和不同级别的磁盘持久化
并通过Redis哨兵和自动分区提供高可用性
String类型               ：点赞。浏览量
  append key value：将这个key的值拼接value,如果key不存在就相当于set
  StrLen key ：获取字符串的长度
  incr key  :相当于i++  可以做浏览量   decr key ：相当于i--   配合incr可以做点赞
  incrBy key 5：相当于i+5    decrBy key 5 ：相当于i-5
  increase  increment     decrement  decrease
  getRange 0 3 :截取字符串下标0-3。[0,3]包含0 1 2 3。  如果想要获取全部 getRange 0 -1
  setRange key 1 XX  :将key的索引1位置字符替换成XX存入
  setex name 30 “whj”：相当于set name “whj”+expire name 30
  setnx(SET if Not eXists)：如果不存在进行set存在返回失败0.而set是覆盖
  mset:批量设置多个值 mset k1 v1 k2 v2 k3 v3       mget:批量获取多个key:mget k1 k2 k3
  msetnx:如果存在设置多个值。一个重复则全部失败。
  getset：先get值然后又set
List类型(列表)     Redis中List类型可以用来当成栈、(消息队列)队列、双端队列、阻塞队列   头尾操作效率高。中间效率低
  lpush list1 1 2 3 4 5:将1-5从左边压入   rpush list2 1 2 3 4 5:将1-5从右边压入
  lrange list1 0 -1： 5 4 3 2 1         lrange list0 0 -1：1 2 3 4 5
  lpop：将左边第一位取出来移除              rpop：将右边第一位取出来移除
  lindex key 3：从左面取索引为3的实际是第四个元素    llen：获取list长度
  lrem key 2 1；从左面删除第一个和第二个1    Ltrim key 0 2：从左边截取list的key索引为0-2然后赋值给key
  rpopLpush key key1：从右边取key的值并移除然后从左边将这个值压入key1
  lset key index value：将key左边索引为index的值更新成value
  linsert key before/after 值1 值2：找到key的值1位置在前面或者后面插入值2
Set类型：    共同关注,共同爱好,推荐好友,（六度分割理论）
  sadd key 值：给set集合插入值,值不可重复   smembers key：获取所有的值  scard获取集合里元素数量
  sismembers key value：查看集合是否存在这个value 返回0/1    srem key value：移除key中的value元素
  无序不重复集合：srandmember key 1:随机获取key集合的1个元素  spop key：随机删除key中的一个元素
  smove key1 key2 value：将key1的value移动到key2集合中 不指定value则是随机移动一个
  sdiff key1 key2：key1集合中key2没有的元素     sinter key1 key2：key1,key2都存在的元素
  sunion key1 key2；将key1和key2元素合并去重
Hash类型：也是键值对,值是map集合 key-map   存一个变更的数据。用户数据 适合存储对象。而string适合字符串
  hset people name whj： 插入值      hget people name：获取值    hgetall people：获取people中所有键值对
  hmset people name whj age 20：插入多个值  hmget people name age：获取多个值  hdel people name：删除name键值
  hlen people ：获取people中的键值对个数   hexists 键名 值键名：判断是否存在返回0/1
  hkeys key：获取key中的所有key   hvals key：获取key中的所有值
Zset类型：  存储班级成绩 工资表  带权重执行  排行榜
  zadd k1 score v1：
  zrangeByscore salary -inf +inf：查询指定范围的元素 zrangebyscore salary (2500 5000 ====>(2500,5000]
  //todo zrangeByscore salary -inf +inf withscore:查询最小到最大并携带成绩
  zrange salary 0 -1：查看所有元素     zrem salary xiaohong：移除小红
  zcard salary：查看元素数量   Zrevrange 0 -1 ：成绩从高到低排列
三种特殊的：geospatial(地理位置)：附近的人 朋友定位  打车距离计算    底层其实就是zset有序集合.可以使用zset命令查看全部和删除
  geoadd key 纬度 经度 name：添加经纬度和名称。 两级无法直接添加。一般会下载城市数据,在java中一次性导入
  geopos key name name1：查询key中name的经纬度。可以有多个name
  geodist key name name1：查询key中name和name1的距离(m\km\mi(英里)\ft(英尺))
  georadius key 经度 维度 500半径范围 单价km：以给定经纬度为中心,找出某一半径内的元素  附近的人
  georadius key 经度 维度 500半径范围  单价km  withdist(距离)或者withcoord(经纬度)  count 数量
  georadiusBymember key name 500 km：查找指定name的附近500km的地方
  geohash key name name1：将key中的name和name1转换成11位的hash字符串 二维经纬度变成一维字符串,越相似越近
hyperloglog：基数统计  一个key中不重复的值。数据量大可以接受误差
  优点：占用内存小 一个人访问多次网页算一个。这种如果要用set实现占用内存大
  PFadd key values：给key添加多个值      pfcount key:统计key的不重复数据个数。可以有多个key则为并集
  pfmerge 新key key1 key2：将key1和key2的值合并生成key3
bitmap：位图 数据结构。都是操作二进制来进行记录。 位存储   统计用户活跃不活跃 10101  登录未登录  打卡
  setbit sign 0 1：设置周一到周日的打卡,第一个是周一到周日,第二个是位0 1。 setbit sign 1 0  setbit sign 2 1
  getbit sign 3：获取周四打没打卡。     bitcount sign start end：默认查看所有为打卡1的个数
Redis事务操作：
  一组命令集合,所有命令都会被序列化,会按照顺序执行。 单条语句具有原子性,多条没有原子性。
  错误类型：编译错误   运行错误   本条运行错误不影响其他运行。但是语法在编译报错则整体报错。 没有隔离性
  开启事务 multi    语句。。。。。    exec执行事务。   discard 取消事务

Watch 监控事务：
  watch命令可以决定事务会回滚还是提交。在事务multi开启之前开启watch监控一些键值对。exec提交的时候检查。键值对没有被其他线程修改
  则提交事务,如果值被修改,则回滚事务。 乐观锁的思想,类似于判断版本。和多线程中CAS的原子引用的乐观锁类似。
  开启：  watch key    取消1.事务exec执行完毕。无论成功失败监控都取消 2.客户端推出 3.手动unwatch 取消
Jedis：使用Java来操作redis,官方推荐java连接redis工具。相当于连接redis的中间件
  new Jedis()参数：ip 端口号 可选：ssl 超时时间       jedis.close()//关闭连接
整合Spring boot：
  Jedis：采用直连,多个线程操作是不安全的,避免不安全,加入jedis pool连接池，更像BIO模式
  netty:采用netty,实例可以在多个线程间共享,不存在线程不安全,可以减少线程数，更像NIO模式
  redisTemplate.opsForValue();//操作String类型  opsForList//操作list   opsForset//操作set
  redisTemplate.getConnectionFactory.getConnertion()//获取连接对象。结果可以进行 flushdb 和 flushall
---------------------------------------------------------------------------------------------
序列化： 任何存储,传输都需要进行序列化,只不过数据库内部已经解决了.在插入的时候进行序列化.在取出来的时候进行解析,而redis内部并没有
解决,redis的value是byte array字节数组。所以需要将数据结构转成字节数组。而字符串几乎就是字节数组,所以不需要转换
  序列化：把对象转化为可传输的字节序列(字节数组)过程称为序列化。
  反序列化：把字节序列(字节数组)还原为对象的过程称为反序列化。
  方式：JDK（不支持跨语言）、JSON、XML    技术选型关键点 1.序列化速度 2.序列化字节数组大小
  JAVA序列化中常见的问题: 问题一：static 属性不能被序列化
  原因：序列化保存的是对象的状态，静态变量属于类的状态，因此 序列化并不保存静态变量。
  问题二：Transient 属性不会被序列化   短暂的属性
  问题三：序列化版本号serialVersionUID  当对象有改动但是版本号一样。不会影响序列化和反序列化。只不过最新的改动会失效
  每个对象必须有版本号，如果没定义会自动生成,自动生成的版本号只要对象有改动就会变更,变更用户就需要更新版本。因此建议手动设置



单线程多线程  事务特性    百度Redis乐观锁高并发秒杀    setex分布式锁





