设计模式的六大原则
    1.开闭原则：扩展开放修改关闭,对程序进行扩展的时候不能修改原有代码
    2.依赖倒置：子类尽量继承抽象类或接口,高层定义规范,子类实现具体细节,提高扩展性
    3.里氏替换：继承子类可以重写父类方法实现功能
    4.接口隔离：将不同功能定义到不同接口中,具体功能实现具体的接口,降低冗余
    5.迪米特(知道最少)：每个模块尽量减少对其他模块的调用,降低耦合度
    6.单一职责：一个类只负责一项职责,降低代码复杂度
设计模式的分类
    1.创建型模式：创建对象用的,提高创建对象的灵活度
    2.结构型模式：通过改变代码结构来进行解耦,使代码更容易扩展和维护
    3.行为型模式：关注程序的流程控制
1.创建型模式(5种)
    1.单例模式(Singleton):
        1.饿汉单例：         缺点：如果程序中未使用,则一直占用内存
        2.懒汉单例：         缺点：多线程下单例会被破坏
        3.线程安全,懒汉单例(加锁)：   缺点：性能低
        4.双重检查懒汉
        5.静态内部类单例
        6.枚举实现单例模式
        一、通过反射还能保证单例吗？
            1.ENUM无法通过反射调用
            2.饿汉和静态内部类可以保证,在构造方法中抛异常禁止
            3.懒汉无法保证
        二、反序列化如何实现单例？
            需要增加一个readResolve()方法调用getInstance()方法,Enum提供了一个ReadEnum的方法
    2.简单工厂模式|静态工厂模式(Factory): 
        通过工厂来创建对象,达到解耦目的    例如Spring中BeanFactory mybatis中SqlSessionFactory
        缺点：1.如果要增加传入参数的种类,可能要修改逻辑,违反开闭原则   2.如果参数种类比较多工厂类比较复杂
    3.抽象工厂模式(Abstract Factory):用于创建一系列相关的对象， 而无需指定其具体类
    4.建造者|生成器模式(Builder)  例如：mybatis中XMLScriptBuilder、XMLStatementBuilder、XMLConfigBuilder、XMLMapperBuilder
    5.原型模式(prototype)
2.结构型模式(7种)
    1.代理模式(Proxy)：本地就是通过代理类创建对象,对被代理对象进行相应增强
    2.适配器模式(Adapter)：
        1.默认适配器：例如一个接口很多方法,实现的时候需要全部重写很麻烦,可以创建一个适配器进行实现,然后继承适配器重写想要使用的方法即可
        2.对象适配器：将一个对象包装成一个完全不想关的另一个对象使用
        3.类适配器：通常指多继承【内部包含实现包含继承】
        使用场景：现有类接口不符合需求,采用适配器将接口进行兼容。 SpringMVC中HandlerAdaptor就是采用适配器类
    3.桥接模式(bridge)
        画图：【什么颜色笔画什么图形】 将颜色和图形抽象解耦出去,调用时进行组合   缺点：需要建立抽象层增加理解难度
        使用场景：一个对象有多个变化因素时,考虑将变化因素抽象实现,而不是具体实现到对象中
    4.组合模式(composite)
        基于层级关系,抽象出来一个对象  例如：公司人员架构图,我们可以定义一个对象判断是否包含上级下级进行处理,而不需要创建多种对象进行判断
        缺点：破坏了单一职责的原则,提高了代码复杂度
    5.外观模式/门面模式(Facade)
        系统中多个外观类包装出一个门面类提供外部调用,简化客户端代码    缺点：不能很好的限制客户端能访问的功能范围  2.新增新功能可能要修改门面类,违反开闭原则
        场景：当一个复杂的系统想要对外提供调用时可以通过外观模式创建一个类,该类可以实现大多数功能调用,简化客户端逻辑
    6.装饰模式(Decorator/Wapper)
        通过继承方式给对象添加行为  缺点：类会越来越多,结构复杂
    7.享元模式(Flyweight)
        当一个系统中包含大量重复对象,如果对象时不可变的则可以创建一份重复使用,节省内存.例如：字符串常量池
        缺点：内部缓存会保存享元对象所以不会被垃圾回收,如果不被频繁使用也属于一种浪费内存的情况,所以需要确认是否可以节约内存再使用
3.行为型模式(11种)
    1.责任链模式(Chain of Responsibility)
        先创建一个链表,只需要执行头节点,内部会判断是否包含下一节点进行自动处理 例如：过滤器、拦截器、异常处理【Exception Handling】
    2.迭代器模式(Iterator)
        按照不同需求创建对应迭代器进行数据遍历
        优点：可以按照需求创建多个迭代器      缺点：创建迭代器会增加类,提高程序复杂度
    3.策略模式(Strategy)
        将策略定义成一个接口,提供多种策略,用户可以根据需要进行不同行为的创建  例如：线程池拒绝策略
    4.模版模式(template)
        通过抽象类或接口定义模板方法,子类进行相应实现     例如：mybatis中Executor、Collection
        缺点：每一个不同的功能就需要重写一个子类
    5.状态模式(State)
        对象需要在不同状态下展现不同行为  例如：1.AQS的Node节点封装状态,如果自己状态是0则继续唤醒,如果状态-1进行节点唤醒   2.加锁状态0/1判断
    6.观察者模式/发布订阅模式(Observer/Listener)
        通常通过中间件实现,订阅者订阅频道,当有发布者发布消息时订阅者能及时收到  例如：Redis订阅发布、Spring时间广播监听器
    7.解释器模式(Interpreter)
        类似词法解析,语法解析将一个语句解析成树状结构   例如：Antlr4、JVM解析器
    8.访问者模式(Visitor)
    9.备忘录模式(Memento)
    10.命令模式(Command)
    11.中介模式(Mediator)

单例模式优缺点？
    优点：多次访问都共用一个对象,不用频繁创建销毁,节约资源   缺点：一旦加载生命周期和进程一致,属于内存泄漏
    场景：创建对象耗时,但又经常使用,例如：工具类、数据库连接、Redis连接、IO
原型模式应用场景？
    类初始化需要消耗很多资源,可以采用拷贝来提高性能   例如：Object中clone就是默认浅拷贝、Spring中多例就是原型模式
工厂模式区别？
    简单工厂：有一个工厂,使用这个工厂来创建一种对象            场景：适合产品较少
    工厂方法：有多个工厂,根据组合来创建一种类型的多个对象       场景：一个类型多个产品  例：小米工厂、华为工厂 内部CPU、内存不一致
    抽象工厂：有多个工厂,并且工厂内部包含多个接口              场景：适合多种类型多个产品 例：Dell工厂、华硕工厂  每个工厂内部提供键盘、主板等


代理模式和适配器模式区别【通常指对象适配器】？
    代理模式通过代理类给对象做了增强,比如给鸡装上刀片,成了战斗鸡
    适配器模式将对象包装成完全不同的对象进行使用,比如把鸡包装成鸭进行贩卖,而鸡鸭没有任何关系
代理模式和装饰器模式区别？
    代理模式通常内部创建被代理对象,隐藏对象具体信息,注重【权限处理】
    装饰器模式通常创建对象传入装饰器对象,注重【对象功能的扩展】
策略模式和桥接模式区别？
    桥接模式：例如用什么颜色笔画什么图案：使用的对象和做出的行为都进行抽象封装。是结构类型设计模式
    策略模式：只针对行为封装,强调的是策略。是行为类型设计模式

Spring使用了哪些设计模式？
    代理模式：AOP   单例模式|原型模式：Bean单例、多例   工厂模式：BeanFactory   模板方法：jdbcTemplate   观察者：事件监听
Mybatis中的设计模式
    工厂模式：SqlSessionFactory  代理模式：MapperProxy  组合模式：SQLNode  模板方法：Executor  适配器模式：JDBC适配














