虚拟机：就是一台虚拟的计算机   计算机上操作系统-》软件   操作系统是系统软件.qq软件是应用软件
    1.系统虚拟机：对物理计算机的仿真。VMware
    2.程序虚拟机：相当于应用。在操作系统上安装,代表JVM

sun公司的 hotspot 虚拟机  主学   还知道IBM的J9虚拟机。apache的 harmony
JVM：支持多语言混合编程。只需要关心如何编译成字节码文件即可
    一次编译到处运行。  java文件编译成二进制字节码文件。  可以在不同的操作系统JVM中解析运行
    1.自动内存管理
    2.自动垃圾回收
    3.数组下标越界检查   实现多态
    优点：降低内存泄漏风险
    缺点：弱化程序员处理OOm的经验
JVM-》JRE(JVM+基础类库)-》JDK(JRE+编译工具)-》开发JavaSE程序(IDEA+JDK)->开发JavaEE程序(IDE+JDK+应用服务器)
JRE是Java运行时环境：比JVM多出来一些java类库(java.io java.lang java.util)
JDK是Java开发工具包  集成了javac编译器  jar打包工具  javadoc文档生成器
--------------------------------------------------------------------------------------------------
JVM的生命周期：
  1.启动
    java虚拟机启动是通过引导类加载器创建一个初始类来完成的.这个类是由虚拟机的具体实现指定的
  2.执行：执行Java程序
    执行一个java程序的时候,真正执行的是一个Java虚拟器进程。   程序启动才执行,程序结束就停止
  3.退出
    1.程序结束正常退出
    2.遇到异常或者错误 终止
    3.操作系统错误  终止
    4.线程调用RunTime类或者System类的exit方法结束或者直接调用RunTime类halt方法终止线程
    5.JNI（JAVA native interface）:描述了用JNI加载或卸载虚拟机时,java虚拟器的退出情况
--------------------------------------------------------------------------------------------------
class二进制文件
  cafe babe (魔术)：表示这是一个java文件,
  0000 0034：小版本号,大版本号(十进制是52 对应JDK1.8   53对应JDK1.9)
  常量池信息  访问修饰符 全限定名  接口数量  属性 方法
java文件编译Class文件,常量池载入运行时常量池,方法字节码载入方法区,main方法运行分配操作数栈和局部变量表,执行引擎JIT编译器编译成机器指令交给CPU运行
----------------------------------------------------------------------------------------------------
指令
操作数栈
  bipush 将一个byte压入操作数栈   sipush 将一个sort压入操作数栈  ldc将一个int压入操作数栈  ldc2_w将lang分两次压入
  一个操作数栈的宽是4byte 不够0补齐,超过short范围的数字就放入常量池中,否则就和字节码指令放一起
局部变量表
  istore 将当前操作数栈的值放入局部变量表    iload  读取局部变量表的的值读入操作数栈
a++
  iinc是直接在局部变量表的slot槽位上运算的   a++和++a的核心是看先iinc还是先iload
条件判断判断
  ifeq:==      ifne:!=       iflt:<         ifle:<=        ifgt:>       ifge:>=
  if_icmpeq:两个int是否相等    if_icmpne:两个int是否!=     上述同理
  if_acmpeq:两个引用是否相等    if_acmpne:两个引用是否!=     上述同理
  ifnull   判断==null         ifnotnull  判断！=null
  说明：byte、short、char都是按int比较  因为操作数栈都是4字节      goto：用来跳转到指定行号字节码
Cinit方法
  会将类中所有静态组合在一起从上到下执行
init方法
  会将类中属性和代码块组合在一起从上到下执行
多态原理(运行期间动态查找,效率低。 JVM自己优化：1.同一个方法调用多次会增加到缓存中 2.当多态只有一个实现类会做成单态优化)  HSDB工具
  类的加载链接阶段生成虚方法表(vtable),vtable中记录了每个虚方法(静态和final修饰之外都是虚方法)的偏移量和内存地址
  1.一个方法被重写,对应vtable中的指针从父类方法改为自己方法 Object(equals,hashcode,finalize,toString,)
抽象方法和虚方法区别？
  1.虚方法有方法实现(方法体),抽象方法没有方法实现
  2.抽象方法只能在抽象类中定义,虚方法可以在任何类中定义
  3.抽象方法必须在派生类(子类)重写,和接口类似,但是虚方法不需要
多态概述？
  1.方法重载：典型构造方法,方法名相同,参数不同(参数个数,参数类型,返回值可以相同可以不同)
  2.方法重写：父类与子类的多态性,重写父类方法  方法名参数返回值都相同
try catch原理
  1.finlly的代码实际在字节码中被复制了3份,一份try后面,一份catch后面,当catch没有匹配到的剩余异常类型后面
  2.finally实际在异常表中多检测一个catch块中的异常,当异常捕获catch匹配不到就会被finally捕获到然后执行finally的代码,
  finally执行完代码后会找到自己捕获的异常然后继续抛出给调用者
finally中出现return
  1.try{int i=10; renturn i;}finally{i = 20; return i;}      结果为20
  finally会被复制3份,因此结果和finally中return相同。  如果只写try finally会把异常吞掉,就算发生异常也看不出来
  2.try{int i=10; renturn i;}finally{i = 20}                 结果为10
  try执行到return会将i值存入局部变量表新位置,而finally复制是拿局部变量表原始位置的值进行修改。return还是新位置的值。相当于暂存了一下
synchronized原理 出现异常正确解锁  只是代码块才可以查看字节码,方法级别的不会体现,因为会表现在方法声明上而不是代码中
  1.字节码中加锁(monitorenter)解锁(monitorexit),也会引入异常表,没有异常就调用解锁,发现异常后将异常存入局部变量表,去除lock对象解锁
  然后去除异常进行抛出
语法糖：   编译器在编译期间自动生成和转换的一些代码.减轻程序员负担
  1.默认构造器     2.自动拆箱装箱
  3.泛型擦除：List<Integer> 只有编译期检测类型是否匹配,它的add和get方法在字节码中实际使用的是Object,get后强制转化为定义类型
  4.泛型反射：擦除的是字节码上的泛型信息,方法参数的信息保存在局部变量类型表。。。 参数和返回值的泛型信息可以通过反射获取到
  5.foreach：配合数组：字节码跟for一样   配合集合(只有实现了iterator接口的才能配合foreach)：字节码跟迭代器一样
  6.switch：先去判断key的hash码,然后内部判断字符串是否相同,最后相同执行方法体
---------------------------------------------------------------------------------------------------
Java执行流程
  1.java文件通过前端编译器生成.class文件
     1.词法分析-》语法分析-》语言/抽象语法树-》语义分析-》注解抽象语法树-》字节码生成器
  2.经过Java虚拟机
     1.类加载器
     2.字节码校验器
     3.执行引擎                 高级语言翻译成机器指令的过程
        1.翻译字节码(解释运行)：将字节码文件编译成字节码指令
        2.JIT编译器(编译运行) ：将字节码指令翻译成机器指令。同时将反复执行的代码缓存起来。保证执行性能
     4.操作系统

----------------------------------------------------------------------------------------
类加载区
插件jclasslib  java编译成class字节码文件。可以通过这个插件查看
    1.init  是类的字节码文件
    2.clinit 如果有静态代码块或者静态变量赋值就会自动生成
父类静态字段-》父类静态代码块-》子类静态字段-》子类静态代码块-》父类成员变量(非静态字段)-》父类非静态代码块-》父类构造器-》子类成员变量-》子类非静态代码块-》子类构造器
类加载器(类加载子系统)
    这四种加载器是包含关系。不是父子类继承的关系    ClassLoader是一个抽象类
 1.Bootstrap ClassLoader引导类加载器(启动类加载器)。C和C++编写,嵌套在JVM内部
    1.获取引导类加载器  ClassLoader BootStrapClassLoader = extClassLoader.getParent();  结果为null
    2.Java的核心类库(rt.jar,resource.jar)都是由引导类加载器加载的,只加载包名为java,javax,sun开头的类
    3.扩展类加载器和应用类加载器是由引导类加载器加载的
 2.Extension ClassLoader扩展类加载器。Java编写 ExtClassLoader
    1.获取扩展类加载器 ClassLoader extClassLoader = systemClassLoader.getParent();
    2.继承于ClassLoader。也属于自定义加载器。  父类加载器是启动类加载器
    3.加载的是jre/lib/ext目录下的文件
 3.System ClassLoader系统类加载器(应用类加载器)。Java编写    AppClassLoader
    1.获取系统类加载器  ClassLoader systemClassLoader = new getSystemClassLoader();
    2.用户自定义的类默认是由系统类加载器加载
    3.继承于ClassLoader。也属于自定义加载器。  父类加载器是扩展类加载器
 4.自定义类加载器
    1.什么场景下需要自定义加载器（为什么要自定义类加载器）？
        1.隔离加载类：避免重名类冲突
        2.修改类加载方式
        3.扩展加载源
        4.防止源码泄露
    2.如何创建自定义加载器？
        1.创建一个类继承ClassLoader类 覆盖findClass方法
        2.创建一个类继承URLClassLoader方法
 作用  ：将class字节码文件转换成Class对象
   1.类加载器负责加载class文件,class文件在文件开头有特定的文件标识  CAFEBABE魔术
   2.加载器只负责加载文件,是否可以运行由执行引擎决定
   3.加载类的信息存放于一块方法区的内存空间,除了类的信息外,方法区还会存放运行时常量池信息
 1.加载阶段(loading)
   1.将class字节码,解析成运行数据instanceKlass(C++指令)存储到方法区,在堆中生成一个镜像Class文件
   2.如果这个类父类没有加载会触发父类的加载 。  加载和链接可能是交替执行的
 2.链接阶段（linking）  将 Java 类的二进制代码合并到 JVM 的运行状态之中的过程。 在链接之前，这个类必须被成功加载
   1.验证(Verify):
       1.确保Java类的二进制表示在结构上是完全正确的。 如果错误会抛出VerifyError
       2.主要包括四种验证：文件格式验证、元数据验证、字节码验证、符号引用验证
   2.准备(prepare):
       1.创建Java类中的静态域，并将这些域的值设为默认值。int(0) 引用类型(null) boolean（false）
       2.如果是final常量在编译的时候已经分配值了,所以这个阶段会显式初始化
   3.解析(resolve)
       1.确保当前类引用的其他类被正确地找到，该过程可能会触发其他类被加载。 符号引用
 3.初始化阶段(initial)
   1.Java类第一次被真正使用到的时候，JVM会进行该类的初始化操作。主要操作是执行静态代码块和初始化静态域。
   2.准备过程就是将静态变量分配默认值。而这个阶段会按照代码的顺序执行静态代码块和初始化静态变量。
双亲委派机制 ： Java虚拟机需要Java类的时候才加载成Class对象。加载方式是双亲委派机制。既把请求交给父类处理。任务委派模式
    1.如果一个类加载器收到加载类请求,并不会直接加载。而是向上委托给父类依次递归到启动类加载器
    2.如果父类加载器可以完成加载任务，就成功返回。如果如类加载器无法完成,交给子类尝试。依次递归
    优势：避免类的重读加载。   2.保护程序安全,防止API被篡改
    禁止自定义类使用引导类加载器加载。不然会报错。也即是不要使用引导类加载的路径。java,javax,sun
沙箱安全机制：
    就是对Java的源代码的一种保护机制。自定义java.lang.String类 写一个main方法执行。报错没有main方法,因为加载的是rt.Jat包下的String类
在JVM中表示两个Class对象是否为同一个类的条件？
    1.类的完整类名必须一致。包括包名
    2.加载这个类的ClassLoader必须是一个
JVM必须知道一个类型是由启动类加载的还是用户类加载的,如果是用户类加载的,JVM会将类加载器的一个引用作为类型的一部分保存在方法区中
当解析一个类型到另一个类型引用的时候,JVM要保证这两个类型的加载器是相同的

Java程序对类的使用方式：主动使用和被动使用。
    区别：主动使用会初始化类。被动使用不会导致类初始化

JVM整体结构：
  上层
    1.类装载子系统(类加载器)字节码文件通过类加载器生成大的Class对象
  中层（运行时数据区 Runtime date Area）   其中方法区和堆是多个线程共享的,而Java栈,本地方法栈和pc寄存器是每个线程都有一份的
    1.方法区(method Area)元数据区:       有可能造成OOM
    2.堆（heap）:                       有可能造成OOM
    3.Java栈(虚拟机栈):                  有可能造成OOM       没有GC
    4.本地方法栈：:                      有可能造成OOM
    5.程序计数器(PC寄存器)：                没有OOM           没有GC
  下层
    1.执行引擎(计算机只执行机器指令,而字节码文件不等同于机器指令,执行引擎将字节码文件翻译成机器语言)
      1.解释器
      2.编译器(JIT编译器)
      3.垃圾回收器
    2.本地方法接口
    3.本地方法库
----------------------------------------------------------------------------------------------------------------------
运行时数据区（RunTime date area）
内存：非常重要的系统资源,是硬盘和CPU的中间仓库及桥梁,承载着操作系统和应用程序的实时运行。
    JVM内存布局规定了Java在运行过程中内存的申请,分配,管理的策略,保证了JVM的高效运行
    1.JVM运行一个应用有多个线程并发执行
    2.Hotspot的虚拟机里每个线程和操作系统的本地线程直接映射.
    3.当Java线程准备好执行后,操作系统的本地线程也同时创建,java线程终止后本地线程也会回收
    4.操作系统负责所有线程的安排调度到任何一个可用的CPU上,一旦本地线程初始化成功,就会调用Java线程中的Run方法
    5.本地线程回收前决定JVM要不要终止。看当前线程是不是最后一个非守护线程
虚拟机里主要的后台程序线程
    1.虚拟机线程
    2.周期任务线程
    3.GC线程
    4.编译线程
    5.信号调度线程
---------------------------------------------------------------------------------------------
PC寄存器（程序计数器）PC Register
作用：    用来存储下一条指令的地址。由执行引擎读取下一条指令。解释器解析一条指令交给CPU
    1.占用空间最小,运行速度最快的内存区域。是线程私有的
    2.保存下一条指令地址。如果是Native方法计数器是空的(undefined)
    3.不存在内存溢出的区
使用PC寄存器存储字节码指令有什么用（为什么使用PC寄存器记录当前线程的执行地址）？
  并发执行多个线程。CPU需要不停切换各个线程,切换回来需要知道从哪开始。并且JVM解释器需要改变PC寄存器的值来确定下一条指令
PC寄存器为什么被设置为线程私有的？
  因为多个线程的话如果公用一个PC寄存器存储。A如果执行了3行,CPU切换到B则会直接从3开始,会产生问题。所以需要每个线程独有一份
---------------------------------------------------------------------------------------------------
栈是线程运行时需要的虚拟空间,堆是存储的单位
栈：每个线程运行需要的内存
栈帧：每个方法运行时需要的内存(参数、局部变量、返回地址 都需要占用内存)

Java栈(虚拟机栈)是什么？
  虚拟机栈是线程私有的.内部是以栈帧为单位保存.一个栈帧对应一个Java方法
栈的执行原理是什么？
  1.栈是先进后出,以栈帧为单位。虚拟机的操作指令只针对栈顶的方法. 执行引擎运行的字节码指令是针对当前栈帧操作的
    栈帧：是一块内存。存放方法的各种数据信息(参数、局部变量、返回地址)。当前执行的栈帧叫当前栈帧，不同栈帧不能相互访问,一个栈帧
    的返回结果会传递给上一个栈帧。           return  都会返回函数,导致栈帧弹出  异常
  栈帧内部结构： 1.局部变量表(local variables)本地变量表：
                   1.主要存储方法的参数和定义在方法体内的局部变量(这些数据类型包括8种基本数据类型,应用类型,redurnAddress)
                   2.局部变量表在栈帧内,栈帧在栈内,一个线程拥有一个栈,所以不存在数据安全问题。单线程操作
                   3.局部变量表的最大容量是在编译的时候就确定的。运行期不会改变
                   4.局部变量表中的局部变量只在当前方法有效.当方法结束局部变量表会随栈帧一起销毁
                   5.局部变量表基本存储单位是slot(槽)  是一个数值类型的一维数组。32位以内一个槽64位2个槽
                        1.如果占两位的访问拿起始位置索引。
                        2.如果是构造方法或者实例方法。会在开始多一个该对象的引用。this
                        3.slot是可以重复利用。如果局部变量失效新变量会占用局部变量空出来的位置
                2.操作数栈(operand stack)表达式栈： 后进先出
                   1.在方法执行过程中,根据字节码指令,在操作数栈里写入数据或提取(复制,交换,求和)数据
                3.动态链接(Dynamic linking):指向运行时常量池的方法引用：
                4.方法返回地址(return Address)正常或者异常退出的定义：
                5.一些附加信息
-------------------------------------------------------------------------------------------------------
本地方法栈： 本地方法运行所需要的内存就是本地方法栈
   本地方法：
      java有一些限制,不能直接跟操作系统底层打交道,所以需要用C或C++编写的本地方法来真正于底层操作系统打交道
   本地方法有哪些
     wait  notify  hasCode
------------------------------------------------------------------------------------------------------
堆和方法区是线程共享的区
堆：通过new关键字创建的对象都使用堆的内存
  特点：
    1.线程共享的,堆中对象都需要考虑线程安全的问题
    2.有垃圾回收机制  (不再使用的内存就会垃圾回收)
堆内存诊断
  1.jps工具
     查看当前系统中有哪些Java进程    直接在IDEA的Terminal命令窗口中 输入jps 可以返回进程号
  2.jmap工具
     查看堆内存占用情况     jmap -heap 进程号  查看堆内存
  3.jconsole工具
     图形界面的,多功能检测的工具,可以连续检测.  可以检测线程数量,CPU占用率,堆内存和加载类的数量   Terminal命令窗口jconsole
  4.jvisualvm  可视化虚拟机   于jconsole类似,但是有一个堆抓取工具可以将占用对的对象进行排序查看,以此来排查优化堆内存
--------------------------------------------------------------------------------------------------------
线程运行诊断
1.CPU占用过高
  top命令可以查看CPU占用  从而获取进程ID(PID),使用PS命令可以查询具体进程内所有线程id(TID)对cpu占用情况
  PS H -eo   (H打印线程的进程数)(打印感兴趣的信息 后面跟PID进程 TiD线程 %CPU cpu占用)
  jstack Pid 可以查看具体信息,将线程id转换成16进制,可以查看具体Java代码行数
2.程序一直没有结果
  jstack pid 查看具体信息,如果存在死锁下面会告诉存在死锁的两个线程及代码行数。
死锁原因：1线程锁住方法A然后sleep3s 再此期间2线程锁住方法B然后要访问方法A 所以需要等待,1线程sleep结束访问方法B 也需要等待
         相互若无外力 一直等待造成死锁
------------------------------------------------------------------------------------------------
方法区
  1.6内存结构 ：
    方法区占用JVM内存,使用的 PermGen(永久代)的实现。
      1.class(类的信息)
      2.classLoader(类加载器信息)
      3.运行时常量池 ：其中最重要的就是字符串常量池StringTable (hastable结构,不能扩容,初始没有遇到会增加字符串)
         String s1=“a"; String s2="b";  String s3="ab";  都是存放在字符串常量池中的
         String s4=s1 + s2;   s1,s2是变量可能被修改,所以在运行期间用Stringbuilder拼接
           相当于StringBuilder().append(s1).append(s2).toString();  new String("ab");堆中
         String s5="a"+"b"; javac在编译期间的优化,编译期间结果就是ab了 去常量池中寻找,没有就创建
  1.8内存结构
    方法区占用本地内存,使用 Metaspace(元空间)的实现
      1.class(类的信息)
      2.classLoader(类加载器信息)
      3.运行时常量池 其中StringTable被移到堆中
StringTable(字符串常量池)特性
  1.字符串加载延迟加载,并不是直接放入常量池中,而是第一次引用的时候才加入常量池,后续存在直接使用
  2.可以避免创建重复字符串  字符串变量拼接原理时Stringbuilder的append方法而字符串常量是在编译期优化
  3.可以使用 intern
     1.8尝试将字符串放入串池,如果有不放入,没有就放入并且返回串池中的对象
     1.6尝试将字符串放入串池,如果有不放入,没有就复制一份放入并且返回串池中的对象
  4.当堆内存紧张时,不用的字符串常量也会被垃圾回收
StringTable调优  (底层是hasTable)
  1.当系统中字符串常量非常多,可以适当调大字符串常量池中桶的数量,减少hash冲突  默认6w个   -XX:StringTableSize
  2.当系统中需要大量的字符串,并且存在重复的话可以考虑将字符串入池来节约空间
二进制字节码文件(类基本信息,常量池,类方法定义(包含虚拟机指令))  javap -v  *.class 反编译
  静态常量池：
     存放在class文件中,类似于一张表,虚拟机指令根据这张表找到要执行的类名,方法名,参数类型,参数值等信息
  运行时常量池
     将常量池中的类被加载时,他的常量池信息就会放到运行时常量池中,把里面的符号变成真实的内存地址
------------------------------------------------------------------------------------------------
直接内存(操作系统内存)  通过byteBuffer.DirectByteBuffer 可以创建直接内存  可以通过任务管理器查看内存,Java的工具监视不到
  1.常见于NIO操作,在数据读写时用作缓冲区
  2.分配回收成本高,但是读写性能非常高
  3.不受JVM内存回收管理
  底层unsafe对象完成创建内存和释放内存。内部使用cleaner(虚引用)来检测byteBuffer,当byte被回收cleaner就会调用unsafe的释放方法
------------------------------------------------------------------------------------------------
垃圾回收
如何判断对象可以被回收
  1.引用计数法
     当对象被其他变量引用就计数加一,不再引用减一。归零就可以回收
     弊端：循环引用  A引用b  B引用A  没人引用他们两个 但是各自引用都不能归零导致内存泄漏
  2.可达性分析法
    确定根对象(GC root)：肯定不能被回收的对象,垃圾回收之前对堆中所有对象扫描,看是否被根对象引用,如果没有被引用就可以回收
    那些对象可以作为根对象：  栈中引用的对象,本地方法引用的对象,静态属性引用的对象,常量池引用的对象


Java中4中引用
强引用：等于直接赋值就是强引用  赋值null取消强引用  不会被垃圾回收。当引用全部断开时垃圾回收
软引用：垃圾回收后内存还是不够会发起再次回收回收软引用      可以配合引用队列来释放软引用自身
  场景：使用软引用加载图片,内存不足前面加载过的就会释放, 防止OOM,要打开再次加载就可以
弱引用：只要发送垃圾回收,不管内存是否充足都会回收弱引用     可以配合引用队列来释放弱引用自身
虚引用：必须配合引用队列,bytebuffer被对象被回收后,将此虚引用放入引用队列,线程调用虚引用释放直接内存
终结器引用：所有对象都继承Object 而Object中有一个finalize终结方法 当对象重写了终结方法,需要被终结器引用所调用。
      垃圾回收时,终结方法入队,终结器引用就找到终结方法进行调用,第二次垃圾回收时回收终结器引用

垃圾回收算法：  实际使用中不是只使用一种,是多种混合使用的
   1.标记清除：将没有被GCRoot引用的对象做标记,清楚标记地址并不是清楚内存,而是将内存地址起始地址存放到空闲列表中提供使用
     优点：速度快  只需要将起始地址做记录就完成清除  缺点 容易产生内存碎片
   2.标记整理：将没有被GCRoot引用的对象做标记,将保留的对象整理成一块连续的内存,剩余一块连续内存
     优点：没有内存碎片   缺点：整理会移动对象,设计东西多，效率低
   3.复制算法：将内存区划分成大小相等的两个区,其中一个空闲,将GCroot标记的对象复制到空闲区域,清空第一个区然后交换两个区位置
     优点 没有内存碎片   缺点  会占用双倍的内存空间
   4.分代垃圾回收机制  (新生代(伊甸园、幸存区From、幸存区To)   老年代)
     1.老年代：有的对象需要长时间使用,放入老年代
     2.新生代：用完可以丢弃的对象放入新生代,因此可以设计不同的垃圾回收,老年代很久一次新生代垃圾回收频繁
对象创建存放在新生代的伊甸园中,当伊甸园空间不足时,触发MinorGc使用可达性分析算法进行标记,被标记的对象放入新生代幸存区To,将寿命+1
交换新生代From和To的内存区域,将伊甸园没有被标记的释放,第二次伊甸园空间不够继续MinorGC,区别就是可达性分析算法还要多加一个From内存
然后标记的放到To,交换位置寿命+1,当寿命到达一个限制就将这个对象放入老年代.
使用复制算法,并且在发送MinorGC时暂停所有用户线程,垃圾回收结束恢复运行  寿命4bit最大15
当老年代空间不足,会执行FUllGC,其他线程暂停时间更长,清理速度较慢。如果fullGC结束还不够就OOM

新生代晋升老年代方式                创建的线程发送OOM不会影响主线程继续执行
   1.长期存活,并且阈值超过指定值
   2.GC后幸存区放不下,只能放入老年代
   3.动态年龄判断,当幸存区内存超过一半,找到年龄最大的加一作为阈值,如果下次minorGC还存活就放入老年代
   4.特别大的对象,伊甸园清空也放不下,就会直接放入老年代
触发MinorGC之前的检查判断
   空间担保机制：当发生minorGC时,虚拟机会检测老年代连续内存>新生代All对象内存
      满足：可以进行minorGC
      不满足：检查虚拟机参数是否允许空间担保：不允许直接进行FullGC
          如果允许检查连续内存>历次晋升老年代的平均大小  若大于则尝试minorGC  若小于平均大小则进行FullGC
安全点(SafePoint)：
  GC垃圾回收之前,所有Java线程都需要进入安全点才能开始垃圾回收。
    1.循环的末尾
    2.方法返回前
    3.抛出异常的位置
垃圾回收器
  1.串行(-XX:UserSerialGC=Serial + SerialOld)
      Serial生存在新生代  使用复制算法           SerialOld生存在老年代    使用标记+整理算法
     单线程,适用于堆内存较小,CPU个数少
  2.吞吐量优先(-XX:UserParallelGc  还可以指定线程数) 1.8默认开启
     多线程,使用堆内存较大,多核CPU,单位时间内STW时间最短            0.2 0.2  =0.4  单位时间内STW时间短
  3.响应时间优先
     多线程,使用堆内存较大,多核CPU,尽可能让STW(其他线程暂停时间)时间最短   0.1 0.1 0.1 0.1 0.1=0.5
垃圾回收调优
  1.
调优方向：
  1.GC调优
  2.IO调优
  3.锁竞争调优
  4.CPU占用调优
  5.内存调优
------------------------------------------------------------------------------------------------
JVM架构模型：
  1.基于栈式架构特点：
    1.涉及和实现更简单,适用于资源受限系统
    2.避开寄存器分配难题。使用零地址指令方式分配
    3.执行过程依赖于操作栈,指令集小,编译器更容易实现
    4.不需要硬件支持,可以执行更好,更好实现跨平台
    优点：跨平台性,指令集小
    缺点：指令多,频繁入栈出栈.执行性能比寄存器方式差
  2.基于寄存器架构特点
    1.典型的应用式X86二进制指令集
    2.指令集架构完全依赖于硬件,可移植性差
    3.性能优秀,执行更高效
    4.花费更少的指令去完成一个操作。一般是一地址指令,二地址指令和三地址指令。而基于栈的架构是零地址指令
  3. 总结
    1.优化跨平台设计。java的指令都是基于栈方式实现的
    2.不同的CPU架构不同,所以不能设计为寄存器的
-------------------------------
初始堆大小                    -Xms
最大堆大小                    -Xmx(-XX:MaxHeapSize)
新生代大小                    -Xmn(-XX:NewSize初始  -XX:MaxNewSize)
GC详情：                     -XX:PrintGCDetails -verbose:gc
幸存区比例（动态和固定）  晋升阈值    设置FullGC之前是否进行MinorGC,一般开启 可以加速FullGC


如果想要手写一个JVM虚拟机,主要考虑那些结构？   类加载器和执行引擎

数组+链表  链表长度超过8变成红黑树      下层是table数组   key value可以为空   默认是16  加载因子0.75   就是一个最优的设置
数组长度超过12数组扩容  扩容后就是重新has计算
hastable  key不为空
单链表：开始节点是头节点  只保存下一节点指针 删除只需要改变引用 不需要移动数据  时间复杂度 O(n)  只能从前向后查
双向链表：头和尾引用null 前后都可以查    删除只需要改变引用 不需要移动数据     时间复杂度 O(n)
二叉树时间复杂度  O(n)
红黑树和二叉平衡数  时间复杂度O(lgn)
b 和  1到树深之间  b+树  稳定在树高

冒泡排序：  一个一个比较 最大的放最后面                           时间复杂度：O(n方)    空间复杂度 O（1）
选择排序：  每次从已知数据中拿最小的放到前面                       时间复杂度：O(n方)    空间复杂度 O（1）
插入排序：  每次插入一个值,放到链表中相应位置                      时间复杂度：O(n方)    空间复杂度 O（1）



































