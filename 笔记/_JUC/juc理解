1.守护线程和用户线程区别？
  1.当jvm中全是守护线程,那么JVM将会关闭,守护线程也会关闭,但是如果还存在一个用户线程,那么jvm就不会关闭一直存活
  2.通过setDaemon可以将用户线程变成守护线程    典型的守护线程：GC垃圾回收线程
2.什么是线程上下文切换
  并发模式下宏观看起来多线程一起执行,但是微观是CPU分片处理,某一时刻只有一个线程在执行,多个线程来回切换就是上下文切换。当再次
  切换回当前线程会去找(pc寄存器)程序计数器来恢复执行位置继续执行
3.为什么While可以防止虚假唤醒而if不行？
  因为线程被唤醒后执行的是wait之后的代码,如果是if就执行完出if判断了  而while往下执行还会进行一次判断  所以能防止虚假唤醒

3.死锁 活锁、饥饿区别
  1.死锁：两个或者两个以上线程,因抢夺资源造成的相互等待,没有外力作用就一直等待。
     1.
  2.活锁：因为条件不满足,一直失败然后重试。状态会改变,并且有可能自己解锁。
     1.单体活锁：  我理解像自旋锁就像单体活锁,失败之后一直重试,如果一直不满足就会一直阻塞
     2.协同活锁：  两个线程发生了碰撞,重新尝试还是碰撞,一直这样下去就会产生活锁
        解决方案：1.引入随机值减少碰撞概率
  3.饥饿： 线程无法获取资源,无法执行
     1.优先级高的一直执行,导致优先级低的无法执行     2.线程await之后总是其他线程被唤醒。造成无法执行
4.线程调度算法是什么？
  时间片轮转方式切换，
  也可以通过设置优先级,抢占式,但是可能会造成线程饥饿
5.为什么要引入Executor框架？和Executors区别      todo：juc书签
  1.可以对线程统一管理,并且减少线程创建和销毁的开销,可以创建最大线程数和拒绝策略来控制线程数,实现线程复用,
  Executor框架包括：线程池，Executor，Executors，ExecutorService，CompletionService，Future，Callable等。
  Executors提供四张线程池创建。 single fixed schedule cached  但是可能造成OOM  推荐使用ThreadPoolExecutor
6.如何在Windows 和 Linux 上查找哪个线程使用的 CPU 时间最长？
  1.window不知道,linux先查询java程序的pid 然后使用top可以查找出cpu占用最高的线程,可以具体查看堆栈信息。一般都是死循环导致卡死
7.什么是原子操作？在 Java Concurrency API 中有哪些原子类(atomic classes)？
  不可被中断的一个或者一系列操作,要么全部执行要么全不执行,避免多线程操作引发的并发修改问题,java中可以通过加锁或者cas实现原子操作,
  AtomicInteger,AtomicLong,AtomicReference 。但是CAS也会有 ABA问题,一直循环消耗资源,只能对一个共享变量操作
  解决方案：如果需要多个共享变量还是需要用锁 2.一直循环资源的话如果jvm支持暂停指令好像可以提高CPU效率
8.什么是 Callable 和Future?
  callable是线程实现的一种方式,实现callable类重写call方法,强大之处是还可以接收线程的返回值,和接收抛出的异常。
  它执行使用了适配器设计模式,我thread类中没有和callable的关联,但是runnable子类futureTask可以可以传入callable实现类
9.什么是 FutureTask?使用 ExecutorService 启动任务。
  1.futuretask实现了future 和runnablefuture 可以当作runbale接口使用所有可以用Execuorservice执行
  2.实现了callable接口,可以使用get获取返回值,但是如果线程没有执行完会阻塞等待
10同步和互斥:
  容易产生线程安全问题的代码加锁,防止出现并发修改问题。 synchronized lock
  比如读写锁就是互斥的,我写的时候不可以读,读的时候不可以写。但是读的时候多个线程同时读,写只允许一个线程
11.竞争条件：
  多个线程对同一个数据进行操作,可能前一个线程没有操作完,下一个线程就进行操作。就会造成数据结果的未知变化
12.你将如何使用 thread dump？你将如何分析 Thread dump   todo
  1.新建状态（ New）
    用 new 语句创建的线程处于新建状态，此时它和其他 Java 对象一样，仅仅在堆区中被分配了内存
  2.就绪状态（ Runnable）
    当一个线程对象创建后，其他线程调用它的 start()方法，该线程就进入就绪状态， Java 虚拟机会为它创建方法调用栈
    和程序计数器。处于这个状态的线程位于可运行池中， 等待获得 CPU 的使用权
  3.运行状态
    处于这个状态的线程占用 CPU， 执行程序代码。只有处于就绪状态的线程才有机会转到运行状态。
  4.阻塞状态（ Blocked
    阻塞状态是指线程因为某些原因放弃 CPU， 暂时停止运行。当线程处于阻塞状态时，Java 虚拟机不会给线程分配 CPU。
    直到线程重新进入就绪状态， 它才有机会转到运行状态。
       1.位于对象等待池中的阻塞状态（ Blocked in object’ s wait pool） ：
          当线程处于运行状态时， 如果执行了某个对象的 wait()方法， Java 虚拟机就会把线程放
          到这个对象的等待池中， 这涉及到“ 线程通信” 的内容。
       2.位于对象等待池中的阻塞状态（ Blocked in object’ s wait pool） ：
          当线程处于运行状态时， 试图获得某个对象的同步锁时， 如果该对象的同步锁已经被其
          他线程占用， Java 虚拟机就会把这个线程放到这个对象的锁池中， 这涉及到“ 线程同
          步” 的内容
       3.其他阻塞状态（ Otherwise Blocked） ：
         当前线程执行了 sleep()方法，或者调用了其他线程的 join()方法，或者发出了 I/O 请求
         时， 就会进入这个状态。
  5.死亡状态（ Dead）
    当线程退出 run()方法时， 就进入死亡状态， 该线程结束生命周期。
13 为什么我们调用 start()方法时会执行run()方法，为什么我们不能直接调用run()方法？
  当你调用 start()方法时你将创建新的线程， 并且执行在 run()方法里的代码。
  如果直接调用 run()方法,只是一个普通方法,不会创建新的线程  只是在主线程顺序执行
14.什么是不可变对象，它对写并发应用有什么帮助？          todo
  一旦创建就不能改变,最常用就是String对象,不可用对象对应的类就是不可变类
  可以让并发变得简单,可以解决共享变量的互斥访问,避免加锁提高复杂度。
  a=hello whj;  a.replace(whj,wyq);  a.replace(wyq,whj);  如果不可变,第三局不执行 如果可变
15.如何停止一个正在运行的线程？
   1.使用stop命令停止线程,是一种恶意中断,无论执行是否完整都会立即中断线程,可能会破坏原子性
   2.使用 interrupt 生成中断标记,使用isInterrupt判断是否存在终端标记,return中止
   3.当线程处于  sleep,wait,join 的时候,如果使用interrupt会抛出异常终止
   4.使用volatile共享变量实现线程中断  while(共享变量)  设置false可中断循环
16.如何实现线程之间的通讯？
 　　1、wait和notify/notifyAll
　　 2、await和signal/signalAll
 　　3、线程中断和共享变量
　　 4、CyclicBarrier 栅栏
　　 5、CountDownLatch 闭锁
　　 6、Semaphore 信号量
17.什么叫线程安全？servlet 是线程安全吗?
  多线程环境下,不会产生并发修改问题。就是线程安全
  servlet在web.xml就创建了实例,单实例多线程  访问同一个servlet可能导致数据出错
  controller和servlet类似,如果非要设置成员变量可以设置为多例,解决线程安全问题
  struts2的action是多实例,每个请求都会创建一个实例,所以不需要考虑线程安全问题
18  java实现阻塞队列  linklist
19.一个线程运行时发生异常会怎样？
  如果异常没有捕获,则程序会终止。  如果异常进行了捕获,程序会继续执行
20.





























































































