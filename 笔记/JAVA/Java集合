Iterable接口(迭代器)： 实现此接口表示对象可迭代,常用方法 foreach 和 Iterator进行迭代
    自定义只需要实现 Iterable的Iterator方法创建一个Iterator类拥有便利的hasNext和next方法即可
Collection接口(集合框架): 提供了对集合对象一些通用方法,add,remove,Stream等接口,是下面的父类
    Set
    List接口 :可以设置null值 有序可重复
        ArrayList(基于动态数组)：1.查询比Linked快, 2.增加和删除可能导致大量的下标修改,相对比慢一些   3.查询多推荐使用ArrayList     1000W数据量 头插慢 尾插和中间插快
        LinkedList(基于双向链表)：1.线性结构查询需要移动指针按序查找,相对比慢一些。 2.增删快     4.增删频繁推荐使用LinkedList
        Vector 和ArrayList 相同点：基于索引,和ArrayList都可以存null值,也都可以通过索引值对元素进行访问
        Vector 和ArrayList 不同点：Vector 加锁保证线程安全,效率比ArrayList低,一般使用CopyOnWriteArrayList或Collections里的synchronizedList
        Array  和ArrayList 区别： 1.数组可以使用基本数据类型和引用类型 集合只能使用引用类型 2.数组需要指定大小,集合自动扩容  3.ArrayList提供的方法多 入addAll等
        总结：如果不确定就使用 ArrayList 如果确定头插的操作比较多使用LinkedList。 LinkedList可以用作可视化链路追踪.
    Queue
Map接口(集合框架):表示一组键值对形式  只有 ConcurrentHashMap 线程安全
    TreeMap: 红⿊树
    HashTable:                不允许空key,底层hashcode方法为空会抛空指针 HashMap如果key为空会转换成0调用hashcode方法
    HashMap: 数组+链表/红⿊树   允许空key空value 不可重复,key相同覆盖
    LinkedHashMap: 数组+链表/红⿊树+双向链表
    ConcurrentHashMap: 数组+链表/红⿊树

Collections工具类： 提供了很多静态方法,例如Sort对list集合排序(需要对象实现 Comparable 实现 compareTo方法)、获取线程安全的集合对象、获取集合最大最小值


1.Java原生就有数组,为什么还要引入ArrayList？
    因为原生数组需要指定长度,少了装不下多了浪费内存,而 ArrayList 实现了动态扩容。
    初始容量为空数组 让第一次add时候容量变成10 每次add数据都会计算数组空间是否足够,不够就会自动扩容
    扩容方法：grow 1.参数为集合现有元素和要添加元素所占实际大小  2.获取旧容量  3.扩容1.5倍新容量
            4.如果新容量小于第一步所占大小,直接扩容为第一步大小  5.如果新容量大于数组最大值,实际占用大于数组最大返回Integer最大 否则返回数组最大
    扩容完毕调用本地方法 arraycopy 进行数组复制。 只是浅拷贝
2.为什么 数组MAX_ARRAY_SIZE 和Integer.MAX - 8 ？
    因为数组需要额外存储元数据信息,所以数组最大大小为 Integer.MAX - 8
3.copyOnWrite原理
    add方法是加锁的,写的时候不在原有数据上操作,而是复制出一份当写完毕将指针指向新元素,初始大小为0,每次复制会进行+1操作 所以不需要扩容 但是依然需要arraycopy的拷贝
    缺点：1.消耗内存,每次add都会复制数组  2.因为读不加锁,所以保证数据最终一致性。 如果A线程读还没读完的时候  B线程将集合清空但是指针没有改变 A还是会读取到集合数据

















