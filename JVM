sun公司的 hotspot 虚拟机  主学   还知道IBM的J9虚拟机。apache的 harmony
Java跨平台语言
    一次编译到处运行。  java文件编译成二进制字节码文件。  可以在不同的操作系统JVM中解析运行
JVM：支持多语言混合编程。只需要关心如何编译成字节码文件即可
    1.自动内存管理
    2.自动垃圾回收
    优点：降低内存泄漏风险
    缺点：弱化程序员处理OOm的经验
虚拟机：就是一台虚拟的计算机   计算机上操作系统-》软件   操作系统是系统软件.qq软件是应用软件
    1.系统虚拟机：对物理计算机的仿真。VMware
    2.程序虚拟机：相当于应用。在操作系统上按照,代表JVM
--------------------------------------------------------------------------------------------------
JVM的生命周期：
  1.启动
    java虚拟机启动是通过引导类加载器创建一个初始类来完成的.这个类是由虚拟机的具体实现指定的
  2.执行：执行Java程序
    执行一个java程序的时候,真正执行的是一个Java虚拟器进程。   程序启动才执行,程序结束就停止
  3.退出
    1.程序结束正常退出
    2.遇到异常或者错误 终止
    3.操作系统错误  终止
    4.线程调用RunTime类或者System类的exit方法结束或者直接调用RunTime类halt方法终止线程
    5.JNI（JAVA native interface）:描述了用JNI加载或卸载虚拟机时,java虚拟器的退出情况
--------------------------------------------------------------------------------------------------
Java执行流程
  1.java文件通过前端编译器生成.class文件
     1.词法分析-》语法分析-》语言/抽象语法树-》语义分析-》注解抽象语法树-》字节码生成器
  2.经过Java虚拟机
     1.类加载器
     2.字节码校验器
     3.执行引擎                 高级语言翻译成机器指令的过程
        1.翻译字节码(解释运行)：将字节码文件编译成字节码指令
        2.JIT编译器(编译运行) ：将字节码指令翻译成机器指令。同时将反复执行的代码缓存起来。保证执行性能
     4.操作系统
JVM整体结构：
  上层
    1.类装载子系统(类加载器)字节码文件通过类加载器生成大的Class对象
  中层（运行时数据区 Runtime date Area）   其中方法区和堆是多个线程共享的,而Java栈,本地方法栈和pc寄存器是每个线程都有一份的
    1.方法区(method Area)元数据区:有可能造成OOM
    2.堆（heap）:有可能造成OOM
    3.Java栈(虚拟机栈):没有GC 有可能造成OOM
    4.本地方法栈：:有可能造成OOM
    5.程序计数器(PC寄存器)：没有OOM,没有GC
  下层
    1.执行引擎(计算机只执行机器指令,而字节码文件不等同于机器指令,执行引擎将字节码文件翻译成机器语言)
      1.解释器
      2.编译器(JIT编译器)
      3.垃圾回收器
    2.本地方法接口
    3.本地方法库

----------------------------------------------------------------------------------------
类加载区
插件jclasslib  java编译成class字节码文件。可以通过这个插件查看
    1.init  是类的字节码文件
    2.clinit 如果有静态代码块或者静态变量赋值就会自动生成
父类静态字段-》父类静态代码块-》子类静态字段-》子类静态代码块-》父类成员变量(非静态字段)-》父类非静态代码块-》父类构造器-》子类成员变量-》子类非静态代码块-》子类构造器
类加载器(类加载子系统)
    这四种加载器是包含关系。不是父子类继承的关系    ClassLoader是一个抽象类
 1.Bootstrap ClassLoader引导类加载器(启动类加载器)。C和C++编写,嵌套在JVM内部
    1.获取引导类加载器  ClassLoader BootStrapClassLoader = extClassLoader.getParent();  结果为null
    2.Java的核心类库(rt.jar,resource.jar)都是由引导类加载器加载的,只加载包名为java,javax,sun开头的类
    3.扩展类加载器和应用类加载器是由引导类加载器加载的
 2.Extension ClassLoader扩展类加载器。Java编写 ExtClassLoader
    1.获取扩展类加载器 ClassLoader extClassLoader = systemClassLoader.getParent();
    2.继承于ClassLoader。也属于自定义加载器。  父类加载器是启动类加载器
    3.加载的是jre/lib/ext目录下的文件
 3.System ClassLoader系统类加载器(应用类加载器)。Java编写    AppClassLoader
    1.获取系统类加载器  ClassLoader systemClassLoader = new getSystemClassLoader();
    2.用户自定义的类默认是由系统类加载器加载
    3.继承于ClassLoader。也属于自定义加载器。  父类加载器是扩展类加载器
 4.自定义类加载器
    1.什么场景下需要自定义加载器（为什么要自定义类加载器）？
        1.隔离加载类：避免重名类冲突
        2.修改类加载方式
        3.扩展加载源
        4.防止源码泄露
    2.如何创建自定义加载器？
        1.创建一个类继承ClassLoader类 覆盖findClass方法
        2.创建一个类继承URLClassLoader方法
 作用  ：将class字节码文件转换成Class对象
   1.类加载器负责加载class文件,class文件在文件开头有特定的文件标识  CAFEBABE魔术
   2.加载器只负责加载文件,是否可以运行由执行引擎决定
   3.加载类的信息存放于一块方法区的内存空间,除了类的信息外,方法区还会存放运行时常量池信息
 1.加载阶段(loading)
   1.通过一个类的全限定名获取定义此类的二进制字节流
   2.将这个字节流代表的静态存储结构转换为方法区的运行时数据结构
   3.在内存中生成一个CLASS对象。作为方法区这个类的各个数据的访问入口(通过对象访问具体方法)
 2.链接阶段（linking）  将 Java 类的二进制代码合并到 JVM 的运行状态之中的过程。 在链接之前，这个类必须被成功加载
   1.验证(Verify):
       1.确保Java类的二进制表示在结构上是完全正确的。 如果错误会抛出VerifyError
       2.主要包括四种验证：文件格式验证、元数据验证、字节码验证、符号引用验证
   2.准备(prepare):
       1.创建Java类中的静态域，并将这些域的值设为默认值。int(0) 引用类型(null) boolean（false）
       2.如果是final常量在编译的时候已经分配值了,所以这个阶段会显式初始化
   3.解析(resolve)
       1.确保当前类引用的其他类被正确地找到，该过程可能会触发其他类被加载。 符号引用
 3.初始化阶段(initial)
   1.Java类第一次被真正使用到的时候，JVM会进行该类的初始化操作。主要操作是执行静态代码块和初始化静态域。
   2.准备过程就是将静态变量分配默认值。而这个阶段会按照代码的顺序执行静态代码块和初始化静态变量。
双亲委派机制 ： Java虚拟机需要Java类的时候才加载成Class对象。加载方式是双亲委派机制。既把请求交给父类处理。任务委派模式
    1.如果一个类加载器收到加载类请求,并不会直接加载。而是向上委托给父类依次递归到启动类加载器
    2.如果父类加载器可以完成加载任务，就成功返回。如果如类加载器无法完成,交给子类尝试。依次递归
    优势：避免类的重读加载。   2.保护程序安全,防止API被篡改
    禁止自定义类使用引导类加载器加载。不然会报错。也即是不要使用引导类加载的路径。java,javax,sun
沙箱安全机制：
    就是对Java的源代码的一种保护机制。   自定义java.lang.String类 写一个main方法执行。报错没有main方法,因为加载的是rt.Jat包下的String类
在JVM中表示两个Class对象是否为同一个类的条件？
    1.类的完整类名必须一致。包括包名
    2.加载这个类的ClassLoader必须是一个
JVM必须知道一个类型是由启动类加载的还是用户类加载的,如果是用户类加载的,JVM会将类加载器的一个引用作为类型的一部分保存在方法区中
当解析一个类型到另一个类型引用的时候,JVM要保证这两个类型的加载器是相同的

Java程序对类的使用方式：主动使用和被动使用。
    区别：主动使用会初始化类。被动使用不会导致类初始化

----------------------------------------------------------------------------------------------------------------------
运行时数据区（RunTime date area）
内存：非常重要的系统资源,是硬盘和CPU的中间仓库及桥梁,承载着操作系统和应用程序的实时运行。
    JVM内存布局规定了Java在运行过程中内存的申请,分配,管理的策略,保证了JVM的高效运行,不同的JVM对内存的划分方式和管理机制存在差异
Java虚拟机定义的运行时数据区,其中一些会随着虚拟机(进程)启动而启动,虚拟机(进程)退出而销毁。比如 堆和堆外内存(永久代或元空间,代码缓存)
另一些则与线程一一对应，这些与线程对应的数据区域会随线程的开始和结束而创建和销毁。 比如：程序计数器(PC寄存器),栈,Java栈(虚拟机栈)
线程：
    1.JVM运行一个应用有多个线程并发执行
    2.Hotspot的虚拟机里每个线程和操作系统的本地线程直接映射.
    3.当Java线程准备好执行后,操作系统的本地线程也同时创建,java线程终止后本地线程也会回收
    4.操作系统负责所有线程的安排调度到任何一个可用的CPU上,一旦本地线程初始化成功,就会调用Java线程中的Run方法
    5.本地线程回收前决定JVM要不要终止。看当前线程是不是最后一个非守护线程
守护线程和普通线程
虚拟机里主要的后台程序线程
    1.虚拟机线程
    2.周期任务线程
    3.GC线程
    4.编译线程
    5.信号调度线程
---------------------------------------------------------------------------------------------
PC寄存器（程序计数器）PC Register
作用：用来存储下一条指令的地址。由执行引擎读取下一条指令。由字节码解释器改变这个程序计数器的值
    2.占用很小的空间,是运行速度最快的内存区域。是线程私有的,生命周期与线程生命周期一致
    4.PC寄存器里保存有当前正在执行的JVM指令的地址。如果是Native方法计数器是空的(undefined)
    5.他是程序控制流的指示器,分支,循环,异常处理,跳转,线程恢复等基础功能都需要依赖计数器完成
使用PC寄存器存储字节码指令有什么用（为什么使用PC寄存器记录当前线程的执行地址）？
  并发执行多个线程。CPU需要不停切换各个线程,切换回来需要知道从哪开始。并且JVM解释器需要改变PC寄存器的值来确定下一条指令
PC寄存器为什么被设置为线程私有的？
  因为多个线程的话如果公用一个PC寄存器存储。A如果执行了3行,CPU切换到B则会直接从3开始,会产生问题。所以需要每个线程独有一份
---------------------------------------------------------------------------------------------------
栈是运行时的单位,堆是存储的单位
  既：栈解决程序如何执行,数据如何处理,堆解决如何存储数据。


Java栈(虚拟机栈)是什么？
 虚拟机栈是线程私有的.生命周期和线程一样.内部是以栈帧为单位保存.一个栈帧对应一个Java方法
栈的执行原理是什么？
  1.栈是先进后出,以栈帧为单位。Java每个方法对应一个栈帧。虚拟机的操作指令只针对栈顶的方法.
    栈帧：是一块内存区块,是一个数据集。维系着方法执行过程中各种数据信息。当前执行的栈帧叫当前栈帧，执行引擎运行的字节码指令是针对当前栈帧操作的
    不同栈帧不允许相互访问,一个栈帧的返回结果会传递给上一个栈帧。
    return  都会返回函数,导致栈帧弹出
    异常
  栈帧内部结构： 1.局部变量表(local variables)本地变量表：
                   1.主要存储方法的参数和定义在方法体内的局部变量(这些数据类型包括8种基本数据类型,应用类型,redurnAddress)
                   2.局部变量表在栈帧内,栈帧在栈内,一个线程拥有一个栈,所以不存在数据安全问题。单线程操作
                   3.局部变量表的最大容量是在编译的时候就确定的。运行期不会改变
                   4.局部变量表中的局部变量只在当前方法有效.当方法结束局部变量表会随栈帧一起销毁
                   5.局部变量表基本存储单位是slot(槽)  是一个数值类型的一维数组。32位以内一个槽64位2个槽
                        1.如果占两位的访问拿起始位置索引。
                        2.如果是构造方法或者实例方法。会在开始多一个该对象的引用。this
                        3.slot是可以重复利用。如果局部变量失效新变量会占用局部变量空出来的位置
                2.操作数栈(operand stack)表达式栈： 后进先出
                   1.在方法执行过程中,根据字节码指令,在操作数栈里写入数据或提取(复制,交换,求和)数据
                3.动态链接(Dynamic linking):指向运行时常量池的方法引用：
                4.方法返回地址(return Address)正常或者异常退出的定义：
                5.一些附加信息
生命周期？ 和线程一致
作用？主管Java程序运行,保存方法的局部变量,部分结果,并参与方法的调用和返回。 局部变量包括(8种基本数据类型和引用类型(对象的地址))
优点？访问速度仅次于PC计数器   2.不存在垃圾回收问题   3.JVM对栈的操作只有方法执行入栈和方法结束出栈

JVM架构模型：
  1.基于栈式架构特点：
    1.涉及和实现更简单,适用于资源受限系统
    2.避开寄存器分配难题。使用零地址指令方式分配
    3.执行过程依赖于操作栈,指令集小,编译器更容易实现
    4.不需要硬件支持,可以执行更好,更好实现跨平台
    优点：跨平台性,指令集小
    缺点：指令多,频繁入栈出栈.执行性能比寄存器方式差
  2.基于寄存器架构特点
    1.典型的应用式X86二进制指令集
    2.指令集架构完全依赖于硬件,可移植性差
    3.性能优秀,执行更高效
    4.花费更少的指令去完成一个操作。一般是一地址指令,二地址指令和三地址指令。而基于栈的架构是零地址指令
  3. 总结
    1.优化跨平台设计。java的指令都是基于栈方式实现的
    2.不同的CPU架构不同,所以不能设计为寄存器的
-------------------------------
参数调优
如何设置虚拟机栈大小   -Xss设置虚拟机栈大小  k-》kb  MB-》MB    在启动设置VMOptions设置
















如果想要手写一个JVM虚拟机,主要考虑那些结构？   类加载器和执行引擎
JDK JRE  JVM






































